(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const o of document.querySelectorAll('link[rel="modulepreload"]'))
        s(o);
    new MutationObserver(o => {
        for (const l of o)
            if (l.type === "childList")
                for (const f of l.addedNodes)
                    f.tagName === "LINK" && f.rel === "modulepreload" && s(f)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(o) {
        const l = {};
        return o.integrity && (l.integrity = o.integrity),
        o.referrerPolicy && (l.referrerPolicy = o.referrerPolicy),
        o.crossOrigin === "use-credentials" ? l.credentials = "include" : o.crossOrigin === "anonymous" ? l.credentials = "omit" : l.credentials = "same-origin",
        l
    }
    function s(o) {
        if (o.ep)
            return;
        o.ep = !0;
        const l = t(o);
        fetch(o.href, l)
    }
}
)();
var ud = {
    exports: {}
}
  , nl = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Xy;
function uA() {
    if (Xy)
        return nl;
    Xy = 1;
    var r = Symbol.for("react.transitional.element")
      , e = Symbol.for("react.fragment");
    function t(s, o, l) {
        var f = null;
        if (l !== void 0 && (f = "" + l),
        o.key !== void 0 && (f = "" + o.key),
        "key"in o) {
            l = {};
            for (var d in o)
                d !== "key" && (l[d] = o[d])
        } else
            l = o;
        return o = l.ref,
        {
            $$typeof: r,
            type: s,
            key: f,
            ref: o !== void 0 ? o : null,
            props: l
        }
    }
    return nl.Fragment = e,
    nl.jsx = t,
    nl.jsxs = t,
    nl
}
var $y;
function cA() {
    return $y || ($y = 1,
    ud.exports = uA()),
    ud.exports
}
var b = cA()
  , cd = {
    exports: {}
}
  , Ae = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Jy;
function fA() {
    if (Jy)
        return Ae;
    Jy = 1;
    var r = Symbol.for("react.transitional.element")
      , e = Symbol.for("react.portal")
      , t = Symbol.for("react.fragment")
      , s = Symbol.for("react.strict_mode")
      , o = Symbol.for("react.profiler")
      , l = Symbol.for("react.consumer")
      , f = Symbol.for("react.context")
      , d = Symbol.for("react.forward_ref")
      , v = Symbol.for("react.suspense")
      , y = Symbol.for("react.memo")
      , T = Symbol.for("react.lazy")
      , A = Symbol.iterator;
    function I(x) {
        return x === null || typeof x != "object" ? null : (x = A && x[A] || x["@@iterator"],
        typeof x == "function" ? x : null)
    }
    var V = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }
      , q = Object.assign
      , G = {};
    function J(x, ee, ae) {
        this.props = x,
        this.context = ee,
        this.refs = G,
        this.updater = ae || V
    }
    J.prototype.isReactComponent = {},
    J.prototype.setState = function(x, ee) {
        if (typeof x != "object" && typeof x != "function" && x != null)
            throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, x, ee, "setState")
    }
    ,
    J.prototype.forceUpdate = function(x) {
        this.updater.enqueueForceUpdate(this, x, "forceUpdate")
    }
    ;
    function ne() {}
    ne.prototype = J.prototype;
    function se(x, ee, ae) {
        this.props = x,
        this.context = ee,
        this.refs = G,
        this.updater = ae || V
    }
    var le = se.prototype = new ne;
    le.constructor = se,
    q(le, J.prototype),
    le.isPureReactComponent = !0;
    var ue = Array.isArray
      , fe = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null
    }
      , Ie = Object.prototype.hasOwnProperty;
    function U(x, ee, ae, ie, me, we) {
        return ae = we.ref,
        {
            $$typeof: r,
            type: x,
            key: ee,
            ref: ae !== void 0 ? ae : null,
            props: we
        }
    }
    function w(x, ee) {
        return U(x.type, ee, void 0, void 0, void 0, x.props)
    }
    function M(x) {
        return typeof x == "object" && x !== null && x.$$typeof === r
    }
    function P(x) {
        var ee = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + x.replace(/[=:]/g, function(ae) {
            return ee[ae]
        })
    }
    var k = /\/+/g;
    function B(x, ee) {
        return typeof x == "object" && x !== null && x.key != null ? P("" + x.key) : ee.toString(36)
    }
    function N() {}
    function $e(x) {
        switch (x.status) {
        case "fulfilled":
            return x.value;
        case "rejected":
            throw x.reason;
        default:
            switch (typeof x.status == "string" ? x.then(N, N) : (x.status = "pending",
            x.then(function(ee) {
                x.status === "pending" && (x.status = "fulfilled",
                x.value = ee)
            }, function(ee) {
                x.status === "pending" && (x.status = "rejected",
                x.reason = ee)
            })),
            x.status) {
            case "fulfilled":
                return x.value;
            case "rejected":
                throw x.reason
            }
        }
        throw x
    }
    function je(x, ee, ae, ie, me) {
        var we = typeof x;
        (we === "undefined" || we === "boolean") && (x = null);
        var Te = !1;
        if (x === null)
            Te = !0;
        else
            switch (we) {
            case "bigint":
            case "string":
            case "number":
                Te = !0;
                break;
            case "object":
                switch (x.$$typeof) {
                case r:
                case e:
                    Te = !0;
                    break;
                case T:
                    return Te = x._init,
                    je(Te(x._payload), ee, ae, ie, me)
                }
            }
        if (Te)
            return me = me(x),
            Te = ie === "" ? "." + B(x, 0) : ie,
            ue(me) ? (ae = "",
            Te != null && (ae = Te.replace(k, "$&/") + "/"),
            je(me, ee, ae, "", function(Gn) {
                return Gn
            })) : me != null && (M(me) && (me = w(me, ae + (me.key == null || x && x.key === me.key ? "" : ("" + me.key).replace(k, "$&/") + "/") + Te)),
            ee.push(me)),
            1;
        Te = 0;
        var Rt = ie === "" ? "." : ie + ":";
        if (ue(x))
            for (var We = 0; We < x.length; We++)
                ie = x[We],
                we = Rt + B(ie, We),
                Te += je(ie, ee, ae, we, me);
        else if (We = I(x),
        typeof We == "function")
            for (x = We.call(x),
            We = 0; !(ie = x.next()).done; )
                ie = ie.value,
                we = Rt + B(ie, We++),
                Te += je(ie, ee, ae, we, me);
        else if (we === "object") {
            if (typeof x.then == "function")
                return je($e(x), ee, ae, ie, me);
            throw ee = String(x),
            Error("Objects are not valid as a React child (found: " + (ee === "[object Object]" ? "object with keys {" + Object.keys(x).join(", ") + "}" : ee) + "). If you meant to render a collection of children, use an array instead.")
        }
        return Te
    }
    function X(x, ee, ae) {
        if (x == null)
            return x;
        var ie = []
          , me = 0;
        return je(x, ie, "", "", function(we) {
            return ee.call(ae, we, me++)
        }),
        ie
    }
    function oe(x) {
        if (x._status === -1) {
            var ee = x._result;
            ee = ee(),
            ee.then(function(ae) {
                (x._status === 0 || x._status === -1) && (x._status = 1,
                x._result = ae)
            }, function(ae) {
                (x._status === 0 || x._status === -1) && (x._status = 2,
                x._result = ae)
            }),
            x._status === -1 && (x._status = 0,
            x._result = ee)
        }
        if (x._status === 1)
            return x._result.default;
        throw x._result
    }
    var pe = typeof reportError == "function" ? reportError : function(x) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var ee = new window.ErrorEvent("error",{
                bubbles: !0,
                cancelable: !0,
                message: typeof x == "object" && x !== null && typeof x.message == "string" ? String(x.message) : String(x),
                error: x
            });
            if (!window.dispatchEvent(ee))
                return
        } else if (typeof process == "object" && typeof process.emit == "function") {
            process.emit("uncaughtException", x);
            return
        }
        console.error(x)
    }
    ;
    function Be() {}
    return Ae.Children = {
        map: X,
        forEach: function(x, ee, ae) {
            X(x, function() {
                ee.apply(this, arguments)
            }, ae)
        },
        count: function(x) {
            var ee = 0;
            return X(x, function() {
                ee++
            }),
            ee
        },
        toArray: function(x) {
            return X(x, function(ee) {
                return ee
            }) || []
        },
        only: function(x) {
            if (!M(x))
                throw Error("React.Children.only expected to receive a single React element child.");
            return x
        }
    },
    Ae.Component = J,
    Ae.Fragment = t,
    Ae.Profiler = o,
    Ae.PureComponent = se,
    Ae.StrictMode = s,
    Ae.Suspense = v,
    Ae.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = fe,
    Ae.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(x) {
            return fe.H.useMemoCache(x)
        }
    },
    Ae.cache = function(x) {
        return function() {
            return x.apply(null, arguments)
        }
    }
    ,
    Ae.cloneElement = function(x, ee, ae) {
        if (x == null)
            throw Error("The argument must be a React element, but you passed " + x + ".");
        var ie = q({}, x.props)
          , me = x.key
          , we = void 0;
        if (ee != null)
            for (Te in ee.ref !== void 0 && (we = void 0),
            ee.key !== void 0 && (me = "" + ee.key),
            ee)
                !Ie.call(ee, Te) || Te === "key" || Te === "__self" || Te === "__source" || Te === "ref" && ee.ref === void 0 || (ie[Te] = ee[Te]);
        var Te = arguments.length - 2;
        if (Te === 1)
            ie.children = ae;
        else if (1 < Te) {
            for (var Rt = Array(Te), We = 0; We < Te; We++)
                Rt[We] = arguments[We + 2];
            ie.children = Rt
        }
        return U(x.type, me, void 0, void 0, we, ie)
    }
    ,
    Ae.createContext = function(x) {
        return x = {
            $$typeof: f,
            _currentValue: x,
            _currentValue2: x,
            _threadCount: 0,
            Provider: null,
            Consumer: null
        },
        x.Provider = x,
        x.Consumer = {
            $$typeof: l,
            _context: x
        },
        x
    }
    ,
    Ae.createElement = function(x, ee, ae) {
        var ie, me = {}, we = null;
        if (ee != null)
            for (ie in ee.key !== void 0 && (we = "" + ee.key),
            ee)
                Ie.call(ee, ie) && ie !== "key" && ie !== "__self" && ie !== "__source" && (me[ie] = ee[ie]);
        var Te = arguments.length - 2;
        if (Te === 1)
            me.children = ae;
        else if (1 < Te) {
            for (var Rt = Array(Te), We = 0; We < Te; We++)
                Rt[We] = arguments[We + 2];
            me.children = Rt
        }
        if (x && x.defaultProps)
            for (ie in Te = x.defaultProps,
            Te)
                me[ie] === void 0 && (me[ie] = Te[ie]);
        return U(x, we, void 0, void 0, null, me)
    }
    ,
    Ae.createRef = function() {
        return {
            current: null
        }
    }
    ,
    Ae.forwardRef = function(x) {
        return {
            $$typeof: d,
            render: x
        }
    }
    ,
    Ae.isValidElement = M,
    Ae.lazy = function(x) {
        return {
            $$typeof: T,
            _payload: {
                _status: -1,
                _result: x
            },
            _init: oe
        }
    }
    ,
    Ae.memo = function(x, ee) {
        return {
            $$typeof: y,
            type: x,
            compare: ee === void 0 ? null : ee
        }
    }
    ,
    Ae.startTransition = function(x) {
        var ee = fe.T
          , ae = {};
        fe.T = ae;
        try {
            var ie = x()
              , me = fe.S;
            me !== null && me(ae, ie),
            typeof ie == "object" && ie !== null && typeof ie.then == "function" && ie.then(Be, pe)
        } catch (we) {
            pe(we)
        } finally {
            fe.T = ee
        }
    }
    ,
    Ae.unstable_useCacheRefresh = function() {
        return fe.H.useCacheRefresh()
    }
    ,
    Ae.use = function(x) {
        return fe.H.use(x)
    }
    ,
    Ae.useActionState = function(x, ee, ae) {
        return fe.H.useActionState(x, ee, ae)
    }
    ,
    Ae.useCallback = function(x, ee) {
        return fe.H.useCallback(x, ee)
    }
    ,
    Ae.useContext = function(x) {
        return fe.H.useContext(x)
    }
    ,
    Ae.useDebugValue = function() {}
    ,
    Ae.useDeferredValue = function(x, ee) {
        return fe.H.useDeferredValue(x, ee)
    }
    ,
    Ae.useEffect = function(x, ee, ae) {
        var ie = fe.H;
        if (typeof ae == "function")
            throw Error("useEffect CRUD overload is not enabled in this build of React.");
        return ie.useEffect(x, ee)
    }
    ,
    Ae.useId = function() {
        return fe.H.useId()
    }
    ,
    Ae.useImperativeHandle = function(x, ee, ae) {
        return fe.H.useImperativeHandle(x, ee, ae)
    }
    ,
    Ae.useInsertionEffect = function(x, ee) {
        return fe.H.useInsertionEffect(x, ee)
    }
    ,
    Ae.useLayoutEffect = function(x, ee) {
        return fe.H.useLayoutEffect(x, ee)
    }
    ,
    Ae.useMemo = function(x, ee) {
        return fe.H.useMemo(x, ee)
    }
    ,
    Ae.useOptimistic = function(x, ee) {
        return fe.H.useOptimistic(x, ee)
    }
    ,
    Ae.useReducer = function(x, ee, ae) {
        return fe.H.useReducer(x, ee, ae)
    }
    ,
    Ae.useRef = function(x) {
        return fe.H.useRef(x)
    }
    ,
    Ae.useState = function(x) {
        return fe.H.useState(x)
    }
    ,
    Ae.useSyncExternalStore = function(x, ee, ae) {
        return fe.H.useSyncExternalStore(x, ee, ae)
    }
    ,
    Ae.useTransition = function() {
        return fe.H.useTransition()
    }
    ,
    Ae.version = "19.1.0",
    Ae
}
var jy;
function ep() {
    return jy || (jy = 1,
    cd.exports = fA()),
    cd.exports
}
var dt = ep()
  , fd = {
    exports: {}
}
  , il = {}
  , hd = {
    exports: {}
}
  , dd = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Wy;
function hA() {
    return Wy || (Wy = 1,
    function(r) {
        function e(X, oe) {
            var pe = X.length;
            X.push(oe);
            e: for (; 0 < pe; ) {
                var Be = pe - 1 >>> 1
                  , x = X[Be];
                if (0 < o(x, oe))
                    X[Be] = oe,
                    X[pe] = x,
                    pe = Be;
                else
                    break e
            }
        }
        function t(X) {
            return X.length === 0 ? null : X[0]
        }
        function s(X) {
            if (X.length === 0)
                return null;
            var oe = X[0]
              , pe = X.pop();
            if (pe !== oe) {
                X[0] = pe;
                e: for (var Be = 0, x = X.length, ee = x >>> 1; Be < ee; ) {
                    var ae = 2 * (Be + 1) - 1
                      , ie = X[ae]
                      , me = ae + 1
                      , we = X[me];
                    if (0 > o(ie, pe))
                        me < x && 0 > o(we, ie) ? (X[Be] = we,
                        X[me] = pe,
                        Be = me) : (X[Be] = ie,
                        X[ae] = pe,
                        Be = ae);
                    else if (me < x && 0 > o(we, pe))
                        X[Be] = we,
                        X[me] = pe,
                        Be = me;
                    else
                        break e
                }
            }
            return oe
        }
        function o(X, oe) {
            var pe = X.sortIndex - oe.sortIndex;
            return pe !== 0 ? pe : X.id - oe.id
        }
        if (r.unstable_now = void 0,
        typeof performance == "object" && typeof performance.now == "function") {
            var l = performance;
            r.unstable_now = function() {
                return l.now()
            }
        } else {
            var f = Date
              , d = f.now();
            r.unstable_now = function() {
                return f.now() - d
            }
        }
        var v = []
          , y = []
          , T = 1
          , A = null
          , I = 3
          , V = !1
          , q = !1
          , G = !1
          , J = !1
          , ne = typeof setTimeout == "function" ? setTimeout : null
          , se = typeof clearTimeout == "function" ? clearTimeout : null
          , le = typeof setImmediate < "u" ? setImmediate : null;
        function ue(X) {
            for (var oe = t(y); oe !== null; ) {
                if (oe.callback === null)
                    s(y);
                else if (oe.startTime <= X)
                    s(y),
                    oe.sortIndex = oe.expirationTime,
                    e(v, oe);
                else
                    break;
                oe = t(y)
            }
        }
        function fe(X) {
            if (G = !1,
            ue(X),
            !q)
                if (t(v) !== null)
                    q = !0,
                    Ie || (Ie = !0,
                    B());
                else {
                    var oe = t(y);
                    oe !== null && je(fe, oe.startTime - X)
                }
        }
        var Ie = !1
          , U = -1
          , w = 5
          , M = -1;
        function P() {
            return J ? !0 : !(r.unstable_now() - M < w)
        }
        function k() {
            if (J = !1,
            Ie) {
                var X = r.unstable_now();
                M = X;
                var oe = !0;
                try {
                    e: {
                        q = !1,
                        G && (G = !1,
                        se(U),
                        U = -1),
                        V = !0;
                        var pe = I;
                        try {
                            t: {
                                for (ue(X),
                                A = t(v); A !== null && !(A.expirationTime > X && P()); ) {
                                    var Be = A.callback;
                                    if (typeof Be == "function") {
                                        A.callback = null,
                                        I = A.priorityLevel;
                                        var x = Be(A.expirationTime <= X);
                                        if (X = r.unstable_now(),
                                        typeof x == "function") {
                                            A.callback = x,
                                            ue(X),
                                            oe = !0;
                                            break t
                                        }
                                        A === t(v) && s(v),
                                        ue(X)
                                    } else
                                        s(v);
                                    A = t(v)
                                }
                                if (A !== null)
                                    oe = !0;
                                else {
                                    var ee = t(y);
                                    ee !== null && je(fe, ee.startTime - X),
                                    oe = !1
                                }
                            }
                            break e
                        } finally {
                            A = null,
                            I = pe,
                            V = !1
                        }
                        oe = void 0
                    }
                } finally {
                    oe ? B() : Ie = !1
                }
            }
        }
        var B;
        if (typeof le == "function")
            B = function() {
                le(k)
            }
            ;
        else if (typeof MessageChannel < "u") {
            var N = new MessageChannel
              , $e = N.port2;
            N.port1.onmessage = k,
            B = function() {
                $e.postMessage(null)
            }
        } else
            B = function() {
                ne(k, 0)
            }
            ;
        function je(X, oe) {
            U = ne(function() {
                X(r.unstable_now())
            }, oe)
        }
        r.unstable_IdlePriority = 5,
        r.unstable_ImmediatePriority = 1,
        r.unstable_LowPriority = 4,
        r.unstable_NormalPriority = 3,
        r.unstable_Profiling = null,
        r.unstable_UserBlockingPriority = 2,
        r.unstable_cancelCallback = function(X) {
            X.callback = null
        }
        ,
        r.unstable_forceFrameRate = function(X) {
            0 > X || 125 < X ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : w = 0 < X ? Math.floor(1e3 / X) : 5
        }
        ,
        r.unstable_getCurrentPriorityLevel = function() {
            return I
        }
        ,
        r.unstable_next = function(X) {
            switch (I) {
            case 1:
            case 2:
            case 3:
                var oe = 3;
                break;
            default:
                oe = I
            }
            var pe = I;
            I = oe;
            try {
                return X()
            } finally {
                I = pe
            }
        }
        ,
        r.unstable_requestPaint = function() {
            J = !0
        }
        ,
        r.unstable_runWithPriority = function(X, oe) {
            switch (X) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                X = 3
            }
            var pe = I;
            I = X;
            try {
                return oe()
            } finally {
                I = pe
            }
        }
        ,
        r.unstable_scheduleCallback = function(X, oe, pe) {
            var Be = r.unstable_now();
            switch (typeof pe == "object" && pe !== null ? (pe = pe.delay,
            pe = typeof pe == "number" && 0 < pe ? Be + pe : Be) : pe = Be,
            X) {
            case 1:
                var x = -1;
                break;
            case 2:
                x = 250;
                break;
            case 5:
                x = 1073741823;
                break;
            case 4:
                x = 1e4;
                break;
            default:
                x = 5e3
            }
            return x = pe + x,
            X = {
                id: T++,
                callback: oe,
                priorityLevel: X,
                startTime: pe,
                expirationTime: x,
                sortIndex: -1
            },
            pe > Be ? (X.sortIndex = pe,
            e(y, X),
            t(v) === null && X === t(y) && (G ? (se(U),
            U = -1) : G = !0,
            je(fe, pe - Be))) : (X.sortIndex = x,
            e(v, X),
            q || V || (q = !0,
            Ie || (Ie = !0,
            B()))),
            X
        }
        ,
        r.unstable_shouldYield = P,
        r.unstable_wrapCallback = function(X) {
            var oe = I;
            return function() {
                var pe = I;
                I = oe;
                try {
                    return X.apply(this, arguments)
                } finally {
                    I = pe
                }
            }
        }
    }(dd)),
    dd
}
var Zy;
function dA() {
    return Zy || (Zy = 1,
    hd.exports = hA()),
    hd.exports
}
var pd = {
    exports: {}
}
  , Yt = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ev;
function pA() {
    if (ev)
        return Yt;
    ev = 1;
    var r = ep();
    function e(v) {
        var y = "https://react.dev/errors/" + v;
        if (1 < arguments.length) {
            y += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var T = 2; T < arguments.length; T++)
                y += "&args[]=" + encodeURIComponent(arguments[T])
        }
        return "Minified React error #" + v + "; visit " + y + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    function t() {}
    var s = {
        d: {
            f: t,
            r: function() {
                throw Error(e(522))
            },
            D: t,
            C: t,
            L: t,
            m: t,
            X: t,
            S: t,
            M: t
        },
        p: 0,
        findDOMNode: null
    }
      , o = Symbol.for("react.portal");
    function l(v, y, T) {
        var A = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: o,
            key: A == null ? null : "" + A,
            children: v,
            containerInfo: y,
            implementation: T
        }
    }
    var f = r.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function d(v, y) {
        if (v === "font")
            return "";
        if (typeof y == "string")
            return y === "use-credentials" ? y : ""
    }
    return Yt.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = s,
    Yt.createPortal = function(v, y) {
        var T = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!y || y.nodeType !== 1 && y.nodeType !== 9 && y.nodeType !== 11)
            throw Error(e(299));
        return l(v, y, null, T)
    }
    ,
    Yt.flushSync = function(v) {
        var y = f.T
          , T = s.p;
        try {
            if (f.T = null,
            s.p = 2,
            v)
                return v()
        } finally {
            f.T = y,
            s.p = T,
            s.d.f()
        }
    }
    ,
    Yt.preconnect = function(v, y) {
        typeof v == "string" && (y ? (y = y.crossOrigin,
        y = typeof y == "string" ? y === "use-credentials" ? y : "" : void 0) : y = null,
        s.d.C(v, y))
    }
    ,
    Yt.prefetchDNS = function(v) {
        typeof v == "string" && s.d.D(v)
    }
    ,
    Yt.preinit = function(v, y) {
        if (typeof v == "string" && y && typeof y.as == "string") {
            var T = y.as
              , A = d(T, y.crossOrigin)
              , I = typeof y.integrity == "string" ? y.integrity : void 0
              , V = typeof y.fetchPriority == "string" ? y.fetchPriority : void 0;
            T === "style" ? s.d.S(v, typeof y.precedence == "string" ? y.precedence : void 0, {
                crossOrigin: A,
                integrity: I,
                fetchPriority: V
            }) : T === "script" && s.d.X(v, {
                crossOrigin: A,
                integrity: I,
                fetchPriority: V,
                nonce: typeof y.nonce == "string" ? y.nonce : void 0
            })
        }
    }
    ,
    Yt.preinitModule = function(v, y) {
        if (typeof v == "string")
            if (typeof y == "object" && y !== null) {
                if (y.as == null || y.as === "script") {
                    var T = d(y.as, y.crossOrigin);
                    s.d.M(v, {
                        crossOrigin: T,
                        integrity: typeof y.integrity == "string" ? y.integrity : void 0,
                        nonce: typeof y.nonce == "string" ? y.nonce : void 0
                    })
                }
            } else
                y == null && s.d.M(v)
    }
    ,
    Yt.preload = function(v, y) {
        if (typeof v == "string" && typeof y == "object" && y !== null && typeof y.as == "string") {
            var T = y.as
              , A = d(T, y.crossOrigin);
            s.d.L(v, T, {
                crossOrigin: A,
                integrity: typeof y.integrity == "string" ? y.integrity : void 0,
                nonce: typeof y.nonce == "string" ? y.nonce : void 0,
                type: typeof y.type == "string" ? y.type : void 0,
                fetchPriority: typeof y.fetchPriority == "string" ? y.fetchPriority : void 0,
                referrerPolicy: typeof y.referrerPolicy == "string" ? y.referrerPolicy : void 0,
                imageSrcSet: typeof y.imageSrcSet == "string" ? y.imageSrcSet : void 0,
                imageSizes: typeof y.imageSizes == "string" ? y.imageSizes : void 0,
                media: typeof y.media == "string" ? y.media : void 0
            })
        }
    }
    ,
    Yt.preloadModule = function(v, y) {
        if (typeof v == "string")
            if (y) {
                var T = d(y.as, y.crossOrigin);
                s.d.m(v, {
                    as: typeof y.as == "string" && y.as !== "script" ? y.as : void 0,
                    crossOrigin: T,
                    integrity: typeof y.integrity == "string" ? y.integrity : void 0
                })
            } else
                s.d.m(v)
    }
    ,
    Yt.requestFormReset = function(v) {
        s.d.r(v)
    }
    ,
    Yt.unstable_batchedUpdates = function(v, y) {
        return v(y)
    }
    ,
    Yt.useFormState = function(v, y, T) {
        return f.H.useFormState(v, y, T)
    }
    ,
    Yt.useFormStatus = function() {
        return f.H.useHostTransitionStatus()
    }
    ,
    Yt.version = "19.1.0",
    Yt
}
var tv;
function mA() {
    if (tv)
        return pd.exports;
    tv = 1;
    function r() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r)
            } catch (e) {
                console.error(e)
            }
    }
    return r(),
    pd.exports = pA(),
    pd.exports
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nv;
function gA() {
    if (nv)
        return il;
    nv = 1;
    var r = dA()
      , e = ep()
      , t = mA();
    function s(n) {
        var i = "https://react.dev/errors/" + n;
        if (1 < arguments.length) {
            i += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var a = 2; a < arguments.length; a++)
                i += "&args[]=" + encodeURIComponent(arguments[a])
        }
        return "Minified React error #" + n + "; visit " + i + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    function o(n) {
        return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11)
    }
    function l(n) {
        var i = n
          , a = n;
        if (n.alternate)
            for (; i.return; )
                i = i.return;
        else {
            n = i;
            do
                i = n,
                (i.flags & 4098) !== 0 && (a = i.return),
                n = i.return;
            while (n)
        }
        return i.tag === 3 ? a : null
    }
    function f(n) {
        if (n.tag === 13) {
            var i = n.memoizedState;
            if (i === null && (n = n.alternate,
            n !== null && (i = n.memoizedState)),
            i !== null)
                return i.dehydrated
        }
        return null
    }
    function d(n) {
        if (l(n) !== n)
            throw Error(s(188))
    }
    function v(n) {
        var i = n.alternate;
        if (!i) {
            if (i = l(n),
            i === null)
                throw Error(s(188));
            return i !== n ? null : n
        }
        for (var a = n, u = i; ; ) {
            var h = a.return;
            if (h === null)
                break;
            var g = h.alternate;
            if (g === null) {
                if (u = h.return,
                u !== null) {
                    a = u;
                    continue
                }
                break
            }
            if (h.child === g.child) {
                for (g = h.child; g; ) {
                    if (g === a)
                        return d(h),
                        n;
                    if (g === u)
                        return d(h),
                        i;
                    g = g.sibling
                }
                throw Error(s(188))
            }
            if (a.return !== u.return)
                a = h,
                u = g;
            else {
                for (var S = !1, C = h.child; C; ) {
                    if (C === a) {
                        S = !0,
                        a = h,
                        u = g;
                        break
                    }
                    if (C === u) {
                        S = !0,
                        u = h,
                        a = g;
                        break
                    }
                    C = C.sibling
                }
                if (!S) {
                    for (C = g.child; C; ) {
                        if (C === a) {
                            S = !0,
                            a = g,
                            u = h;
                            break
                        }
                        if (C === u) {
                            S = !0,
                            u = g,
                            a = h;
                            break
                        }
                        C = C.sibling
                    }
                    if (!S)
                        throw Error(s(189))
                }
            }
            if (a.alternate !== u)
                throw Error(s(190))
        }
        if (a.tag !== 3)
            throw Error(s(188));
        return a.stateNode.current === a ? n : i
    }
    function y(n) {
        var i = n.tag;
        if (i === 5 || i === 26 || i === 27 || i === 6)
            return n;
        for (n = n.child; n !== null; ) {
            if (i = y(n),
            i !== null)
                return i;
            n = n.sibling
        }
        return null
    }
    var T = Object.assign
      , A = Symbol.for("react.element")
      , I = Symbol.for("react.transitional.element")
      , V = Symbol.for("react.portal")
      , q = Symbol.for("react.fragment")
      , G = Symbol.for("react.strict_mode")
      , J = Symbol.for("react.profiler")
      , ne = Symbol.for("react.provider")
      , se = Symbol.for("react.consumer")
      , le = Symbol.for("react.context")
      , ue = Symbol.for("react.forward_ref")
      , fe = Symbol.for("react.suspense")
      , Ie = Symbol.for("react.suspense_list")
      , U = Symbol.for("react.memo")
      , w = Symbol.for("react.lazy")
      , M = Symbol.for("react.activity")
      , P = Symbol.for("react.memo_cache_sentinel")
      , k = Symbol.iterator;
    function B(n) {
        return n === null || typeof n != "object" ? null : (n = k && n[k] || n["@@iterator"],
        typeof n == "function" ? n : null)
    }
    var N = Symbol.for("react.client.reference");
    function $e(n) {
        if (n == null)
            return null;
        if (typeof n == "function")
            return n.$$typeof === N ? null : n.displayName || n.name || null;
        if (typeof n == "string")
            return n;
        switch (n) {
        case q:
            return "Fragment";
        case J:
            return "Profiler";
        case G:
            return "StrictMode";
        case fe:
            return "Suspense";
        case Ie:
            return "SuspenseList";
        case M:
            return "Activity"
        }
        if (typeof n == "object")
            switch (n.$$typeof) {
            case V:
                return "Portal";
            case le:
                return (n.displayName || "Context") + ".Provider";
            case se:
                return (n._context.displayName || "Context") + ".Consumer";
            case ue:
                var i = n.render;
                return n = n.displayName,
                n || (n = i.displayName || i.name || "",
                n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"),
                n;
            case U:
                return i = n.displayName || null,
                i !== null ? i : $e(n.type) || "Memo";
            case w:
                i = n._payload,
                n = n._init;
                try {
                    return $e(n(i))
                } catch {}
            }
        return null
    }
    var je = Array.isArray
      , X = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
      , oe = t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
      , pe = {
        pending: !1,
        data: null,
        method: null,
        action: null
    }
      , Be = []
      , x = -1;
    function ee(n) {
        return {
            current: n
        }
    }
    function ae(n) {
        0 > x || (n.current = Be[x],
        Be[x] = null,
        x--)
    }
    function ie(n, i) {
        x++,
        Be[x] = n.current,
        n.current = i
    }
    var me = ee(null)
      , we = ee(null)
      , Te = ee(null)
      , Rt = ee(null);
    function We(n, i) {
        switch (ie(Te, i),
        ie(we, n),
        ie(me, null),
        i.nodeType) {
        case 9:
        case 11:
            n = (n = i.documentElement) && (n = n.namespaceURI) ? Sy(n) : 0;
            break;
        default:
            if (n = i.tagName,
            i = i.namespaceURI)
                i = Sy(i),
                n = Ay(i, n);
            else
                switch (n) {
                case "svg":
                    n = 1;
                    break;
                case "math":
                    n = 2;
                    break;
                default:
                    n = 0
                }
        }
        ae(me),
        ie(me, n)
    }
    function Gn() {
        ae(me),
        ae(we),
        ae(Te)
    }
    function Qi(n) {
        n.memoizedState !== null && ie(Rt, n);
        var i = me.current
          , a = Ay(i, n.type);
        i !== a && (ie(we, n),
        ie(me, a))
    }
    function fi(n) {
        we.current === n && (ae(me),
        ae(we)),
        Rt.current === n && (ae(Rt),
        ja._currentValue = pe)
    }
    var Br = Object.prototype.hasOwnProperty
      , qr = r.unstable_scheduleCallback
      , zr = r.unstable_cancelCallback
      , Xo = r.unstable_shouldYield
      , Vl = r.unstable_requestPaint
      , _n = r.unstable_now
      , uf = r.unstable_getCurrentPriorityLevel
      , $o = r.unstable_ImmediatePriority
      , ks = r.unstable_UserBlockingPriority
      , Fr = r.unstable_NormalPriority
      , cf = r.unstable_LowPriority
      , Ls = r.unstable_IdlePriority
      , Jo = r.log
      , Ul = r.unstable_setDisableYieldValue
      , st = null
      , Fe = null;
    function ln(n) {
        if (typeof Jo == "function" && Ul(n),
        Fe && typeof Fe.setStrictMode == "function")
            try {
                Fe.setStrictMode(st, n)
            } catch {}
    }
    var Ht = Math.clz32 ? Math.clz32 : Hr
      , kl = Math.log
      , ff = Math.LN2;
    function Hr(n) {
        return n >>>= 0,
        n === 0 ? 32 : 31 - (kl(n) / ff | 0) | 0
    }
    var Gr = 256
      , Yr = 4194304;
    function Pn(n) {
        var i = n & 42;
        if (i !== 0)
            return i;
        switch (n & -n) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
            return 64;
        case 128:
            return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return n & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            return n & 62914560;
        case 67108864:
            return 67108864;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 0;
        default:
            return n
        }
    }
    function Bs(n, i, a) {
        var u = n.pendingLanes;
        if (u === 0)
            return 0;
        var h = 0
          , g = n.suspendedLanes
          , S = n.pingedLanes;
        n = n.warmLanes;
        var C = u & 134217727;
        return C !== 0 ? (u = C & ~g,
        u !== 0 ? h = Pn(u) : (S &= C,
        S !== 0 ? h = Pn(S) : a || (a = C & ~n,
        a !== 0 && (h = Pn(a))))) : (C = u & ~g,
        C !== 0 ? h = Pn(C) : S !== 0 ? h = Pn(S) : a || (a = u & ~n,
        a !== 0 && (h = Pn(a)))),
        h === 0 ? 0 : i !== 0 && i !== h && (i & g) === 0 && (g = h & -h,
        a = i & -i,
        g >= a || g === 32 && (a & 4194048) !== 0) ? i : h
    }
    function Kr(n, i) {
        return (n.pendingLanes & ~(n.suspendedLanes & ~n.pingedLanes) & i) === 0
    }
    function jo(n, i) {
        switch (n) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
            return i + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return i + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function Wo() {
        var n = Gr;
        return Gr <<= 1,
        (Gr & 4194048) === 0 && (Gr = 256),
        n
    }
    function Zo() {
        var n = Yr;
        return Yr <<= 1,
        (Yr & 62914560) === 0 && (Yr = 4194304),
        n
    }
    function hi(n) {
        for (var i = [], a = 0; 31 > a; a++)
            i.push(n);
        return i
    }
    function di(n, i) {
        n.pendingLanes |= i,
        i !== 268435456 && (n.suspendedLanes = 0,
        n.pingedLanes = 0,
        n.warmLanes = 0)
    }
    function ea(n, i, a, u, h, g) {
        var S = n.pendingLanes;
        n.pendingLanes = a,
        n.suspendedLanes = 0,
        n.pingedLanes = 0,
        n.warmLanes = 0,
        n.expiredLanes &= a,
        n.entangledLanes &= a,
        n.errorRecoveryDisabledLanes &= a,
        n.shellSuspendCounter = 0;
        var C = n.entanglements
          , D = n.expirationTimes
          , H = n.hiddenUpdates;
        for (a = S & ~a; 0 < a; ) {
            var $ = 31 - Ht(a)
              , W = 1 << $;
            C[$] = 0,
            D[$] = -1;
            var Y = H[$];
            if (Y !== null)
                for (H[$] = null,
                $ = 0; $ < Y.length; $++) {
                    var K = Y[$];
                    K !== null && (K.lane &= -536870913)
                }
            a &= ~W
        }
        u !== 0 && Yn(n, u, 0),
        g !== 0 && h === 0 && n.tag !== 0 && (n.suspendedLanes |= g & ~(S & ~i))
    }
    function Yn(n, i, a) {
        n.pendingLanes |= i,
        n.suspendedLanes &= ~i;
        var u = 31 - Ht(i);
        n.entangledLanes |= i,
        n.entanglements[u] = n.entanglements[u] | 1073741824 | a & 4194090
    }
    function ta(n, i) {
        var a = n.entangledLanes |= i;
        for (n = n.entanglements; a; ) {
            var u = 31 - Ht(a)
              , h = 1 << u;
            h & i | n[u] & i && (n[u] |= i),
            a &= ~h
        }
    }
    function Xi(n) {
        switch (n) {
        case 2:
            n = 1;
            break;
        case 8:
            n = 4;
            break;
        case 32:
            n = 16;
            break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            n = 128;
            break;
        case 268435456:
            n = 134217728;
            break;
        default:
            n = 0
        }
        return n
    }
    function qs(n) {
        return n &= -n,
        2 < n ? 8 < n ? (n & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
    }
    function $i() {
        var n = oe.p;
        return n !== 0 ? n : (n = window.event,
        n === void 0 ? 32 : Fy(n.type))
    }
    function Ll(n, i) {
        var a = oe.p;
        try {
            return oe.p = n,
            i()
        } finally {
            oe.p = a
        }
    }
    var tt = Math.random().toString(36).slice(2)
      , Tt = "__reactFiber$" + tt
      , pt = "__reactProps$" + tt
      , Tn = "__reactContainer$" + tt
      , na = "__reactEvents$" + tt
      , hf = "__reactListeners$" + tt
      , Ji = "__reactHandles$" + tt
      , Bl = "__reactResources$" + tt
      , Qr = "__reactMarker$" + tt;
    function ji(n) {
        delete n[Tt],
        delete n[pt],
        delete n[na],
        delete n[hf],
        delete n[Ji]
    }
    function pi(n) {
        var i = n[Tt];
        if (i)
            return i;
        for (var a = n.parentNode; a; ) {
            if (i = a[Tn] || a[Tt]) {
                if (a = i.alternate,
                i.child !== null || a !== null && a.child !== null)
                    for (n = wy(n); n !== null; ) {
                        if (a = n[Tt])
                            return a;
                        n = wy(n)
                    }
                return i
            }
            n = a,
            a = n.parentNode
        }
        return null
    }
    function Kn(n) {
        if (n = n[Tt] || n[Tn]) {
            var i = n.tag;
            if (i === 5 || i === 6 || i === 13 || i === 26 || i === 27 || i === 3)
                return n
        }
        return null
    }
    function Qn(n) {
        var i = n.tag;
        if (i === 5 || i === 26 || i === 27 || i === 6)
            return n.stateNode;
        throw Error(s(33))
    }
    function jt(n) {
        var i = n[Bl];
        return i || (i = n[Bl] = {
            hoistableStyles: new Map,
            hoistableScripts: new Map
        }),
        i
    }
    function ct(n) {
        n[Qr] = !0
    }
    var ia = new Set
      , zs = {};
    function On(n, i) {
        mi(n, i),
        mi(n + "Capture", i)
    }
    function mi(n, i) {
        for (zs[n] = i,
        n = 0; n < i.length; n++)
            ia.add(i[n])
    }
    var ql = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$")
      , zl = {}
      , Xr = {};
    function Fl(n) {
        return Br.call(Xr, n) ? !0 : Br.call(zl, n) ? !1 : ql.test(n) ? Xr[n] = !0 : (zl[n] = !0,
        !1)
    }
    function Wi(n, i, a) {
        if (Fl(i))
            if (a === null)
                n.removeAttribute(i);
            else {
                switch (typeof a) {
                case "undefined":
                case "function":
                case "symbol":
                    n.removeAttribute(i);
                    return;
                case "boolean":
                    var u = i.toLowerCase().slice(0, 5);
                    if (u !== "data-" && u !== "aria-") {
                        n.removeAttribute(i);
                        return
                    }
                }
                n.setAttribute(i, "" + a)
            }
    }
    function Xn(n, i, a) {
        if (a === null)
            n.removeAttribute(i);
        else {
            switch (typeof a) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                n.removeAttribute(i);
                return
            }
            n.setAttribute(i, "" + a)
        }
    }
    function Ot(n, i, a, u) {
        if (u === null)
            n.removeAttribute(a);
        else {
            switch (typeof u) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                n.removeAttribute(a);
                return
            }
            n.setAttributeNS(i, a, "" + u)
        }
    }
    var $r, Hl;
    function gi(n) {
        if ($r === void 0)
            try {
                throw Error()
            } catch (a) {
                var i = a.stack.trim().match(/\n( *(at )?)/);
                $r = i && i[1] || "",
                Hl = -1 < a.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < a.stack.indexOf("@") ? "@unknown:0:0" : ""
            }
        return `
` + $r + n + Hl
    }
    var Fs = !1;
    function Hs(n, i) {
        if (!n || Fs)
            return "";
        Fs = !0;
        var a = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            var u = {
                DetermineComponentFrameRoot: function() {
                    try {
                        if (i) {
                            var W = function() {
                                throw Error()
                            };
                            if (Object.defineProperty(W.prototype, "props", {
                                set: function() {
                                    throw Error()
                                }
                            }),
                            typeof Reflect == "object" && Reflect.construct) {
                                try {
                                    Reflect.construct(W, [])
                                } catch (K) {
                                    var Y = K
                                }
                                Reflect.construct(n, [], W)
                            } else {
                                try {
                                    W.call()
                                } catch (K) {
                                    Y = K
                                }
                                n.call(W.prototype)
                            }
                        } else {
                            try {
                                throw Error()
                            } catch (K) {
                                Y = K
                            }
                            (W = n()) && typeof W.catch == "function" && W.catch(function() {})
                        }
                    } catch (K) {
                        if (K && Y && typeof K.stack == "string")
                            return [K.stack, Y.stack]
                    }
                    return [null, null]
                }
            };
            u.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var h = Object.getOwnPropertyDescriptor(u.DetermineComponentFrameRoot, "name");
            h && h.configurable && Object.defineProperty(u.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
            });
            var g = u.DetermineComponentFrameRoot()
              , S = g[0]
              , C = g[1];
            if (S && C) {
                var D = S.split(`
`)
                  , H = C.split(`
`);
                for (h = u = 0; u < D.length && !D[u].includes("DetermineComponentFrameRoot"); )
                    u++;
                for (; h < H.length && !H[h].includes("DetermineComponentFrameRoot"); )
                    h++;
                if (u === D.length || h === H.length)
                    for (u = D.length - 1,
                    h = H.length - 1; 1 <= u && 0 <= h && D[u] !== H[h]; )
                        h--;
                for (; 1 <= u && 0 <= h; u--,
                h--)
                    if (D[u] !== H[h]) {
                        if (u !== 1 || h !== 1)
                            do
                                if (u--,
                                h--,
                                0 > h || D[u] !== H[h]) {
                                    var $ = `
` + D[u].replace(" at new ", " at ");
                                    return n.displayName && $.includes("<anonymous>") && ($ = $.replace("<anonymous>", n.displayName)),
                                    $
                                }
                            while (1 <= u && 0 <= h);
                        break
                    }
            }
        } finally {
            Fs = !1,
            Error.prepareStackTrace = a
        }
        return (a = n ? n.displayName || n.name : "") ? gi(a) : ""
    }
    function ra(n) {
        switch (n.tag) {
        case 26:
        case 27:
        case 5:
            return gi(n.type);
        case 16:
            return gi("Lazy");
        case 13:
            return gi("Suspense");
        case 19:
            return gi("SuspenseList");
        case 0:
        case 15:
            return Hs(n.type, !1);
        case 11:
            return Hs(n.type.render, !1);
        case 1:
            return Hs(n.type, !0);
        case 31:
            return gi("Activity");
        default:
            return ""
        }
    }
    function Gs(n) {
        try {
            var i = "";
            do
                i += ra(n),
                n = n.return;
            while (n);
            return i
        } catch (a) {
            return `
Error generating stack: ` + a.message + `
` + a.stack
        }
    }
    function Wt(n) {
        switch (typeof n) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return n;
        case "object":
            return n;
        default:
            return ""
        }
    }
    function sa(n) {
        var i = n.type;
        return (n = n.nodeName) && n.toLowerCase() === "input" && (i === "checkbox" || i === "radio")
    }
    function df(n) {
        var i = sa(n) ? "checked" : "value"
          , a = Object.getOwnPropertyDescriptor(n.constructor.prototype, i)
          , u = "" + n[i];
        if (!n.hasOwnProperty(i) && typeof a < "u" && typeof a.get == "function" && typeof a.set == "function") {
            var h = a.get
              , g = a.set;
            return Object.defineProperty(n, i, {
                configurable: !0,
                get: function() {
                    return h.call(this)
                },
                set: function(S) {
                    u = "" + S,
                    g.call(this, S)
                }
            }),
            Object.defineProperty(n, i, {
                enumerable: a.enumerable
            }),
            {
                getValue: function() {
                    return u
                },
                setValue: function(S) {
                    u = "" + S
                },
                stopTracking: function() {
                    n._valueTracker = null,
                    delete n[i]
                }
            }
        }
    }
    function Ys(n) {
        n._valueTracker || (n._valueTracker = df(n))
    }
    function oa(n) {
        if (!n)
            return !1;
        var i = n._valueTracker;
        if (!i)
            return !0;
        var a = i.getValue()
          , u = "";
        return n && (u = sa(n) ? n.checked ? "true" : "false" : n.value),
        n = u,
        n !== a ? (i.setValue(n),
        !0) : !1
    }
    function Jr(n) {
        if (n = n || (typeof document < "u" ? document : void 0),
        typeof n > "u")
            return null;
        try {
            return n.activeElement || n.body
        } catch {
            return n.body
        }
    }
    var pf = /[\n"\\]/g;
    function mt(n) {
        return n.replace(pf, function(i) {
            return "\\" + i.charCodeAt(0).toString(16) + " "
        })
    }
    function un(n, i, a, u, h, g, S, C) {
        n.name = "",
        S != null && typeof S != "function" && typeof S != "symbol" && typeof S != "boolean" ? n.type = S : n.removeAttribute("type"),
        i != null ? S === "number" ? (i === 0 && n.value === "" || n.value != i) && (n.value = "" + Wt(i)) : n.value !== "" + Wt(i) && (n.value = "" + Wt(i)) : S !== "submit" && S !== "reset" || n.removeAttribute("value"),
        i != null ? Zi(n, S, Wt(i)) : a != null ? Zi(n, S, Wt(a)) : u != null && n.removeAttribute("value"),
        h == null && g != null && (n.defaultChecked = !!g),
        h != null && (n.checked = h && typeof h != "function" && typeof h != "symbol"),
        C != null && typeof C != "function" && typeof C != "symbol" && typeof C != "boolean" ? n.name = "" + Wt(C) : n.removeAttribute("name")
    }
    function jr(n, i, a, u, h, g, S, C) {
        if (g != null && typeof g != "function" && typeof g != "symbol" && typeof g != "boolean" && (n.type = g),
        i != null || a != null) {
            if (!(g !== "submit" && g !== "reset" || i != null))
                return;
            a = a != null ? "" + Wt(a) : "",
            i = i != null ? "" + Wt(i) : a,
            C || i === n.value || (n.value = i),
            n.defaultValue = i
        }
        u = u ?? h,
        u = typeof u != "function" && typeof u != "symbol" && !!u,
        n.checked = C ? n.checked : !!u,
        n.defaultChecked = !!u,
        S != null && typeof S != "function" && typeof S != "symbol" && typeof S != "boolean" && (n.name = S)
    }
    function Zi(n, i, a) {
        i === "number" && Jr(n.ownerDocument) === n || n.defaultValue === "" + a || (n.defaultValue = "" + a)
    }
    function yi(n, i, a, u) {
        if (n = n.options,
        i) {
            i = {};
            for (var h = 0; h < a.length; h++)
                i["$" + a[h]] = !0;
            for (a = 0; a < n.length; a++)
                h = i.hasOwnProperty("$" + n[a].value),
                n[a].selected !== h && (n[a].selected = h),
                h && u && (n[a].defaultSelected = !0)
        } else {
            for (a = "" + Wt(a),
            i = null,
            h = 0; h < n.length; h++) {
                if (n[h].value === a) {
                    n[h].selected = !0,
                    u && (n[h].defaultSelected = !0);
                    return
                }
                i !== null || n[h].disabled || (i = n[h])
            }
            i !== null && (i.selected = !0)
        }
    }
    function Ye(n, i, a) {
        if (i != null && (i = "" + Wt(i),
        i !== n.value && (n.value = i),
        a == null)) {
            n.defaultValue !== i && (n.defaultValue = i);
            return
        }
        n.defaultValue = a != null ? "" + Wt(a) : ""
    }
    function Wr(n, i, a, u) {
        if (i == null) {
            if (u != null) {
                if (a != null)
                    throw Error(s(92));
                if (je(u)) {
                    if (1 < u.length)
                        throw Error(s(93));
                    u = u[0]
                }
                a = u
            }
            a == null && (a = ""),
            i = a
        }
        a = Wt(i),
        n.defaultValue = a,
        u = n.textContent,
        u === a && u !== "" && u !== null && (n.value = u)
    }
    function En(n, i) {
        if (i) {
            var a = n.firstChild;
            if (a && a === n.lastChild && a.nodeType === 3) {
                a.nodeValue = i;
                return
            }
        }
        n.textContent = i
    }
    var Zr = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
    function Gl(n, i, a) {
        var u = i.indexOf("--") === 0;
        a == null || typeof a == "boolean" || a === "" ? u ? n.setProperty(i, "") : i === "float" ? n.cssFloat = "" : n[i] = "" : u ? n.setProperty(i, a) : typeof a != "number" || a === 0 || Zr.has(i) ? i === "float" ? n.cssFloat = a : n[i] = ("" + a).trim() : n[i] = a + "px"
    }
    function aa(n, i, a) {
        if (i != null && typeof i != "object")
            throw Error(s(62));
        if (n = n.style,
        a != null) {
            for (var u in a)
                !a.hasOwnProperty(u) || i != null && i.hasOwnProperty(u) || (u.indexOf("--") === 0 ? n.setProperty(u, "") : u === "float" ? n.cssFloat = "" : n[u] = "");
            for (var h in i)
                u = i[h],
                i.hasOwnProperty(h) && a[h] !== u && Gl(n, h, u)
        } else
            for (var g in i)
                i.hasOwnProperty(g) && Gl(n, g, i[g])
    }
    function la(n) {
        if (n.indexOf("-") === -1)
            return !1;
        switch (n) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
        }
    }
    var mf = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]])
      , gf = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function Ks(n) {
        return gf.test("" + n) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : n
    }
    var vi = null;
    function Sn(n) {
        return n = n.target || n.srcElement || window,
        n.correspondingUseElement && (n = n.correspondingUseElement),
        n.nodeType === 3 ? n.parentNode : n
    }
    var _i = null
      , Ti = null;
    function ua(n) {
        var i = Kn(n);
        if (i && (n = i.stateNode)) {
            var a = n[pt] || null;
            e: switch (n = i.stateNode,
            i.type) {
            case "input":
                if (un(n, a.value, a.defaultValue, a.defaultValue, a.checked, a.defaultChecked, a.type, a.name),
                i = a.name,
                a.type === "radio" && i != null) {
                    for (a = n; a.parentNode; )
                        a = a.parentNode;
                    for (a = a.querySelectorAll('input[name="' + mt("" + i) + '"][type="radio"]'),
                    i = 0; i < a.length; i++) {
                        var u = a[i];
                        if (u !== n && u.form === n.form) {
                            var h = u[pt] || null;
                            if (!h)
                                throw Error(s(90));
                            un(u, h.value, h.defaultValue, h.defaultValue, h.checked, h.defaultChecked, h.type, h.name)
                        }
                    }
                    for (i = 0; i < a.length; i++)
                        u = a[i],
                        u.form === n.form && oa(u)
                }
                break e;
            case "textarea":
                Ye(n, a.value, a.defaultValue);
                break e;
            case "select":
                i = a.value,
                i != null && yi(n, !!a.multiple, i, !1)
            }
        }
    }
    var $n = !1;
    function Yl(n, i, a) {
        if ($n)
            return n(i, a);
        $n = !0;
        try {
            var u = n(i);
            return u
        } finally {
            if ($n = !1,
            (_i !== null || Ti !== null) && (Lu(),
            _i && (i = _i,
            n = Ti,
            Ti = _i = null,
            ua(i),
            n)))
                for (i = 0; i < n.length; i++)
                    ua(n[i])
        }
    }
    function es(n, i) {
        var a = n.stateNode;
        if (a === null)
            return null;
        var u = a[pt] || null;
        if (u === null)
            return null;
        a = u[i];
        e: switch (i) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (u = !u.disabled) || (n = n.type,
            u = !(n === "button" || n === "input" || n === "select" || n === "textarea")),
            n = !u;
            break e;
        default:
            n = !1
        }
        if (n)
            return null;
        if (a && typeof a != "function")
            throw Error(s(231, i, typeof a));
        return a
    }
    var Vn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
      , An = !1;
    if (Vn)
        try {
            var ts = {};
            Object.defineProperty(ts, "passive", {
                get: function() {
                    An = !0
                }
            }),
            window.addEventListener("test", ts, ts),
            window.removeEventListener("test", ts, ts)
        } catch {
            An = !1
        }
    var Jn = null
      , er = null
      , Ei = null;
    function ca() {
        if (Ei)
            return Ei;
        var n, i = er, a = i.length, u, h = "value"in Jn ? Jn.value : Jn.textContent, g = h.length;
        for (n = 0; n < a && i[n] === h[n]; n++)
            ;
        var S = a - n;
        for (u = 1; u <= S && i[a - u] === h[g - u]; u++)
            ;
        return Ei = h.slice(n, 1 < u ? 1 - u : void 0)
    }
    function jn(n) {
        var i = n.keyCode;
        return "charCode"in n ? (n = n.charCode,
        n === 0 && i === 13 && (n = 13)) : n = i,
        n === 10 && (n = 13),
        32 <= n || n === 13 ? n : 0
    }
    function Wn() {
        return !0
    }
    function fa() {
        return !1
    }
    function It(n) {
        function i(a, u, h, g, S) {
            this._reactName = a,
            this._targetInst = h,
            this.type = u,
            this.nativeEvent = g,
            this.target = S,
            this.currentTarget = null;
            for (var C in n)
                n.hasOwnProperty(C) && (a = n[C],
                this[C] = a ? a(g) : g[C]);
            return this.isDefaultPrevented = (g.defaultPrevented != null ? g.defaultPrevented : g.returnValue === !1) ? Wn : fa,
            this.isPropagationStopped = fa,
            this
        }
        return T(i.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var a = this.nativeEvent;
                a && (a.preventDefault ? a.preventDefault() : typeof a.returnValue != "unknown" && (a.returnValue = !1),
                this.isDefaultPrevented = Wn)
            },
            stopPropagation: function() {
                var a = this.nativeEvent;
                a && (a.stopPropagation ? a.stopPropagation() : typeof a.cancelBubble != "unknown" && (a.cancelBubble = !0),
                this.isPropagationStopped = Wn)
            },
            persist: function() {},
            isPersistent: Wn
        }),
        i
    }
    var ze = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(n) {
            return n.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, Qs = It(ze), ns = T({}, ze, {
        view: 0,
        detail: 0
    }), Kl = It(ns), Xs, $s, Zn, is = T({}, ns, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: os,
        button: 0,
        buttons: 0,
        relatedTarget: function(n) {
            return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget
        },
        movementX: function(n) {
            return "movementX"in n ? n.movementX : (n !== Zn && (Zn && n.type === "mousemove" ? (Xs = n.screenX - Zn.screenX,
            $s = n.screenY - Zn.screenY) : $s = Xs = 0,
            Zn = n),
            Xs)
        },
        movementY: function(n) {
            return "movementY"in n ? n.movementY : $s
        }
    }), Cn = It(is), Ql = T({}, is, {
        dataTransfer: 0
    }), yf = It(Ql), rs = T({}, ns, {
        relatedTarget: 0
    }), Js = It(rs), ha = T({}, ze, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), js = It(ha), Xl = T({}, ze, {
        clipboardData: function(n) {
            return "clipboardData"in n ? n.clipboardData : window.clipboardData
        }
    }), Ws = It(Xl), vf = T({}, ze, {
        data: 0
    }), da = It(vf), ss = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, $l = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, Jl = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function pa(n) {
        var i = this.nativeEvent;
        return i.getModifierState ? i.getModifierState(n) : (n = Jl[n]) ? !!i[n] : !1
    }
    function os() {
        return pa
    }
    var jl = T({}, ns, {
        key: function(n) {
            if (n.key) {
                var i = ss[n.key] || n.key;
                if (i !== "Unidentified")
                    return i
            }
            return n.type === "keypress" ? (n = jn(n),
            n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? $l[n.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: os,
        charCode: function(n) {
            return n.type === "keypress" ? jn(n) : 0
        },
        keyCode: function(n) {
            return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0
        },
        which: function(n) {
            return n.type === "keypress" ? jn(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0
        }
    })
      , Zs = It(jl)
      , Wl = T({}, is, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    })
      , ma = It(Wl)
      , Si = T({}, ns, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: os
    })
      , Zl = It(Si)
      , eu = T({}, ze, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    })
      , tu = It(eu)
      , nu = T({}, is, {
        deltaX: function(n) {
            return "deltaX"in n ? n.deltaX : "wheelDeltaX"in n ? -n.wheelDeltaX : 0
        },
        deltaY: function(n) {
            return "deltaY"in n ? n.deltaY : "wheelDeltaY"in n ? -n.wheelDeltaY : "wheelDelta"in n ? -n.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    })
      , eo = It(nu)
      , Zt = T({}, ze, {
        newState: 0,
        oldState: 0
    })
      , iu = It(Zt)
      , ru = [9, 13, 27, 32]
      , ei = Vn && "CompositionEvent"in window
      , c = null;
    Vn && "documentMode"in document && (c = document.documentMode);
    var _ = Vn && "TextEvent"in window && !c
      , E = Vn && (!ei || c && 8 < c && 11 >= c)
      , R = " "
      , z = !1;
    function Q(n, i) {
        switch (n) {
        case "keyup":
            return ru.indexOf(i.keyCode) !== -1;
        case "keydown":
            return i.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
        }
    }
    function re(n) {
        return n = n.detail,
        typeof n == "object" && "data"in n ? n.data : null
    }
    var Pe = !1;
    function Et(n, i) {
        switch (n) {
        case "compositionend":
            return re(i);
        case "keypress":
            return i.which !== 32 ? null : (z = !0,
            R);
        case "textInput":
            return n = i.data,
            n === R && z ? null : n;
        default:
            return null
        }
    }
    function Oe(n, i) {
        if (Pe)
            return n === "compositionend" || !ei && Q(n, i) ? (n = ca(),
            Ei = er = Jn = null,
            Pe = !1,
            n) : null;
        switch (n) {
        case "paste":
            return null;
        case "keypress":
            if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
                if (i.char && 1 < i.char.length)
                    return i.char;
                if (i.which)
                    return String.fromCharCode(i.which)
            }
            return null;
        case "compositionend":
            return E && i.locale !== "ko" ? null : i.data;
        default:
            return null
        }
    }
    var wt = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function St(n) {
        var i = n && n.nodeName && n.nodeName.toLowerCase();
        return i === "input" ? !!wt[n.type] : i === "textarea"
    }
    function Ai(n, i, a, u) {
        _i ? Ti ? Ti.push(u) : Ti = [u] : _i = u,
        i = Gu(i, "onChange"),
        0 < i.length && (a = new Qs("onChange","change",null,a,u),
        n.push({
            event: a,
            listeners: i
        }))
    }
    var Vt = null
      , ti = null;
    function ga(n) {
        yy(n, 0)
    }
    function su(n) {
        var i = Qn(n);
        if (oa(i))
            return n
    }
    function Lp(n, i) {
        if (n === "change")
            return i
    }
    var Bp = !1;
    if (Vn) {
        var _f;
        if (Vn) {
            var Tf = "oninput"in document;
            if (!Tf) {
                var qp = document.createElement("div");
                qp.setAttribute("oninput", "return;"),
                Tf = typeof qp.oninput == "function"
            }
            _f = Tf
        } else
            _f = !1;
        Bp = _f && (!document.documentMode || 9 < document.documentMode)
    }
    function zp() {
        Vt && (Vt.detachEvent("onpropertychange", Fp),
        ti = Vt = null)
    }
    function Fp(n) {
        if (n.propertyName === "value" && su(ti)) {
            var i = [];
            Ai(i, ti, n, Sn(n)),
            Yl(ga, i)
        }
    }
    function B0(n, i, a) {
        n === "focusin" ? (zp(),
        Vt = i,
        ti = a,
        Vt.attachEvent("onpropertychange", Fp)) : n === "focusout" && zp()
    }
    function q0(n) {
        if (n === "selectionchange" || n === "keyup" || n === "keydown")
            return su(ti)
    }
    function z0(n, i) {
        if (n === "click")
            return su(i)
    }
    function F0(n, i) {
        if (n === "input" || n === "change")
            return su(i)
    }
    function H0(n, i) {
        return n === i && (n !== 0 || 1 / n === 1 / i) || n !== n && i !== i
    }
    var cn = typeof Object.is == "function" ? Object.is : H0;
    function ya(n, i) {
        if (cn(n, i))
            return !0;
        if (typeof n != "object" || n === null || typeof i != "object" || i === null)
            return !1;
        var a = Object.keys(n)
          , u = Object.keys(i);
        if (a.length !== u.length)
            return !1;
        for (u = 0; u < a.length; u++) {
            var h = a[u];
            if (!Br.call(i, h) || !cn(n[h], i[h]))
                return !1
        }
        return !0
    }
    function Hp(n) {
        for (; n && n.firstChild; )
            n = n.firstChild;
        return n
    }
    function Gp(n, i) {
        var a = Hp(n);
        n = 0;
        for (var u; a; ) {
            if (a.nodeType === 3) {
                if (u = n + a.textContent.length,
                n <= i && u >= i)
                    return {
                        node: a,
                        offset: i - n
                    };
                n = u
            }
            e: {
                for (; a; ) {
                    if (a.nextSibling) {
                        a = a.nextSibling;
                        break e
                    }
                    a = a.parentNode
                }
                a = void 0
            }
            a = Hp(a)
        }
    }
    function Yp(n, i) {
        return n && i ? n === i ? !0 : n && n.nodeType === 3 ? !1 : i && i.nodeType === 3 ? Yp(n, i.parentNode) : "contains"in n ? n.contains(i) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(i) & 16) : !1 : !1
    }
    function Kp(n) {
        n = n != null && n.ownerDocument != null && n.ownerDocument.defaultView != null ? n.ownerDocument.defaultView : window;
        for (var i = Jr(n.document); i instanceof n.HTMLIFrameElement; ) {
            try {
                var a = typeof i.contentWindow.location.href == "string"
            } catch {
                a = !1
            }
            if (a)
                n = i.contentWindow;
            else
                break;
            i = Jr(n.document)
        }
        return i
    }
    function Ef(n) {
        var i = n && n.nodeName && n.nodeName.toLowerCase();
        return i && (i === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || i === "textarea" || n.contentEditable === "true")
    }
    var G0 = Vn && "documentMode"in document && 11 >= document.documentMode
      , to = null
      , Sf = null
      , va = null
      , Af = !1;
    function Qp(n, i, a) {
        var u = a.window === a ? a.document : a.nodeType === 9 ? a : a.ownerDocument;
        Af || to == null || to !== Jr(u) || (u = to,
        "selectionStart"in u && Ef(u) ? u = {
            start: u.selectionStart,
            end: u.selectionEnd
        } : (u = (u.ownerDocument && u.ownerDocument.defaultView || window).getSelection(),
        u = {
            anchorNode: u.anchorNode,
            anchorOffset: u.anchorOffset,
            focusNode: u.focusNode,
            focusOffset: u.focusOffset
        }),
        va && ya(va, u) || (va = u,
        u = Gu(Sf, "onSelect"),
        0 < u.length && (i = new Qs("onSelect","select",null,i,a),
        n.push({
            event: i,
            listeners: u
        }),
        i.target = to)))
    }
    function as(n, i) {
        var a = {};
        return a[n.toLowerCase()] = i.toLowerCase(),
        a["Webkit" + n] = "webkit" + i,
        a["Moz" + n] = "moz" + i,
        a
    }
    var no = {
        animationend: as("Animation", "AnimationEnd"),
        animationiteration: as("Animation", "AnimationIteration"),
        animationstart: as("Animation", "AnimationStart"),
        transitionrun: as("Transition", "TransitionRun"),
        transitionstart: as("Transition", "TransitionStart"),
        transitioncancel: as("Transition", "TransitionCancel"),
        transitionend: as("Transition", "TransitionEnd")
    }
      , Cf = {}
      , Xp = {};
    Vn && (Xp = document.createElement("div").style,
    "AnimationEvent"in window || (delete no.animationend.animation,
    delete no.animationiteration.animation,
    delete no.animationstart.animation),
    "TransitionEvent"in window || delete no.transitionend.transition);
    function ls(n) {
        if (Cf[n])
            return Cf[n];
        if (!no[n])
            return n;
        var i = no[n], a;
        for (a in i)
            if (i.hasOwnProperty(a) && a in Xp)
                return Cf[n] = i[a];
        return n
    }
    var $p = ls("animationend")
      , Jp = ls("animationiteration")
      , jp = ls("animationstart")
      , Y0 = ls("transitionrun")
      , K0 = ls("transitionstart")
      , Q0 = ls("transitioncancel")
      , Wp = ls("transitionend")
      , Zp = new Map
      , Rf = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    Rf.push("scrollEnd");
    function Un(n, i) {
        Zp.set(n, i),
        On(i, [n])
    }
    var em = new WeakMap;
    function Rn(n, i) {
        if (typeof n == "object" && n !== null) {
            var a = em.get(n);
            return a !== void 0 ? a : (i = {
                value: n,
                source: i,
                stack: Gs(i)
            },
            em.set(n, i),
            i)
        }
        return {
            value: n,
            source: i,
            stack: Gs(i)
        }
    }
    var In = []
      , io = 0
      , If = 0;
    function ou() {
        for (var n = io, i = If = io = 0; i < n; ) {
            var a = In[i];
            In[i++] = null;
            var u = In[i];
            In[i++] = null;
            var h = In[i];
            In[i++] = null;
            var g = In[i];
            if (In[i++] = null,
            u !== null && h !== null) {
                var S = u.pending;
                S === null ? h.next = h : (h.next = S.next,
                S.next = h),
                u.pending = h
            }
            g !== 0 && tm(a, h, g)
        }
    }
    function au(n, i, a, u) {
        In[io++] = n,
        In[io++] = i,
        In[io++] = a,
        In[io++] = u,
        If |= u,
        n.lanes |= u,
        n = n.alternate,
        n !== null && (n.lanes |= u)
    }
    function wf(n, i, a, u) {
        return au(n, i, a, u),
        lu(n)
    }
    function ro(n, i) {
        return au(n, null, null, i),
        lu(n)
    }
    function tm(n, i, a) {
        n.lanes |= a;
        var u = n.alternate;
        u !== null && (u.lanes |= a);
        for (var h = !1, g = n.return; g !== null; )
            g.childLanes |= a,
            u = g.alternate,
            u !== null && (u.childLanes |= a),
            g.tag === 22 && (n = g.stateNode,
            n === null || n._visibility & 1 || (h = !0)),
            n = g,
            g = g.return;
        return n.tag === 3 ? (g = n.stateNode,
        h && i !== null && (h = 31 - Ht(a),
        n = g.hiddenUpdates,
        u = n[h],
        u === null ? n[h] = [i] : u.push(i),
        i.lane = a | 536870912),
        g) : null
    }
    function lu(n) {
        if (50 < Ha)
            throw Ha = 0,
            Ph = null,
            Error(s(185));
        for (var i = n.return; i !== null; )
            n = i,
            i = n.return;
        return n.tag === 3 ? n.stateNode : null
    }
    var so = {};
    function X0(n, i, a, u) {
        this.tag = n,
        this.key = a,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.refCleanup = this.ref = null,
        this.pendingProps = i,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = u,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function fn(n, i, a, u) {
        return new X0(n,i,a,u)
    }
    function bf(n) {
        return n = n.prototype,
        !(!n || !n.isReactComponent)
    }
    function Ci(n, i) {
        var a = n.alternate;
        return a === null ? (a = fn(n.tag, i, n.key, n.mode),
        a.elementType = n.elementType,
        a.type = n.type,
        a.stateNode = n.stateNode,
        a.alternate = n,
        n.alternate = a) : (a.pendingProps = i,
        a.type = n.type,
        a.flags = 0,
        a.subtreeFlags = 0,
        a.deletions = null),
        a.flags = n.flags & 65011712,
        a.childLanes = n.childLanes,
        a.lanes = n.lanes,
        a.child = n.child,
        a.memoizedProps = n.memoizedProps,
        a.memoizedState = n.memoizedState,
        a.updateQueue = n.updateQueue,
        i = n.dependencies,
        a.dependencies = i === null ? null : {
            lanes: i.lanes,
            firstContext: i.firstContext
        },
        a.sibling = n.sibling,
        a.index = n.index,
        a.ref = n.ref,
        a.refCleanup = n.refCleanup,
        a
    }
    function nm(n, i) {
        n.flags &= 65011714;
        var a = n.alternate;
        return a === null ? (n.childLanes = 0,
        n.lanes = i,
        n.child = null,
        n.subtreeFlags = 0,
        n.memoizedProps = null,
        n.memoizedState = null,
        n.updateQueue = null,
        n.dependencies = null,
        n.stateNode = null) : (n.childLanes = a.childLanes,
        n.lanes = a.lanes,
        n.child = a.child,
        n.subtreeFlags = 0,
        n.deletions = null,
        n.memoizedProps = a.memoizedProps,
        n.memoizedState = a.memoizedState,
        n.updateQueue = a.updateQueue,
        n.type = a.type,
        i = a.dependencies,
        n.dependencies = i === null ? null : {
            lanes: i.lanes,
            firstContext: i.firstContext
        }),
        n
    }
    function uu(n, i, a, u, h, g) {
        var S = 0;
        if (u = n,
        typeof n == "function")
            bf(n) && (S = 1);
        else if (typeof n == "string")
            S = JS(n, a, me.current) ? 26 : n === "html" || n === "head" || n === "body" ? 27 : 5;
        else
            e: switch (n) {
            case M:
                return n = fn(31, a, i, h),
                n.elementType = M,
                n.lanes = g,
                n;
            case q:
                return us(a.children, h, g, i);
            case G:
                S = 8,
                h |= 24;
                break;
            case J:
                return n = fn(12, a, i, h | 2),
                n.elementType = J,
                n.lanes = g,
                n;
            case fe:
                return n = fn(13, a, i, h),
                n.elementType = fe,
                n.lanes = g,
                n;
            case Ie:
                return n = fn(19, a, i, h),
                n.elementType = Ie,
                n.lanes = g,
                n;
            default:
                if (typeof n == "object" && n !== null)
                    switch (n.$$typeof) {
                    case ne:
                    case le:
                        S = 10;
                        break e;
                    case se:
                        S = 9;
                        break e;
                    case ue:
                        S = 11;
                        break e;
                    case U:
                        S = 14;
                        break e;
                    case w:
                        S = 16,
                        u = null;
                        break e
                    }
                S = 29,
                a = Error(s(130, n === null ? "null" : typeof n, "")),
                u = null
            }
        return i = fn(S, a, i, h),
        i.elementType = n,
        i.type = u,
        i.lanes = g,
        i
    }
    function us(n, i, a, u) {
        return n = fn(7, n, u, i),
        n.lanes = a,
        n
    }
    function Df(n, i, a) {
        return n = fn(6, n, null, i),
        n.lanes = a,
        n
    }
    function Mf(n, i, a) {
        return i = fn(4, n.children !== null ? n.children : [], n.key, i),
        i.lanes = a,
        i.stateNode = {
            containerInfo: n.containerInfo,
            pendingChildren: null,
            implementation: n.implementation
        },
        i
    }
    var oo = []
      , ao = 0
      , cu = null
      , fu = 0
      , wn = []
      , bn = 0
      , cs = null
      , Ri = 1
      , Ii = "";
    function fs(n, i) {
        oo[ao++] = fu,
        oo[ao++] = cu,
        cu = n,
        fu = i
    }
    function im(n, i, a) {
        wn[bn++] = Ri,
        wn[bn++] = Ii,
        wn[bn++] = cs,
        cs = n;
        var u = Ri;
        n = Ii;
        var h = 32 - Ht(u) - 1;
        u &= ~(1 << h),
        a += 1;
        var g = 32 - Ht(i) + h;
        if (30 < g) {
            var S = h - h % 5;
            g = (u & (1 << S) - 1).toString(32),
            u >>= S,
            h -= S,
            Ri = 1 << 32 - Ht(i) + h | a << h | u,
            Ii = g + n
        } else
            Ri = 1 << g | a << h | u,
            Ii = n
    }
    function Nf(n) {
        n.return !== null && (fs(n, 1),
        im(n, 1, 0))
    }
    function xf(n) {
        for (; n === cu; )
            cu = oo[--ao],
            oo[ao] = null,
            fu = oo[--ao],
            oo[ao] = null;
        for (; n === cs; )
            cs = wn[--bn],
            wn[bn] = null,
            Ii = wn[--bn],
            wn[bn] = null,
            Ri = wn[--bn],
            wn[bn] = null
    }
    var en = null
      , ot = null
      , qe = !1
      , hs = null
      , ni = !1
      , Pf = Error(s(519));
    function ds(n) {
        var i = Error(s(418, ""));
        throw Ea(Rn(i, n)),
        Pf
    }
    function rm(n) {
        var i = n.stateNode
          , a = n.type
          , u = n.memoizedProps;
        switch (i[Tt] = n,
        i[pt] = u,
        a) {
        case "dialog":
            Ne("cancel", i),
            Ne("close", i);
            break;
        case "iframe":
        case "object":
        case "embed":
            Ne("load", i);
            break;
        case "video":
        case "audio":
            for (a = 0; a < Ya.length; a++)
                Ne(Ya[a], i);
            break;
        case "source":
            Ne("error", i);
            break;
        case "img":
        case "image":
        case "link":
            Ne("error", i),
            Ne("load", i);
            break;
        case "details":
            Ne("toggle", i);
            break;
        case "input":
            Ne("invalid", i),
            jr(i, u.value, u.defaultValue, u.checked, u.defaultChecked, u.type, u.name, !0),
            Ys(i);
            break;
        case "select":
            Ne("invalid", i);
            break;
        case "textarea":
            Ne("invalid", i),
            Wr(i, u.value, u.defaultValue, u.children),
            Ys(i)
        }
        a = u.children,
        typeof a != "string" && typeof a != "number" && typeof a != "bigint" || i.textContent === "" + a || u.suppressHydrationWarning === !0 || Ey(i.textContent, a) ? (u.popover != null && (Ne("beforetoggle", i),
        Ne("toggle", i)),
        u.onScroll != null && Ne("scroll", i),
        u.onScrollEnd != null && Ne("scrollend", i),
        u.onClick != null && (i.onclick = Yu),
        i = !0) : i = !1,
        i || ds(n)
    }
    function sm(n) {
        for (en = n.return; en; )
            switch (en.tag) {
            case 5:
            case 13:
                ni = !1;
                return;
            case 27:
            case 3:
                ni = !0;
                return;
            default:
                en = en.return
            }
    }
    function _a(n) {
        if (n !== en)
            return !1;
        if (!qe)
            return sm(n),
            qe = !0,
            !1;
        var i = n.tag, a;
        if ((a = i !== 3 && i !== 27) && ((a = i === 5) && (a = n.type,
        a = !(a !== "form" && a !== "button") || $h(n.type, n.memoizedProps)),
        a = !a),
        a && ot && ds(n),
        sm(n),
        i === 13) {
            if (n = n.memoizedState,
            n = n !== null ? n.dehydrated : null,
            !n)
                throw Error(s(317));
            e: {
                for (n = n.nextSibling,
                i = 0; n; ) {
                    if (n.nodeType === 8)
                        if (a = n.data,
                        a === "/$") {
                            if (i === 0) {
                                ot = Ln(n.nextSibling);
                                break e
                            }
                            i--
                        } else
                            a !== "$" && a !== "$!" && a !== "$?" || i++;
                    n = n.nextSibling
                }
                ot = null
            }
        } else
            i === 27 ? (i = ot,
            gr(n.type) ? (n = Zh,
            Zh = null,
            ot = n) : ot = i) : ot = en ? Ln(n.stateNode.nextSibling) : null;
        return !0
    }
    function Ta() {
        ot = en = null,
        qe = !1
    }
    function om() {
        var n = hs;
        return n !== null && (rn === null ? rn = n : rn.push.apply(rn, n),
        hs = null),
        n
    }
    function Ea(n) {
        hs === null ? hs = [n] : hs.push(n)
    }
    var Of = ee(null)
      , ps = null
      , wi = null;
    function tr(n, i, a) {
        ie(Of, i._currentValue),
        i._currentValue = a
    }
    function bi(n) {
        n._currentValue = Of.current,
        ae(Of)
    }
    function Vf(n, i, a) {
        for (; n !== null; ) {
            var u = n.alternate;
            if ((n.childLanes & i) !== i ? (n.childLanes |= i,
            u !== null && (u.childLanes |= i)) : u !== null && (u.childLanes & i) !== i && (u.childLanes |= i),
            n === a)
                break;
            n = n.return
        }
    }
    function Uf(n, i, a, u) {
        var h = n.child;
        for (h !== null && (h.return = n); h !== null; ) {
            var g = h.dependencies;
            if (g !== null) {
                var S = h.child;
                g = g.firstContext;
                e: for (; g !== null; ) {
                    var C = g;
                    g = h;
                    for (var D = 0; D < i.length; D++)
                        if (C.context === i[D]) {
                            g.lanes |= a,
                            C = g.alternate,
                            C !== null && (C.lanes |= a),
                            Vf(g.return, a, n),
                            u || (S = null);
                            break e
                        }
                    g = C.next
                }
            } else if (h.tag === 18) {
                if (S = h.return,
                S === null)
                    throw Error(s(341));
                S.lanes |= a,
                g = S.alternate,
                g !== null && (g.lanes |= a),
                Vf(S, a, n),
                S = null
            } else
                S = h.child;
            if (S !== null)
                S.return = h;
            else
                for (S = h; S !== null; ) {
                    if (S === n) {
                        S = null;
                        break
                    }
                    if (h = S.sibling,
                    h !== null) {
                        h.return = S.return,
                        S = h;
                        break
                    }
                    S = S.return
                }
            h = S
        }
    }
    function Sa(n, i, a, u) {
        n = null;
        for (var h = i, g = !1; h !== null; ) {
            if (!g) {
                if ((h.flags & 524288) !== 0)
                    g = !0;
                else if ((h.flags & 262144) !== 0)
                    break
            }
            if (h.tag === 10) {
                var S = h.alternate;
                if (S === null)
                    throw Error(s(387));
                if (S = S.memoizedProps,
                S !== null) {
                    var C = h.type;
                    cn(h.pendingProps.value, S.value) || (n !== null ? n.push(C) : n = [C])
                }
            } else if (h === Rt.current) {
                if (S = h.alternate,
                S === null)
                    throw Error(s(387));
                S.memoizedState.memoizedState !== h.memoizedState.memoizedState && (n !== null ? n.push(ja) : n = [ja])
            }
            h = h.return
        }
        n !== null && Uf(i, n, a, u),
        i.flags |= 262144
    }
    function hu(n) {
        for (n = n.firstContext; n !== null; ) {
            if (!cn(n.context._currentValue, n.memoizedValue))
                return !0;
            n = n.next
        }
        return !1
    }
    function ms(n) {
        ps = n,
        wi = null,
        n = n.dependencies,
        n !== null && (n.firstContext = null)
    }
    function Gt(n) {
        return am(ps, n)
    }
    function du(n, i) {
        return ps === null && ms(n),
        am(n, i)
    }
    function am(n, i) {
        var a = i._currentValue;
        if (i = {
            context: i,
            memoizedValue: a,
            next: null
        },
        wi === null) {
            if (n === null)
                throw Error(s(308));
            wi = i,
            n.dependencies = {
                lanes: 0,
                firstContext: i
            },
            n.flags |= 524288
        } else
            wi = wi.next = i;
        return a
    }
    var $0 = typeof AbortController < "u" ? AbortController : function() {
        var n = []
          , i = this.signal = {
            aborted: !1,
            addEventListener: function(a, u) {
                n.push(u)
            }
        };
        this.abort = function() {
            i.aborted = !0,
            n.forEach(function(a) {
                return a()
            })
        }
    }
      , J0 = r.unstable_scheduleCallback
      , j0 = r.unstable_NormalPriority
      , At = {
        $$typeof: le,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
    };
    function kf() {
        return {
            controller: new $0,
            data: new Map,
            refCount: 0
        }
    }
    function Aa(n) {
        n.refCount--,
        n.refCount === 0 && J0(j0, function() {
            n.controller.abort()
        })
    }
    var Ca = null
      , Lf = 0
      , lo = 0
      , uo = null;
    function W0(n, i) {
        if (Ca === null) {
            var a = Ca = [];
            Lf = 0,
            lo = qh(),
            uo = {
                status: "pending",
                value: void 0,
                then: function(u) {
                    a.push(u)
                }
            }
        }
        return Lf++,
        i.then(lm, lm),
        i
    }
    function lm() {
        if (--Lf === 0 && Ca !== null) {
            uo !== null && (uo.status = "fulfilled");
            var n = Ca;
            Ca = null,
            lo = 0,
            uo = null;
            for (var i = 0; i < n.length; i++)
                (0,
                n[i])()
        }
    }
    function Z0(n, i) {
        var a = []
          , u = {
            status: "pending",
            value: null,
            reason: null,
            then: function(h) {
                a.push(h)
            }
        };
        return n.then(function() {
            u.status = "fulfilled",
            u.value = i;
            for (var h = 0; h < a.length; h++)
                (0,
                a[h])(i)
        }, function(h) {
            for (u.status = "rejected",
            u.reason = h,
            h = 0; h < a.length; h++)
                (0,
                a[h])(void 0)
        }),
        u
    }
    var um = X.S;
    X.S = function(n, i) {
        typeof i == "object" && i !== null && typeof i.then == "function" && W0(n, i),
        um !== null && um(n, i)
    }
    ;
    var gs = ee(null);
    function Bf() {
        var n = gs.current;
        return n !== null ? n : Ze.pooledCache
    }
    function pu(n, i) {
        i === null ? ie(gs, gs.current) : ie(gs, i.pool)
    }
    function cm() {
        var n = Bf();
        return n === null ? null : {
            parent: At._currentValue,
            pool: n
        }
    }
    var Ra = Error(s(460))
      , fm = Error(s(474))
      , mu = Error(s(542))
      , qf = {
        then: function() {}
    };
    function hm(n) {
        return n = n.status,
        n === "fulfilled" || n === "rejected"
    }
    function gu() {}
    function dm(n, i, a) {
        switch (a = n[a],
        a === void 0 ? n.push(i) : a !== i && (i.then(gu, gu),
        i = a),
        i.status) {
        case "fulfilled":
            return i.value;
        case "rejected":
            throw n = i.reason,
            mm(n),
            n;
        default:
            if (typeof i.status == "string")
                i.then(gu, gu);
            else {
                if (n = Ze,
                n !== null && 100 < n.shellSuspendCounter)
                    throw Error(s(482));
                n = i,
                n.status = "pending",
                n.then(function(u) {
                    if (i.status === "pending") {
                        var h = i;
                        h.status = "fulfilled",
                        h.value = u
                    }
                }, function(u) {
                    if (i.status === "pending") {
                        var h = i;
                        h.status = "rejected",
                        h.reason = u
                    }
                })
            }
            switch (i.status) {
            case "fulfilled":
                return i.value;
            case "rejected":
                throw n = i.reason,
                mm(n),
                n
            }
            throw Ia = i,
            Ra
        }
    }
    var Ia = null;
    function pm() {
        if (Ia === null)
            throw Error(s(459));
        var n = Ia;
        return Ia = null,
        n
    }
    function mm(n) {
        if (n === Ra || n === mu)
            throw Error(s(483))
    }
    var nr = !1;
    function zf(n) {
        n.updateQueue = {
            baseState: n.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                lanes: 0,
                hiddenCallbacks: null
            },
            callbacks: null
        }
    }
    function Ff(n, i) {
        n = n.updateQueue,
        i.updateQueue === n && (i.updateQueue = {
            baseState: n.baseState,
            firstBaseUpdate: n.firstBaseUpdate,
            lastBaseUpdate: n.lastBaseUpdate,
            shared: n.shared,
            callbacks: null
        })
    }
    function ir(n) {
        return {
            lane: n,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function rr(n, i, a) {
        var u = n.updateQueue;
        if (u === null)
            return null;
        if (u = u.shared,
        (He & 2) !== 0) {
            var h = u.pending;
            return h === null ? i.next = i : (i.next = h.next,
            h.next = i),
            u.pending = i,
            i = lu(n),
            tm(n, null, a),
            i
        }
        return au(n, u, i, a),
        lu(n)
    }
    function wa(n, i, a) {
        if (i = i.updateQueue,
        i !== null && (i = i.shared,
        (a & 4194048) !== 0)) {
            var u = i.lanes;
            u &= n.pendingLanes,
            a |= u,
            i.lanes = a,
            ta(n, a)
        }
    }
    function Hf(n, i) {
        var a = n.updateQueue
          , u = n.alternate;
        if (u !== null && (u = u.updateQueue,
        a === u)) {
            var h = null
              , g = null;
            if (a = a.firstBaseUpdate,
            a !== null) {
                do {
                    var S = {
                        lane: a.lane,
                        tag: a.tag,
                        payload: a.payload,
                        callback: null,
                        next: null
                    };
                    g === null ? h = g = S : g = g.next = S,
                    a = a.next
                } while (a !== null);
                g === null ? h = g = i : g = g.next = i
            } else
                h = g = i;
            a = {
                baseState: u.baseState,
                firstBaseUpdate: h,
                lastBaseUpdate: g,
                shared: u.shared,
                callbacks: u.callbacks
            },
            n.updateQueue = a;
            return
        }
        n = a.lastBaseUpdate,
        n === null ? a.firstBaseUpdate = i : n.next = i,
        a.lastBaseUpdate = i
    }
    var Gf = !1;
    function ba() {
        if (Gf) {
            var n = uo;
            if (n !== null)
                throw n
        }
    }
    function Da(n, i, a, u) {
        Gf = !1;
        var h = n.updateQueue;
        nr = !1;
        var g = h.firstBaseUpdate
          , S = h.lastBaseUpdate
          , C = h.shared.pending;
        if (C !== null) {
            h.shared.pending = null;
            var D = C
              , H = D.next;
            D.next = null,
            S === null ? g = H : S.next = H,
            S = D;
            var $ = n.alternate;
            $ !== null && ($ = $.updateQueue,
            C = $.lastBaseUpdate,
            C !== S && (C === null ? $.firstBaseUpdate = H : C.next = H,
            $.lastBaseUpdate = D))
        }
        if (g !== null) {
            var W = h.baseState;
            S = 0,
            $ = H = D = null,
            C = g;
            do {
                var Y = C.lane & -536870913
                  , K = Y !== C.lane;
                if (K ? (Ve & Y) === Y : (u & Y) === Y) {
                    Y !== 0 && Y === lo && (Gf = !0),
                    $ !== null && ($ = $.next = {
                        lane: 0,
                        tag: C.tag,
                        payload: C.payload,
                        callback: null,
                        next: null
                    });
                    e: {
                        var _e = n
                          , ge = C;
                        Y = i;
                        var Xe = a;
                        switch (ge.tag) {
                        case 1:
                            if (_e = ge.payload,
                            typeof _e == "function") {
                                W = _e.call(Xe, W, Y);
                                break e
                            }
                            W = _e;
                            break e;
                        case 3:
                            _e.flags = _e.flags & -65537 | 128;
                        case 0:
                            if (_e = ge.payload,
                            Y = typeof _e == "function" ? _e.call(Xe, W, Y) : _e,
                            Y == null)
                                break e;
                            W = T({}, W, Y);
                            break e;
                        case 2:
                            nr = !0
                        }
                    }
                    Y = C.callback,
                    Y !== null && (n.flags |= 64,
                    K && (n.flags |= 8192),
                    K = h.callbacks,
                    K === null ? h.callbacks = [Y] : K.push(Y))
                } else
                    K = {
                        lane: Y,
                        tag: C.tag,
                        payload: C.payload,
                        callback: C.callback,
                        next: null
                    },
                    $ === null ? (H = $ = K,
                    D = W) : $ = $.next = K,
                    S |= Y;
                if (C = C.next,
                C === null) {
                    if (C = h.shared.pending,
                    C === null)
                        break;
                    K = C,
                    C = K.next,
                    K.next = null,
                    h.lastBaseUpdate = K,
                    h.shared.pending = null
                }
            } while (!0);
            $ === null && (D = W),
            h.baseState = D,
            h.firstBaseUpdate = H,
            h.lastBaseUpdate = $,
            g === null && (h.shared.lanes = 0),
            hr |= S,
            n.lanes = S,
            n.memoizedState = W
        }
    }
    function gm(n, i) {
        if (typeof n != "function")
            throw Error(s(191, n));
        n.call(i)
    }
    function ym(n, i) {
        var a = n.callbacks;
        if (a !== null)
            for (n.callbacks = null,
            n = 0; n < a.length; n++)
                gm(a[n], i)
    }
    var co = ee(null)
      , yu = ee(0);
    function vm(n, i) {
        n = Vi,
        ie(yu, n),
        ie(co, i),
        Vi = n | i.baseLanes
    }
    function Yf() {
        ie(yu, Vi),
        ie(co, co.current)
    }
    function Kf() {
        Vi = yu.current,
        ae(co),
        ae(yu)
    }
    var sr = 0
      , Ce = null
      , Ke = null
      , gt = null
      , vu = !1
      , fo = !1
      , ys = !1
      , _u = 0
      , Ma = 0
      , ho = null
      , eS = 0;
    function ft() {
        throw Error(s(321))
    }
    function Qf(n, i) {
        if (i === null)
            return !1;
        for (var a = 0; a < i.length && a < n.length; a++)
            if (!cn(n[a], i[a]))
                return !1;
        return !0
    }
    function Xf(n, i, a, u, h, g) {
        return sr = g,
        Ce = i,
        i.memoizedState = null,
        i.updateQueue = null,
        i.lanes = 0,
        X.H = n === null || n.memoizedState === null ? tg : ng,
        ys = !1,
        g = a(u, h),
        ys = !1,
        fo && (g = Tm(i, a, u, h)),
        _m(n),
        g
    }
    function _m(n) {
        X.H = Ru;
        var i = Ke !== null && Ke.next !== null;
        if (sr = 0,
        gt = Ke = Ce = null,
        vu = !1,
        Ma = 0,
        ho = null,
        i)
            throw Error(s(300));
        n === null || bt || (n = n.dependencies,
        n !== null && hu(n) && (bt = !0))
    }
    function Tm(n, i, a, u) {
        Ce = n;
        var h = 0;
        do {
            if (fo && (ho = null),
            Ma = 0,
            fo = !1,
            25 <= h)
                throw Error(s(301));
            if (h += 1,
            gt = Ke = null,
            n.updateQueue != null) {
                var g = n.updateQueue;
                g.lastEffect = null,
                g.events = null,
                g.stores = null,
                g.memoCache != null && (g.memoCache.index = 0)
            }
            X.H = aS,
            g = i(a, u)
        } while (fo);
        return g
    }
    function tS() {
        var n = X.H
          , i = n.useState()[0];
        return i = typeof i.then == "function" ? Na(i) : i,
        n = n.useState()[0],
        (Ke !== null ? Ke.memoizedState : null) !== n && (Ce.flags |= 1024),
        i
    }
    function $f() {
        var n = _u !== 0;
        return _u = 0,
        n
    }
    function Jf(n, i, a) {
        i.updateQueue = n.updateQueue,
        i.flags &= -2053,
        n.lanes &= ~a
    }
    function jf(n) {
        if (vu) {
            for (n = n.memoizedState; n !== null; ) {
                var i = n.queue;
                i !== null && (i.pending = null),
                n = n.next
            }
            vu = !1
        }
        sr = 0,
        gt = Ke = Ce = null,
        fo = !1,
        Ma = _u = 0,
        ho = null
    }
    function tn() {
        var n = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return gt === null ? Ce.memoizedState = gt = n : gt = gt.next = n,
        gt
    }
    function yt() {
        if (Ke === null) {
            var n = Ce.alternate;
            n = n !== null ? n.memoizedState : null
        } else
            n = Ke.next;
        var i = gt === null ? Ce.memoizedState : gt.next;
        if (i !== null)
            gt = i,
            Ke = n;
        else {
            if (n === null)
                throw Ce.alternate === null ? Error(s(467)) : Error(s(310));
            Ke = n,
            n = {
                memoizedState: Ke.memoizedState,
                baseState: Ke.baseState,
                baseQueue: Ke.baseQueue,
                queue: Ke.queue,
                next: null
            },
            gt === null ? Ce.memoizedState = gt = n : gt = gt.next = n
        }
        return gt
    }
    function Wf() {
        return {
            lastEffect: null,
            events: null,
            stores: null,
            memoCache: null
        }
    }
    function Na(n) {
        var i = Ma;
        return Ma += 1,
        ho === null && (ho = []),
        n = dm(ho, n, i),
        i = Ce,
        (gt === null ? i.memoizedState : gt.next) === null && (i = i.alternate,
        X.H = i === null || i.memoizedState === null ? tg : ng),
        n
    }
    function Tu(n) {
        if (n !== null && typeof n == "object") {
            if (typeof n.then == "function")
                return Na(n);
            if (n.$$typeof === le)
                return Gt(n)
        }
        throw Error(s(438, String(n)))
    }
    function Zf(n) {
        var i = null
          , a = Ce.updateQueue;
        if (a !== null && (i = a.memoCache),
        i == null) {
            var u = Ce.alternate;
            u !== null && (u = u.updateQueue,
            u !== null && (u = u.memoCache,
            u != null && (i = {
                data: u.data.map(function(h) {
                    return h.slice()
                }),
                index: 0
            })))
        }
        if (i == null && (i = {
            data: [],
            index: 0
        }),
        a === null && (a = Wf(),
        Ce.updateQueue = a),
        a.memoCache = i,
        a = i.data[i.index],
        a === void 0)
            for (a = i.data[i.index] = Array(n),
            u = 0; u < n; u++)
                a[u] = P;
        return i.index++,
        a
    }
    function Di(n, i) {
        return typeof i == "function" ? i(n) : i
    }
    function Eu(n) {
        var i = yt();
        return eh(i, Ke, n)
    }
    function eh(n, i, a) {
        var u = n.queue;
        if (u === null)
            throw Error(s(311));
        u.lastRenderedReducer = a;
        var h = n.baseQueue
          , g = u.pending;
        if (g !== null) {
            if (h !== null) {
                var S = h.next;
                h.next = g.next,
                g.next = S
            }
            i.baseQueue = h = g,
            u.pending = null
        }
        if (g = n.baseState,
        h === null)
            n.memoizedState = g;
        else {
            i = h.next;
            var C = S = null
              , D = null
              , H = i
              , $ = !1;
            do {
                var W = H.lane & -536870913;
                if (W !== H.lane ? (Ve & W) === W : (sr & W) === W) {
                    var Y = H.revertLane;
                    if (Y === 0)
                        D !== null && (D = D.next = {
                            lane: 0,
                            revertLane: 0,
                            action: H.action,
                            hasEagerState: H.hasEagerState,
                            eagerState: H.eagerState,
                            next: null
                        }),
                        W === lo && ($ = !0);
                    else if ((sr & Y) === Y) {
                        H = H.next,
                        Y === lo && ($ = !0);
                        continue
                    } else
                        W = {
                            lane: 0,
                            revertLane: H.revertLane,
                            action: H.action,
                            hasEagerState: H.hasEagerState,
                            eagerState: H.eagerState,
                            next: null
                        },
                        D === null ? (C = D = W,
                        S = g) : D = D.next = W,
                        Ce.lanes |= Y,
                        hr |= Y;
                    W = H.action,
                    ys && a(g, W),
                    g = H.hasEagerState ? H.eagerState : a(g, W)
                } else
                    Y = {
                        lane: W,
                        revertLane: H.revertLane,
                        action: H.action,
                        hasEagerState: H.hasEagerState,
                        eagerState: H.eagerState,
                        next: null
                    },
                    D === null ? (C = D = Y,
                    S = g) : D = D.next = Y,
                    Ce.lanes |= W,
                    hr |= W;
                H = H.next
            } while (H !== null && H !== i);
            if (D === null ? S = g : D.next = C,
            !cn(g, n.memoizedState) && (bt = !0,
            $ && (a = uo,
            a !== null)))
                throw a;
            n.memoizedState = g,
            n.baseState = S,
            n.baseQueue = D,
            u.lastRenderedState = g
        }
        return h === null && (u.lanes = 0),
        [n.memoizedState, u.dispatch]
    }
    function th(n) {
        var i = yt()
          , a = i.queue;
        if (a === null)
            throw Error(s(311));
        a.lastRenderedReducer = n;
        var u = a.dispatch
          , h = a.pending
          , g = i.memoizedState;
        if (h !== null) {
            a.pending = null;
            var S = h = h.next;
            do
                g = n(g, S.action),
                S = S.next;
            while (S !== h);
            cn(g, i.memoizedState) || (bt = !0),
            i.memoizedState = g,
            i.baseQueue === null && (i.baseState = g),
            a.lastRenderedState = g
        }
        return [g, u]
    }
    function Em(n, i, a) {
        var u = Ce
          , h = yt()
          , g = qe;
        if (g) {
            if (a === void 0)
                throw Error(s(407));
            a = a()
        } else
            a = i();
        var S = !cn((Ke || h).memoizedState, a);
        S && (h.memoizedState = a,
        bt = !0),
        h = h.queue;
        var C = Cm.bind(null, u, h, n);
        if (xa(2048, 8, C, [n]),
        h.getSnapshot !== i || S || gt !== null && gt.memoizedState.tag & 1) {
            if (u.flags |= 2048,
            po(9, Su(), Am.bind(null, u, h, a, i), null),
            Ze === null)
                throw Error(s(349));
            g || (sr & 124) !== 0 || Sm(u, i, a)
        }
        return a
    }
    function Sm(n, i, a) {
        n.flags |= 16384,
        n = {
            getSnapshot: i,
            value: a
        },
        i = Ce.updateQueue,
        i === null ? (i = Wf(),
        Ce.updateQueue = i,
        i.stores = [n]) : (a = i.stores,
        a === null ? i.stores = [n] : a.push(n))
    }
    function Am(n, i, a, u) {
        i.value = a,
        i.getSnapshot = u,
        Rm(i) && Im(n)
    }
    function Cm(n, i, a) {
        return a(function() {
            Rm(i) && Im(n)
        })
    }
    function Rm(n) {
        var i = n.getSnapshot;
        n = n.value;
        try {
            var a = i();
            return !cn(n, a)
        } catch {
            return !0
        }
    }
    function Im(n) {
        var i = ro(n, 2);
        i !== null && gn(i, n, 2)
    }
    function nh(n) {
        var i = tn();
        if (typeof n == "function") {
            var a = n;
            if (n = a(),
            ys) {
                ln(!0);
                try {
                    a()
                } finally {
                    ln(!1)
                }
            }
        }
        return i.memoizedState = i.baseState = n,
        i.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Di,
            lastRenderedState: n
        },
        i
    }
    function wm(n, i, a, u) {
        return n.baseState = a,
        eh(n, Ke, typeof u == "function" ? u : Di)
    }
    function nS(n, i, a, u, h) {
        if (Cu(n))
            throw Error(s(485));
        if (n = i.action,
        n !== null) {
            var g = {
                payload: h,
                action: n,
                next: null,
                isTransition: !0,
                status: "pending",
                value: null,
                reason: null,
                listeners: [],
                then: function(S) {
                    g.listeners.push(S)
                }
            };
            X.T !== null ? a(!0) : g.isTransition = !1,
            u(g),
            a = i.pending,
            a === null ? (g.next = i.pending = g,
            bm(i, g)) : (g.next = a.next,
            i.pending = a.next = g)
        }
    }
    function bm(n, i) {
        var a = i.action
          , u = i.payload
          , h = n.state;
        if (i.isTransition) {
            var g = X.T
              , S = {};
            X.T = S;
            try {
                var C = a(h, u)
                  , D = X.S;
                D !== null && D(S, C),
                Dm(n, i, C)
            } catch (H) {
                ih(n, i, H)
            } finally {
                X.T = g
            }
        } else
            try {
                g = a(h, u),
                Dm(n, i, g)
            } catch (H) {
                ih(n, i, H)
            }
    }
    function Dm(n, i, a) {
        a !== null && typeof a == "object" && typeof a.then == "function" ? a.then(function(u) {
            Mm(n, i, u)
        }, function(u) {
            return ih(n, i, u)
        }) : Mm(n, i, a)
    }
    function Mm(n, i, a) {
        i.status = "fulfilled",
        i.value = a,
        Nm(i),
        n.state = a,
        i = n.pending,
        i !== null && (a = i.next,
        a === i ? n.pending = null : (a = a.next,
        i.next = a,
        bm(n, a)))
    }
    function ih(n, i, a) {
        var u = n.pending;
        if (n.pending = null,
        u !== null) {
            u = u.next;
            do
                i.status = "rejected",
                i.reason = a,
                Nm(i),
                i = i.next;
            while (i !== u)
        }
        n.action = null
    }
    function Nm(n) {
        n = n.listeners;
        for (var i = 0; i < n.length; i++)
            (0,
            n[i])()
    }
    function xm(n, i) {
        return i
    }
    function Pm(n, i) {
        if (qe) {
            var a = Ze.formState;
            if (a !== null) {
                e: {
                    var u = Ce;
                    if (qe) {
                        if (ot) {
                            t: {
                                for (var h = ot, g = ni; h.nodeType !== 8; ) {
                                    if (!g) {
                                        h = null;
                                        break t
                                    }
                                    if (h = Ln(h.nextSibling),
                                    h === null) {
                                        h = null;
                                        break t
                                    }
                                }
                                g = h.data,
                                h = g === "F!" || g === "F" ? h : null
                            }
                            if (h) {
                                ot = Ln(h.nextSibling),
                                u = h.data === "F!";
                                break e
                            }
                        }
                        ds(u)
                    }
                    u = !1
                }
                u && (i = a[0])
            }
        }
        return a = tn(),
        a.memoizedState = a.baseState = i,
        u = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: xm,
            lastRenderedState: i
        },
        a.queue = u,
        a = Wm.bind(null, Ce, u),
        u.dispatch = a,
        u = nh(!1),
        g = lh.bind(null, Ce, !1, u.queue),
        u = tn(),
        h = {
            state: i,
            dispatch: null,
            action: n,
            pending: null
        },
        u.queue = h,
        a = nS.bind(null, Ce, h, g, a),
        h.dispatch = a,
        u.memoizedState = n,
        [i, a, !1]
    }
    function Om(n) {
        var i = yt();
        return Vm(i, Ke, n)
    }
    function Vm(n, i, a) {
        if (i = eh(n, i, xm)[0],
        n = Eu(Di)[0],
        typeof i == "object" && i !== null && typeof i.then == "function")
            try {
                var u = Na(i)
            } catch (S) {
                throw S === Ra ? mu : S
            }
        else
            u = i;
        i = yt();
        var h = i.queue
          , g = h.dispatch;
        return a !== i.memoizedState && (Ce.flags |= 2048,
        po(9, Su(), iS.bind(null, h, a), null)),
        [u, g, n]
    }
    function iS(n, i) {
        n.action = i
    }
    function Um(n) {
        var i = yt()
          , a = Ke;
        if (a !== null)
            return Vm(i, a, n);
        yt(),
        i = i.memoizedState,
        a = yt();
        var u = a.queue.dispatch;
        return a.memoizedState = n,
        [i, u, !1]
    }
    function po(n, i, a, u) {
        return n = {
            tag: n,
            create: a,
            deps: u,
            inst: i,
            next: null
        },
        i = Ce.updateQueue,
        i === null && (i = Wf(),
        Ce.updateQueue = i),
        a = i.lastEffect,
        a === null ? i.lastEffect = n.next = n : (u = a.next,
        a.next = n,
        n.next = u,
        i.lastEffect = n),
        n
    }
    function Su() {
        return {
            destroy: void 0,
            resource: void 0
        }
    }
    function km() {
        return yt().memoizedState
    }
    function Au(n, i, a, u) {
        var h = tn();
        u = u === void 0 ? null : u,
        Ce.flags |= n,
        h.memoizedState = po(1 | i, Su(), a, u)
    }
    function xa(n, i, a, u) {
        var h = yt();
        u = u === void 0 ? null : u;
        var g = h.memoizedState.inst;
        Ke !== null && u !== null && Qf(u, Ke.memoizedState.deps) ? h.memoizedState = po(i, g, a, u) : (Ce.flags |= n,
        h.memoizedState = po(1 | i, g, a, u))
    }
    function Lm(n, i) {
        Au(8390656, 8, n, i)
    }
    function Bm(n, i) {
        xa(2048, 8, n, i)
    }
    function qm(n, i) {
        return xa(4, 2, n, i)
    }
    function zm(n, i) {
        return xa(4, 4, n, i)
    }
    function Fm(n, i) {
        if (typeof i == "function") {
            n = n();
            var a = i(n);
            return function() {
                typeof a == "function" ? a() : i(null)
            }
        }
        if (i != null)
            return n = n(),
            i.current = n,
            function() {
                i.current = null
            }
    }
    function Hm(n, i, a) {
        a = a != null ? a.concat([n]) : null,
        xa(4, 4, Fm.bind(null, i, n), a)
    }
    function rh() {}
    function Gm(n, i) {
        var a = yt();
        i = i === void 0 ? null : i;
        var u = a.memoizedState;
        return i !== null && Qf(i, u[1]) ? u[0] : (a.memoizedState = [n, i],
        n)
    }
    function Ym(n, i) {
        var a = yt();
        i = i === void 0 ? null : i;
        var u = a.memoizedState;
        if (i !== null && Qf(i, u[1]))
            return u[0];
        if (u = n(),
        ys) {
            ln(!0);
            try {
                n()
            } finally {
                ln(!1)
            }
        }
        return a.memoizedState = [u, i],
        u
    }
    function sh(n, i, a) {
        return a === void 0 || (sr & 1073741824) !== 0 ? n.memoizedState = i : (n.memoizedState = a,
        n = Xg(),
        Ce.lanes |= n,
        hr |= n,
        a)
    }
    function Km(n, i, a, u) {
        return cn(a, i) ? a : co.current !== null ? (n = sh(n, a, u),
        cn(n, i) || (bt = !0),
        n) : (sr & 42) === 0 ? (bt = !0,
        n.memoizedState = a) : (n = Xg(),
        Ce.lanes |= n,
        hr |= n,
        i)
    }
    function Qm(n, i, a, u, h) {
        var g = oe.p;
        oe.p = g !== 0 && 8 > g ? g : 8;
        var S = X.T
          , C = {};
        X.T = C,
        lh(n, !1, i, a);
        try {
            var D = h()
              , H = X.S;
            if (H !== null && H(C, D),
            D !== null && typeof D == "object" && typeof D.then == "function") {
                var $ = Z0(D, u);
                Pa(n, i, $, mn(n))
            } else
                Pa(n, i, u, mn(n))
        } catch (W) {
            Pa(n, i, {
                then: function() {},
                status: "rejected",
                reason: W
            }, mn())
        } finally {
            oe.p = g,
            X.T = S
        }
    }
    function rS() {}
    function oh(n, i, a, u) {
        if (n.tag !== 5)
            throw Error(s(476));
        var h = Xm(n).queue;
        Qm(n, h, i, pe, a === null ? rS : function() {
            return $m(n),
            a(u)
        }
        )
    }
    function Xm(n) {
        var i = n.memoizedState;
        if (i !== null)
            return i;
        i = {
            memoizedState: pe,
            baseState: pe,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Di,
                lastRenderedState: pe
            },
            next: null
        };
        var a = {};
        return i.next = {
            memoizedState: a,
            baseState: a,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Di,
                lastRenderedState: a
            },
            next: null
        },
        n.memoizedState = i,
        n = n.alternate,
        n !== null && (n.memoizedState = i),
        i
    }
    function $m(n) {
        var i = Xm(n).next.queue;
        Pa(n, i, {}, mn())
    }
    function ah() {
        return Gt(ja)
    }
    function Jm() {
        return yt().memoizedState
    }
    function jm() {
        return yt().memoizedState
    }
    function sS(n) {
        for (var i = n.return; i !== null; ) {
            switch (i.tag) {
            case 24:
            case 3:
                var a = mn();
                n = ir(a);
                var u = rr(i, n, a);
                u !== null && (gn(u, i, a),
                wa(u, i, a)),
                i = {
                    cache: kf()
                },
                n.payload = i;
                return
            }
            i = i.return
        }
    }
    function oS(n, i, a) {
        var u = mn();
        a = {
            lane: u,
            revertLane: 0,
            action: a,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        Cu(n) ? Zm(i, a) : (a = wf(n, i, a, u),
        a !== null && (gn(a, n, u),
        eg(a, i, u)))
    }
    function Wm(n, i, a) {
        var u = mn();
        Pa(n, i, a, u)
    }
    function Pa(n, i, a, u) {
        var h = {
            lane: u,
            revertLane: 0,
            action: a,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (Cu(n))
            Zm(i, h);
        else {
            var g = n.alternate;
            if (n.lanes === 0 && (g === null || g.lanes === 0) && (g = i.lastRenderedReducer,
            g !== null))
                try {
                    var S = i.lastRenderedState
                      , C = g(S, a);
                    if (h.hasEagerState = !0,
                    h.eagerState = C,
                    cn(C, S))
                        return au(n, i, h, 0),
                        Ze === null && ou(),
                        !1
                } catch {} finally {}
            if (a = wf(n, i, h, u),
            a !== null)
                return gn(a, n, u),
                eg(a, i, u),
                !0
        }
        return !1
    }
    function lh(n, i, a, u) {
        if (u = {
            lane: 2,
            revertLane: qh(),
            action: u,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        Cu(n)) {
            if (i)
                throw Error(s(479))
        } else
            i = wf(n, a, u, 2),
            i !== null && gn(i, n, 2)
    }
    function Cu(n) {
        var i = n.alternate;
        return n === Ce || i !== null && i === Ce
    }
    function Zm(n, i) {
        fo = vu = !0;
        var a = n.pending;
        a === null ? i.next = i : (i.next = a.next,
        a.next = i),
        n.pending = i
    }
    function eg(n, i, a) {
        if ((a & 4194048) !== 0) {
            var u = i.lanes;
            u &= n.pendingLanes,
            a |= u,
            i.lanes = a,
            ta(n, a)
        }
    }
    var Ru = {
        readContext: Gt,
        use: Tu,
        useCallback: ft,
        useContext: ft,
        useEffect: ft,
        useImperativeHandle: ft,
        useLayoutEffect: ft,
        useInsertionEffect: ft,
        useMemo: ft,
        useReducer: ft,
        useRef: ft,
        useState: ft,
        useDebugValue: ft,
        useDeferredValue: ft,
        useTransition: ft,
        useSyncExternalStore: ft,
        useId: ft,
        useHostTransitionStatus: ft,
        useFormState: ft,
        useActionState: ft,
        useOptimistic: ft,
        useMemoCache: ft,
        useCacheRefresh: ft
    }
      , tg = {
        readContext: Gt,
        use: Tu,
        useCallback: function(n, i) {
            return tn().memoizedState = [n, i === void 0 ? null : i],
            n
        },
        useContext: Gt,
        useEffect: Lm,
        useImperativeHandle: function(n, i, a) {
            a = a != null ? a.concat([n]) : null,
            Au(4194308, 4, Fm.bind(null, i, n), a)
        },
        useLayoutEffect: function(n, i) {
            return Au(4194308, 4, n, i)
        },
        useInsertionEffect: function(n, i) {
            Au(4, 2, n, i)
        },
        useMemo: function(n, i) {
            var a = tn();
            i = i === void 0 ? null : i;
            var u = n();
            if (ys) {
                ln(!0);
                try {
                    n()
                } finally {
                    ln(!1)
                }
            }
            return a.memoizedState = [u, i],
            u
        },
        useReducer: function(n, i, a) {
            var u = tn();
            if (a !== void 0) {
                var h = a(i);
                if (ys) {
                    ln(!0);
                    try {
                        a(i)
                    } finally {
                        ln(!1)
                    }
                }
            } else
                h = i;
            return u.memoizedState = u.baseState = h,
            n = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: n,
                lastRenderedState: h
            },
            u.queue = n,
            n = n.dispatch = oS.bind(null, Ce, n),
            [u.memoizedState, n]
        },
        useRef: function(n) {
            var i = tn();
            return n = {
                current: n
            },
            i.memoizedState = n
        },
        useState: function(n) {
            n = nh(n);
            var i = n.queue
              , a = Wm.bind(null, Ce, i);
            return i.dispatch = a,
            [n.memoizedState, a]
        },
        useDebugValue: rh,
        useDeferredValue: function(n, i) {
            var a = tn();
            return sh(a, n, i)
        },
        useTransition: function() {
            var n = nh(!1);
            return n = Qm.bind(null, Ce, n.queue, !0, !1),
            tn().memoizedState = n,
            [!1, n]
        },
        useSyncExternalStore: function(n, i, a) {
            var u = Ce
              , h = tn();
            if (qe) {
                if (a === void 0)
                    throw Error(s(407));
                a = a()
            } else {
                if (a = i(),
                Ze === null)
                    throw Error(s(349));
                (Ve & 124) !== 0 || Sm(u, i, a)
            }
            h.memoizedState = a;
            var g = {
                value: a,
                getSnapshot: i
            };
            return h.queue = g,
            Lm(Cm.bind(null, u, g, n), [n]),
            u.flags |= 2048,
            po(9, Su(), Am.bind(null, u, g, a, i), null),
            a
        },
        useId: function() {
            var n = tn()
              , i = Ze.identifierPrefix;
            if (qe) {
                var a = Ii
                  , u = Ri;
                a = (u & ~(1 << 32 - Ht(u) - 1)).toString(32) + a,
                i = "«" + i + "R" + a,
                a = _u++,
                0 < a && (i += "H" + a.toString(32)),
                i += "»"
            } else
                a = eS++,
                i = "«" + i + "r" + a.toString(32) + "»";
            return n.memoizedState = i
        },
        useHostTransitionStatus: ah,
        useFormState: Pm,
        useActionState: Pm,
        useOptimistic: function(n) {
            var i = tn();
            i.memoizedState = i.baseState = n;
            var a = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: null,
                lastRenderedState: null
            };
            return i.queue = a,
            i = lh.bind(null, Ce, !0, a),
            a.dispatch = i,
            [n, i]
        },
        useMemoCache: Zf,
        useCacheRefresh: function() {
            return tn().memoizedState = sS.bind(null, Ce)
        }
    }
      , ng = {
        readContext: Gt,
        use: Tu,
        useCallback: Gm,
        useContext: Gt,
        useEffect: Bm,
        useImperativeHandle: Hm,
        useInsertionEffect: qm,
        useLayoutEffect: zm,
        useMemo: Ym,
        useReducer: Eu,
        useRef: km,
        useState: function() {
            return Eu(Di)
        },
        useDebugValue: rh,
        useDeferredValue: function(n, i) {
            var a = yt();
            return Km(a, Ke.memoizedState, n, i)
        },
        useTransition: function() {
            var n = Eu(Di)[0]
              , i = yt().memoizedState;
            return [typeof n == "boolean" ? n : Na(n), i]
        },
        useSyncExternalStore: Em,
        useId: Jm,
        useHostTransitionStatus: ah,
        useFormState: Om,
        useActionState: Om,
        useOptimistic: function(n, i) {
            var a = yt();
            return wm(a, Ke, n, i)
        },
        useMemoCache: Zf,
        useCacheRefresh: jm
    }
      , aS = {
        readContext: Gt,
        use: Tu,
        useCallback: Gm,
        useContext: Gt,
        useEffect: Bm,
        useImperativeHandle: Hm,
        useInsertionEffect: qm,
        useLayoutEffect: zm,
        useMemo: Ym,
        useReducer: th,
        useRef: km,
        useState: function() {
            return th(Di)
        },
        useDebugValue: rh,
        useDeferredValue: function(n, i) {
            var a = yt();
            return Ke === null ? sh(a, n, i) : Km(a, Ke.memoizedState, n, i)
        },
        useTransition: function() {
            var n = th(Di)[0]
              , i = yt().memoizedState;
            return [typeof n == "boolean" ? n : Na(n), i]
        },
        useSyncExternalStore: Em,
        useId: Jm,
        useHostTransitionStatus: ah,
        useFormState: Um,
        useActionState: Um,
        useOptimistic: function(n, i) {
            var a = yt();
            return Ke !== null ? wm(a, Ke, n, i) : (a.baseState = n,
            [n, a.queue.dispatch])
        },
        useMemoCache: Zf,
        useCacheRefresh: jm
    }
      , mo = null
      , Oa = 0;
    function Iu(n) {
        var i = Oa;
        return Oa += 1,
        mo === null && (mo = []),
        dm(mo, n, i)
    }
    function Va(n, i) {
        i = i.props.ref,
        n.ref = i !== void 0 ? i : null
    }
    function wu(n, i) {
        throw i.$$typeof === A ? Error(s(525)) : (n = Object.prototype.toString.call(i),
        Error(s(31, n === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : n)))
    }
    function ig(n) {
        var i = n._init;
        return i(n._payload)
    }
    function rg(n) {
        function i(L, O) {
            if (n) {
                var F = L.deletions;
                F === null ? (L.deletions = [O],
                L.flags |= 16) : F.push(O)
            }
        }
        function a(L, O) {
            if (!n)
                return null;
            for (; O !== null; )
                i(L, O),
                O = O.sibling;
            return null
        }
        function u(L) {
            for (var O = new Map; L !== null; )
                L.key !== null ? O.set(L.key, L) : O.set(L.index, L),
                L = L.sibling;
            return O
        }
        function h(L, O) {
            return L = Ci(L, O),
            L.index = 0,
            L.sibling = null,
            L
        }
        function g(L, O, F) {
            return L.index = F,
            n ? (F = L.alternate,
            F !== null ? (F = F.index,
            F < O ? (L.flags |= 67108866,
            O) : F) : (L.flags |= 67108866,
            O)) : (L.flags |= 1048576,
            O)
        }
        function S(L) {
            return n && L.alternate === null && (L.flags |= 67108866),
            L
        }
        function C(L, O, F, j) {
            return O === null || O.tag !== 6 ? (O = Df(F, L.mode, j),
            O.return = L,
            O) : (O = h(O, F),
            O.return = L,
            O)
        }
        function D(L, O, F, j) {
            var ce = F.type;
            return ce === q ? $(L, O, F.props.children, j, F.key) : O !== null && (O.elementType === ce || typeof ce == "object" && ce !== null && ce.$$typeof === w && ig(ce) === O.type) ? (O = h(O, F.props),
            Va(O, F),
            O.return = L,
            O) : (O = uu(F.type, F.key, F.props, null, L.mode, j),
            Va(O, F),
            O.return = L,
            O)
        }
        function H(L, O, F, j) {
            return O === null || O.tag !== 4 || O.stateNode.containerInfo !== F.containerInfo || O.stateNode.implementation !== F.implementation ? (O = Mf(F, L.mode, j),
            O.return = L,
            O) : (O = h(O, F.children || []),
            O.return = L,
            O)
        }
        function $(L, O, F, j, ce) {
            return O === null || O.tag !== 7 ? (O = us(F, L.mode, j, ce),
            O.return = L,
            O) : (O = h(O, F),
            O.return = L,
            O)
        }
        function W(L, O, F) {
            if (typeof O == "string" && O !== "" || typeof O == "number" || typeof O == "bigint")
                return O = Df("" + O, L.mode, F),
                O.return = L,
                O;
            if (typeof O == "object" && O !== null) {
                switch (O.$$typeof) {
                case I:
                    return F = uu(O.type, O.key, O.props, null, L.mode, F),
                    Va(F, O),
                    F.return = L,
                    F;
                case V:
                    return O = Mf(O, L.mode, F),
                    O.return = L,
                    O;
                case w:
                    var j = O._init;
                    return O = j(O._payload),
                    W(L, O, F)
                }
                if (je(O) || B(O))
                    return O = us(O, L.mode, F, null),
                    O.return = L,
                    O;
                if (typeof O.then == "function")
                    return W(L, Iu(O), F);
                if (O.$$typeof === le)
                    return W(L, du(L, O), F);
                wu(L, O)
            }
            return null
        }
        function Y(L, O, F, j) {
            var ce = O !== null ? O.key : null;
            if (typeof F == "string" && F !== "" || typeof F == "number" || typeof F == "bigint")
                return ce !== null ? null : C(L, O, "" + F, j);
            if (typeof F == "object" && F !== null) {
                switch (F.$$typeof) {
                case I:
                    return F.key === ce ? D(L, O, F, j) : null;
                case V:
                    return F.key === ce ? H(L, O, F, j) : null;
                case w:
                    return ce = F._init,
                    F = ce(F._payload),
                    Y(L, O, F, j)
                }
                if (je(F) || B(F))
                    return ce !== null ? null : $(L, O, F, j, null);
                if (typeof F.then == "function")
                    return Y(L, O, Iu(F), j);
                if (F.$$typeof === le)
                    return Y(L, O, du(L, F), j);
                wu(L, F)
            }
            return null
        }
        function K(L, O, F, j, ce) {
            if (typeof j == "string" && j !== "" || typeof j == "number" || typeof j == "bigint")
                return L = L.get(F) || null,
                C(O, L, "" + j, ce);
            if (typeof j == "object" && j !== null) {
                switch (j.$$typeof) {
                case I:
                    return L = L.get(j.key === null ? F : j.key) || null,
                    D(O, L, j, ce);
                case V:
                    return L = L.get(j.key === null ? F : j.key) || null,
                    H(O, L, j, ce);
                case w:
                    var be = j._init;
                    return j = be(j._payload),
                    K(L, O, F, j, ce)
                }
                if (je(j) || B(j))
                    return L = L.get(F) || null,
                    $(O, L, j, ce, null);
                if (typeof j.then == "function")
                    return K(L, O, F, Iu(j), ce);
                if (j.$$typeof === le)
                    return K(L, O, F, du(O, j), ce);
                wu(O, j)
            }
            return null
        }
        function _e(L, O, F, j) {
            for (var ce = null, be = null, de = O, ye = O = 0, Mt = null; de !== null && ye < F.length; ye++) {
                de.index > ye ? (Mt = de,
                de = null) : Mt = de.sibling;
                var Le = Y(L, de, F[ye], j);
                if (Le === null) {
                    de === null && (de = Mt);
                    break
                }
                n && de && Le.alternate === null && i(L, de),
                O = g(Le, O, ye),
                be === null ? ce = Le : be.sibling = Le,
                be = Le,
                de = Mt
            }
            if (ye === F.length)
                return a(L, de),
                qe && fs(L, ye),
                ce;
            if (de === null) {
                for (; ye < F.length; ye++)
                    de = W(L, F[ye], j),
                    de !== null && (O = g(de, O, ye),
                    be === null ? ce = de : be.sibling = de,
                    be = de);
                return qe && fs(L, ye),
                ce
            }
            for (de = u(de); ye < F.length; ye++)
                Mt = K(de, L, ye, F[ye], j),
                Mt !== null && (n && Mt.alternate !== null && de.delete(Mt.key === null ? ye : Mt.key),
                O = g(Mt, O, ye),
                be === null ? ce = Mt : be.sibling = Mt,
                be = Mt);
            return n && de.forEach(function(Er) {
                return i(L, Er)
            }),
            qe && fs(L, ye),
            ce
        }
        function ge(L, O, F, j) {
            if (F == null)
                throw Error(s(151));
            for (var ce = null, be = null, de = O, ye = O = 0, Mt = null, Le = F.next(); de !== null && !Le.done; ye++,
            Le = F.next()) {
                de.index > ye ? (Mt = de,
                de = null) : Mt = de.sibling;
                var Er = Y(L, de, Le.value, j);
                if (Er === null) {
                    de === null && (de = Mt);
                    break
                }
                n && de && Er.alternate === null && i(L, de),
                O = g(Er, O, ye),
                be === null ? ce = Er : be.sibling = Er,
                be = Er,
                de = Mt
            }
            if (Le.done)
                return a(L, de),
                qe && fs(L, ye),
                ce;
            if (de === null) {
                for (; !Le.done; ye++,
                Le = F.next())
                    Le = W(L, Le.value, j),
                    Le !== null && (O = g(Le, O, ye),
                    be === null ? ce = Le : be.sibling = Le,
                    be = Le);
                return qe && fs(L, ye),
                ce
            }
            for (de = u(de); !Le.done; ye++,
            Le = F.next())
                Le = K(de, L, ye, Le.value, j),
                Le !== null && (n && Le.alternate !== null && de.delete(Le.key === null ? ye : Le.key),
                O = g(Le, O, ye),
                be === null ? ce = Le : be.sibling = Le,
                be = Le);
            return n && de.forEach(function(lA) {
                return i(L, lA)
            }),
            qe && fs(L, ye),
            ce
        }
        function Xe(L, O, F, j) {
            if (typeof F == "object" && F !== null && F.type === q && F.key === null && (F = F.props.children),
            typeof F == "object" && F !== null) {
                switch (F.$$typeof) {
                case I:
                    e: {
                        for (var ce = F.key; O !== null; ) {
                            if (O.key === ce) {
                                if (ce = F.type,
                                ce === q) {
                                    if (O.tag === 7) {
                                        a(L, O.sibling),
                                        j = h(O, F.props.children),
                                        j.return = L,
                                        L = j;
                                        break e
                                    }
                                } else if (O.elementType === ce || typeof ce == "object" && ce !== null && ce.$$typeof === w && ig(ce) === O.type) {
                                    a(L, O.sibling),
                                    j = h(O, F.props),
                                    Va(j, F),
                                    j.return = L,
                                    L = j;
                                    break e
                                }
                                a(L, O);
                                break
                            } else
                                i(L, O);
                            O = O.sibling
                        }
                        F.type === q ? (j = us(F.props.children, L.mode, j, F.key),
                        j.return = L,
                        L = j) : (j = uu(F.type, F.key, F.props, null, L.mode, j),
                        Va(j, F),
                        j.return = L,
                        L = j)
                    }
                    return S(L);
                case V:
                    e: {
                        for (ce = F.key; O !== null; ) {
                            if (O.key === ce)
                                if (O.tag === 4 && O.stateNode.containerInfo === F.containerInfo && O.stateNode.implementation === F.implementation) {
                                    a(L, O.sibling),
                                    j = h(O, F.children || []),
                                    j.return = L,
                                    L = j;
                                    break e
                                } else {
                                    a(L, O);
                                    break
                                }
                            else
                                i(L, O);
                            O = O.sibling
                        }
                        j = Mf(F, L.mode, j),
                        j.return = L,
                        L = j
                    }
                    return S(L);
                case w:
                    return ce = F._init,
                    F = ce(F._payload),
                    Xe(L, O, F, j)
                }
                if (je(F))
                    return _e(L, O, F, j);
                if (B(F)) {
                    if (ce = B(F),
                    typeof ce != "function")
                        throw Error(s(150));
                    return F = ce.call(F),
                    ge(L, O, F, j)
                }
                if (typeof F.then == "function")
                    return Xe(L, O, Iu(F), j);
                if (F.$$typeof === le)
                    return Xe(L, O, du(L, F), j);
                wu(L, F)
            }
            return typeof F == "string" && F !== "" || typeof F == "number" || typeof F == "bigint" ? (F = "" + F,
            O !== null && O.tag === 6 ? (a(L, O.sibling),
            j = h(O, F),
            j.return = L,
            L = j) : (a(L, O),
            j = Df(F, L.mode, j),
            j.return = L,
            L = j),
            S(L)) : a(L, O)
        }
        return function(L, O, F, j) {
            try {
                Oa = 0;
                var ce = Xe(L, O, F, j);
                return mo = null,
                ce
            } catch (de) {
                if (de === Ra || de === mu)
                    throw de;
                var be = fn(29, de, null, L.mode);
                return be.lanes = j,
                be.return = L,
                be
            } finally {}
        }
    }
    var go = rg(!0)
      , sg = rg(!1)
      , Dn = ee(null)
      , ii = null;
    function or(n) {
        var i = n.alternate;
        ie(Ct, Ct.current & 1),
        ie(Dn, n),
        ii === null && (i === null || co.current !== null || i.memoizedState !== null) && (ii = n)
    }
    function og(n) {
        if (n.tag === 22) {
            if (ie(Ct, Ct.current),
            ie(Dn, n),
            ii === null) {
                var i = n.alternate;
                i !== null && i.memoizedState !== null && (ii = n)
            }
        } else
            ar()
    }
    function ar() {
        ie(Ct, Ct.current),
        ie(Dn, Dn.current)
    }
    function Mi(n) {
        ae(Dn),
        ii === n && (ii = null),
        ae(Ct)
    }
    var Ct = ee(0);
    function bu(n) {
        for (var i = n; i !== null; ) {
            if (i.tag === 13) {
                var a = i.memoizedState;
                if (a !== null && (a = a.dehydrated,
                a === null || a.data === "$?" || Wh(a)))
                    return i
            } else if (i.tag === 19 && i.memoizedProps.revealOrder !== void 0) {
                if ((i.flags & 128) !== 0)
                    return i
            } else if (i.child !== null) {
                i.child.return = i,
                i = i.child;
                continue
            }
            if (i === n)
                break;
            for (; i.sibling === null; ) {
                if (i.return === null || i.return === n)
                    return null;
                i = i.return
            }
            i.sibling.return = i.return,
            i = i.sibling
        }
        return null
    }
    function uh(n, i, a, u) {
        i = n.memoizedState,
        a = a(u, i),
        a = a == null ? i : T({}, i, a),
        n.memoizedState = a,
        n.lanes === 0 && (n.updateQueue.baseState = a)
    }
    var ch = {
        enqueueSetState: function(n, i, a) {
            n = n._reactInternals;
            var u = mn()
              , h = ir(u);
            h.payload = i,
            a != null && (h.callback = a),
            i = rr(n, h, u),
            i !== null && (gn(i, n, u),
            wa(i, n, u))
        },
        enqueueReplaceState: function(n, i, a) {
            n = n._reactInternals;
            var u = mn()
              , h = ir(u);
            h.tag = 1,
            h.payload = i,
            a != null && (h.callback = a),
            i = rr(n, h, u),
            i !== null && (gn(i, n, u),
            wa(i, n, u))
        },
        enqueueForceUpdate: function(n, i) {
            n = n._reactInternals;
            var a = mn()
              , u = ir(a);
            u.tag = 2,
            i != null && (u.callback = i),
            i = rr(n, u, a),
            i !== null && (gn(i, n, a),
            wa(i, n, a))
        }
    };
    function ag(n, i, a, u, h, g, S) {
        return n = n.stateNode,
        typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(u, g, S) : i.prototype && i.prototype.isPureReactComponent ? !ya(a, u) || !ya(h, g) : !0
    }
    function lg(n, i, a, u) {
        n = i.state,
        typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(a, u),
        typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(a, u),
        i.state !== n && ch.enqueueReplaceState(i, i.state, null)
    }
    function vs(n, i) {
        var a = i;
        if ("ref"in i) {
            a = {};
            for (var u in i)
                u !== "ref" && (a[u] = i[u])
        }
        if (n = n.defaultProps) {
            a === i && (a = T({}, a));
            for (var h in n)
                a[h] === void 0 && (a[h] = n[h])
        }
        return a
    }
    var Du = typeof reportError == "function" ? reportError : function(n) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var i = new window.ErrorEvent("error",{
                bubbles: !0,
                cancelable: !0,
                message: typeof n == "object" && n !== null && typeof n.message == "string" ? String(n.message) : String(n),
                error: n
            });
            if (!window.dispatchEvent(i))
                return
        } else if (typeof process == "object" && typeof process.emit == "function") {
            process.emit("uncaughtException", n);
            return
        }
        console.error(n)
    }
    ;
    function ug(n) {
        Du(n)
    }
    function cg(n) {
        console.error(n)
    }
    function fg(n) {
        Du(n)
    }
    function Mu(n, i) {
        try {
            var a = n.onUncaughtError;
            a(i.value, {
                componentStack: i.stack
            })
        } catch (u) {
            setTimeout(function() {
                throw u
            })
        }
    }
    function hg(n, i, a) {
        try {
            var u = n.onCaughtError;
            u(a.value, {
                componentStack: a.stack,
                errorBoundary: i.tag === 1 ? i.stateNode : null
            })
        } catch (h) {
            setTimeout(function() {
                throw h
            })
        }
    }
    function fh(n, i, a) {
        return a = ir(a),
        a.tag = 3,
        a.payload = {
            element: null
        },
        a.callback = function() {
            Mu(n, i)
        }
        ,
        a
    }
    function dg(n) {
        return n = ir(n),
        n.tag = 3,
        n
    }
    function pg(n, i, a, u) {
        var h = a.type.getDerivedStateFromError;
        if (typeof h == "function") {
            var g = u.value;
            n.payload = function() {
                return h(g)
            }
            ,
            n.callback = function() {
                hg(i, a, u)
            }
        }
        var S = a.stateNode;
        S !== null && typeof S.componentDidCatch == "function" && (n.callback = function() {
            hg(i, a, u),
            typeof h != "function" && (dr === null ? dr = new Set([this]) : dr.add(this));
            var C = u.stack;
            this.componentDidCatch(u.value, {
                componentStack: C !== null ? C : ""
            })
        }
        )
    }
    function lS(n, i, a, u, h) {
        if (a.flags |= 32768,
        u !== null && typeof u == "object" && typeof u.then == "function") {
            if (i = a.alternate,
            i !== null && Sa(i, a, h, !0),
            a = Dn.current,
            a !== null) {
                switch (a.tag) {
                case 13:
                    return ii === null ? Vh() : a.alternate === null && at === 0 && (at = 3),
                    a.flags &= -257,
                    a.flags |= 65536,
                    a.lanes = h,
                    u === qf ? a.flags |= 16384 : (i = a.updateQueue,
                    i === null ? a.updateQueue = new Set([u]) : i.add(u),
                    kh(n, u, h)),
                    !1;
                case 22:
                    return a.flags |= 65536,
                    u === qf ? a.flags |= 16384 : (i = a.updateQueue,
                    i === null ? (i = {
                        transitions: null,
                        markerInstances: null,
                        retryQueue: new Set([u])
                    },
                    a.updateQueue = i) : (a = i.retryQueue,
                    a === null ? i.retryQueue = new Set([u]) : a.add(u)),
                    kh(n, u, h)),
                    !1
                }
                throw Error(s(435, a.tag))
            }
            return kh(n, u, h),
            Vh(),
            !1
        }
        if (qe)
            return i = Dn.current,
            i !== null ? ((i.flags & 65536) === 0 && (i.flags |= 256),
            i.flags |= 65536,
            i.lanes = h,
            u !== Pf && (n = Error(s(422), {
                cause: u
            }),
            Ea(Rn(n, a)))) : (u !== Pf && (i = Error(s(423), {
                cause: u
            }),
            Ea(Rn(i, a))),
            n = n.current.alternate,
            n.flags |= 65536,
            h &= -h,
            n.lanes |= h,
            u = Rn(u, a),
            h = fh(n.stateNode, u, h),
            Hf(n, h),
            at !== 4 && (at = 2)),
            !1;
        var g = Error(s(520), {
            cause: u
        });
        if (g = Rn(g, a),
        Fa === null ? Fa = [g] : Fa.push(g),
        at !== 4 && (at = 2),
        i === null)
            return !0;
        u = Rn(u, a),
        a = i;
        do {
            switch (a.tag) {
            case 3:
                return a.flags |= 65536,
                n = h & -h,
                a.lanes |= n,
                n = fh(a.stateNode, u, n),
                Hf(a, n),
                !1;
            case 1:
                if (i = a.type,
                g = a.stateNode,
                (a.flags & 128) === 0 && (typeof i.getDerivedStateFromError == "function" || g !== null && typeof g.componentDidCatch == "function" && (dr === null || !dr.has(g))))
                    return a.flags |= 65536,
                    h &= -h,
                    a.lanes |= h,
                    h = dg(h),
                    pg(h, n, a, u),
                    Hf(a, h),
                    !1
            }
            a = a.return
        } while (a !== null);
        return !1
    }
    var mg = Error(s(461))
      , bt = !1;
    function Ut(n, i, a, u) {
        i.child = n === null ? sg(i, null, a, u) : go(i, n.child, a, u)
    }
    function gg(n, i, a, u, h) {
        a = a.render;
        var g = i.ref;
        if ("ref"in u) {
            var S = {};
            for (var C in u)
                C !== "ref" && (S[C] = u[C])
        } else
            S = u;
        return ms(i),
        u = Xf(n, i, a, S, g, h),
        C = $f(),
        n !== null && !bt ? (Jf(n, i, h),
        Ni(n, i, h)) : (qe && C && Nf(i),
        i.flags |= 1,
        Ut(n, i, u, h),
        i.child)
    }
    function yg(n, i, a, u, h) {
        if (n === null) {
            var g = a.type;
            return typeof g == "function" && !bf(g) && g.defaultProps === void 0 && a.compare === null ? (i.tag = 15,
            i.type = g,
            vg(n, i, g, u, h)) : (n = uu(a.type, null, u, i, i.mode, h),
            n.ref = i.ref,
            n.return = i,
            i.child = n)
        }
        if (g = n.child,
        !_h(n, h)) {
            var S = g.memoizedProps;
            if (a = a.compare,
            a = a !== null ? a : ya,
            a(S, u) && n.ref === i.ref)
                return Ni(n, i, h)
        }
        return i.flags |= 1,
        n = Ci(g, u),
        n.ref = i.ref,
        n.return = i,
        i.child = n
    }
    function vg(n, i, a, u, h) {
        if (n !== null) {
            var g = n.memoizedProps;
            if (ya(g, u) && n.ref === i.ref)
                if (bt = !1,
                i.pendingProps = u = g,
                _h(n, h))
                    (n.flags & 131072) !== 0 && (bt = !0);
                else
                    return i.lanes = n.lanes,
                    Ni(n, i, h)
        }
        return hh(n, i, a, u, h)
    }
    function _g(n, i, a) {
        var u = i.pendingProps
          , h = u.children
          , g = n !== null ? n.memoizedState : null;
        if (u.mode === "hidden") {
            if ((i.flags & 128) !== 0) {
                if (u = g !== null ? g.baseLanes | a : a,
                n !== null) {
                    for (h = i.child = n.child,
                    g = 0; h !== null; )
                        g = g | h.lanes | h.childLanes,
                        h = h.sibling;
                    i.childLanes = g & ~u
                } else
                    i.childLanes = 0,
                    i.child = null;
                return Tg(n, i, u, a)
            }
            if ((a & 536870912) !== 0)
                i.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                n !== null && pu(i, g !== null ? g.cachePool : null),
                g !== null ? vm(i, g) : Yf(),
                og(i);
            else
                return i.lanes = i.childLanes = 536870912,
                Tg(n, i, g !== null ? g.baseLanes | a : a, a)
        } else
            g !== null ? (pu(i, g.cachePool),
            vm(i, g),
            ar(),
            i.memoizedState = null) : (n !== null && pu(i, null),
            Yf(),
            ar());
        return Ut(n, i, h, a),
        i.child
    }
    function Tg(n, i, a, u) {
        var h = Bf();
        return h = h === null ? null : {
            parent: At._currentValue,
            pool: h
        },
        i.memoizedState = {
            baseLanes: a,
            cachePool: h
        },
        n !== null && pu(i, null),
        Yf(),
        og(i),
        n !== null && Sa(n, i, u, !0),
        null
    }
    function Nu(n, i) {
        var a = i.ref;
        if (a === null)
            n !== null && n.ref !== null && (i.flags |= 4194816);
        else {
            if (typeof a != "function" && typeof a != "object")
                throw Error(s(284));
            (n === null || n.ref !== a) && (i.flags |= 4194816)
        }
    }
    function hh(n, i, a, u, h) {
        return ms(i),
        a = Xf(n, i, a, u, void 0, h),
        u = $f(),
        n !== null && !bt ? (Jf(n, i, h),
        Ni(n, i, h)) : (qe && u && Nf(i),
        i.flags |= 1,
        Ut(n, i, a, h),
        i.child)
    }
    function Eg(n, i, a, u, h, g) {
        return ms(i),
        i.updateQueue = null,
        a = Tm(i, u, a, h),
        _m(n),
        u = $f(),
        n !== null && !bt ? (Jf(n, i, g),
        Ni(n, i, g)) : (qe && u && Nf(i),
        i.flags |= 1,
        Ut(n, i, a, g),
        i.child)
    }
    function Sg(n, i, a, u, h) {
        if (ms(i),
        i.stateNode === null) {
            var g = so
              , S = a.contextType;
            typeof S == "object" && S !== null && (g = Gt(S)),
            g = new a(u,g),
            i.memoizedState = g.state !== null && g.state !== void 0 ? g.state : null,
            g.updater = ch,
            i.stateNode = g,
            g._reactInternals = i,
            g = i.stateNode,
            g.props = u,
            g.state = i.memoizedState,
            g.refs = {},
            zf(i),
            S = a.contextType,
            g.context = typeof S == "object" && S !== null ? Gt(S) : so,
            g.state = i.memoizedState,
            S = a.getDerivedStateFromProps,
            typeof S == "function" && (uh(i, a, S, u),
            g.state = i.memoizedState),
            typeof a.getDerivedStateFromProps == "function" || typeof g.getSnapshotBeforeUpdate == "function" || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (S = g.state,
            typeof g.componentWillMount == "function" && g.componentWillMount(),
            typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount(),
            S !== g.state && ch.enqueueReplaceState(g, g.state, null),
            Da(i, u, g, h),
            ba(),
            g.state = i.memoizedState),
            typeof g.componentDidMount == "function" && (i.flags |= 4194308),
            u = !0
        } else if (n === null) {
            g = i.stateNode;
            var C = i.memoizedProps
              , D = vs(a, C);
            g.props = D;
            var H = g.context
              , $ = a.contextType;
            S = so,
            typeof $ == "object" && $ !== null && (S = Gt($));
            var W = a.getDerivedStateFromProps;
            $ = typeof W == "function" || typeof g.getSnapshotBeforeUpdate == "function",
            C = i.pendingProps !== C,
            $ || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (C || H !== S) && lg(i, g, u, S),
            nr = !1;
            var Y = i.memoizedState;
            g.state = Y,
            Da(i, u, g, h),
            ba(),
            H = i.memoizedState,
            C || Y !== H || nr ? (typeof W == "function" && (uh(i, a, W, u),
            H = i.memoizedState),
            (D = nr || ag(i, a, D, u, Y, H, S)) ? ($ || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (typeof g.componentWillMount == "function" && g.componentWillMount(),
            typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount()),
            typeof g.componentDidMount == "function" && (i.flags |= 4194308)) : (typeof g.componentDidMount == "function" && (i.flags |= 4194308),
            i.memoizedProps = u,
            i.memoizedState = H),
            g.props = u,
            g.state = H,
            g.context = S,
            u = D) : (typeof g.componentDidMount == "function" && (i.flags |= 4194308),
            u = !1)
        } else {
            g = i.stateNode,
            Ff(n, i),
            S = i.memoizedProps,
            $ = vs(a, S),
            g.props = $,
            W = i.pendingProps,
            Y = g.context,
            H = a.contextType,
            D = so,
            typeof H == "object" && H !== null && (D = Gt(H)),
            C = a.getDerivedStateFromProps,
            (H = typeof C == "function" || typeof g.getSnapshotBeforeUpdate == "function") || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (S !== W || Y !== D) && lg(i, g, u, D),
            nr = !1,
            Y = i.memoizedState,
            g.state = Y,
            Da(i, u, g, h),
            ba();
            var K = i.memoizedState;
            S !== W || Y !== K || nr || n !== null && n.dependencies !== null && hu(n.dependencies) ? (typeof C == "function" && (uh(i, a, C, u),
            K = i.memoizedState),
            ($ = nr || ag(i, a, $, u, Y, K, D) || n !== null && n.dependencies !== null && hu(n.dependencies)) ? (H || typeof g.UNSAFE_componentWillUpdate != "function" && typeof g.componentWillUpdate != "function" || (typeof g.componentWillUpdate == "function" && g.componentWillUpdate(u, K, D),
            typeof g.UNSAFE_componentWillUpdate == "function" && g.UNSAFE_componentWillUpdate(u, K, D)),
            typeof g.componentDidUpdate == "function" && (i.flags |= 4),
            typeof g.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof g.componentDidUpdate != "function" || S === n.memoizedProps && Y === n.memoizedState || (i.flags |= 4),
            typeof g.getSnapshotBeforeUpdate != "function" || S === n.memoizedProps && Y === n.memoizedState || (i.flags |= 1024),
            i.memoizedProps = u,
            i.memoizedState = K),
            g.props = u,
            g.state = K,
            g.context = D,
            u = $) : (typeof g.componentDidUpdate != "function" || S === n.memoizedProps && Y === n.memoizedState || (i.flags |= 4),
            typeof g.getSnapshotBeforeUpdate != "function" || S === n.memoizedProps && Y === n.memoizedState || (i.flags |= 1024),
            u = !1)
        }
        return g = u,
        Nu(n, i),
        u = (i.flags & 128) !== 0,
        g || u ? (g = i.stateNode,
        a = u && typeof a.getDerivedStateFromError != "function" ? null : g.render(),
        i.flags |= 1,
        n !== null && u ? (i.child = go(i, n.child, null, h),
        i.child = go(i, null, a, h)) : Ut(n, i, a, h),
        i.memoizedState = g.state,
        n = i.child) : n = Ni(n, i, h),
        n
    }
    function Ag(n, i, a, u) {
        return Ta(),
        i.flags |= 256,
        Ut(n, i, a, u),
        i.child
    }
    var dh = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
    };
    function ph(n) {
        return {
            baseLanes: n,
            cachePool: cm()
        }
    }
    function mh(n, i, a) {
        return n = n !== null ? n.childLanes & ~a : 0,
        i && (n |= Mn),
        n
    }
    function Cg(n, i, a) {
        var u = i.pendingProps, h = !1, g = (i.flags & 128) !== 0, S;
        if ((S = g) || (S = n !== null && n.memoizedState === null ? !1 : (Ct.current & 2) !== 0),
        S && (h = !0,
        i.flags &= -129),
        S = (i.flags & 32) !== 0,
        i.flags &= -33,
        n === null) {
            if (qe) {
                if (h ? or(i) : ar(),
                qe) {
                    var C = ot, D;
                    if (D = C) {
                        e: {
                            for (D = C,
                            C = ni; D.nodeType !== 8; ) {
                                if (!C) {
                                    C = null;
                                    break e
                                }
                                if (D = Ln(D.nextSibling),
                                D === null) {
                                    C = null;
                                    break e
                                }
                            }
                            C = D
                        }
                        C !== null ? (i.memoizedState = {
                            dehydrated: C,
                            treeContext: cs !== null ? {
                                id: Ri,
                                overflow: Ii
                            } : null,
                            retryLane: 536870912,
                            hydrationErrors: null
                        },
                        D = fn(18, null, null, 0),
                        D.stateNode = C,
                        D.return = i,
                        i.child = D,
                        en = i,
                        ot = null,
                        D = !0) : D = !1
                    }
                    D || ds(i)
                }
                if (C = i.memoizedState,
                C !== null && (C = C.dehydrated,
                C !== null))
                    return Wh(C) ? i.lanes = 32 : i.lanes = 536870912,
                    null;
                Mi(i)
            }
            return C = u.children,
            u = u.fallback,
            h ? (ar(),
            h = i.mode,
            C = xu({
                mode: "hidden",
                children: C
            }, h),
            u = us(u, h, a, null),
            C.return = i,
            u.return = i,
            C.sibling = u,
            i.child = C,
            h = i.child,
            h.memoizedState = ph(a),
            h.childLanes = mh(n, S, a),
            i.memoizedState = dh,
            u) : (or(i),
            gh(i, C))
        }
        if (D = n.memoizedState,
        D !== null && (C = D.dehydrated,
        C !== null)) {
            if (g)
                i.flags & 256 ? (or(i),
                i.flags &= -257,
                i = yh(n, i, a)) : i.memoizedState !== null ? (ar(),
                i.child = n.child,
                i.flags |= 128,
                i = null) : (ar(),
                h = u.fallback,
                C = i.mode,
                u = xu({
                    mode: "visible",
                    children: u.children
                }, C),
                h = us(h, C, a, null),
                h.flags |= 2,
                u.return = i,
                h.return = i,
                u.sibling = h,
                i.child = u,
                go(i, n.child, null, a),
                u = i.child,
                u.memoizedState = ph(a),
                u.childLanes = mh(n, S, a),
                i.memoizedState = dh,
                i = h);
            else if (or(i),
            Wh(C)) {
                if (S = C.nextSibling && C.nextSibling.dataset,
                S)
                    var H = S.dgst;
                S = H,
                u = Error(s(419)),
                u.stack = "",
                u.digest = S,
                Ea({
                    value: u,
                    source: null,
                    stack: null
                }),
                i = yh(n, i, a)
            } else if (bt || Sa(n, i, a, !1),
            S = (a & n.childLanes) !== 0,
            bt || S) {
                if (S = Ze,
                S !== null && (u = a & -a,
                u = (u & 42) !== 0 ? 1 : Xi(u),
                u = (u & (S.suspendedLanes | a)) !== 0 ? 0 : u,
                u !== 0 && u !== D.retryLane))
                    throw D.retryLane = u,
                    ro(n, u),
                    gn(S, n, u),
                    mg;
                C.data === "$?" || Vh(),
                i = yh(n, i, a)
            } else
                C.data === "$?" ? (i.flags |= 192,
                i.child = n.child,
                i = null) : (n = D.treeContext,
                ot = Ln(C.nextSibling),
                en = i,
                qe = !0,
                hs = null,
                ni = !1,
                n !== null && (wn[bn++] = Ri,
                wn[bn++] = Ii,
                wn[bn++] = cs,
                Ri = n.id,
                Ii = n.overflow,
                cs = i),
                i = gh(i, u.children),
                i.flags |= 4096);
            return i
        }
        return h ? (ar(),
        h = u.fallback,
        C = i.mode,
        D = n.child,
        H = D.sibling,
        u = Ci(D, {
            mode: "hidden",
            children: u.children
        }),
        u.subtreeFlags = D.subtreeFlags & 65011712,
        H !== null ? h = Ci(H, h) : (h = us(h, C, a, null),
        h.flags |= 2),
        h.return = i,
        u.return = i,
        u.sibling = h,
        i.child = u,
        u = h,
        h = i.child,
        C = n.child.memoizedState,
        C === null ? C = ph(a) : (D = C.cachePool,
        D !== null ? (H = At._currentValue,
        D = D.parent !== H ? {
            parent: H,
            pool: H
        } : D) : D = cm(),
        C = {
            baseLanes: C.baseLanes | a,
            cachePool: D
        }),
        h.memoizedState = C,
        h.childLanes = mh(n, S, a),
        i.memoizedState = dh,
        u) : (or(i),
        a = n.child,
        n = a.sibling,
        a = Ci(a, {
            mode: "visible",
            children: u.children
        }),
        a.return = i,
        a.sibling = null,
        n !== null && (S = i.deletions,
        S === null ? (i.deletions = [n],
        i.flags |= 16) : S.push(n)),
        i.child = a,
        i.memoizedState = null,
        a)
    }
    function gh(n, i) {
        return i = xu({
            mode: "visible",
            children: i
        }, n.mode),
        i.return = n,
        n.child = i
    }
    function xu(n, i) {
        return n = fn(22, n, null, i),
        n.lanes = 0,
        n.stateNode = {
            _visibility: 1,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
        },
        n
    }
    function yh(n, i, a) {
        return go(i, n.child, null, a),
        n = gh(i, i.pendingProps.children),
        n.flags |= 2,
        i.memoizedState = null,
        n
    }
    function Rg(n, i, a) {
        n.lanes |= i;
        var u = n.alternate;
        u !== null && (u.lanes |= i),
        Vf(n.return, i, a)
    }
    function vh(n, i, a, u, h) {
        var g = n.memoizedState;
        g === null ? n.memoizedState = {
            isBackwards: i,
            rendering: null,
            renderingStartTime: 0,
            last: u,
            tail: a,
            tailMode: h
        } : (g.isBackwards = i,
        g.rendering = null,
        g.renderingStartTime = 0,
        g.last = u,
        g.tail = a,
        g.tailMode = h)
    }
    function Ig(n, i, a) {
        var u = i.pendingProps
          , h = u.revealOrder
          , g = u.tail;
        if (Ut(n, i, u.children, a),
        u = Ct.current,
        (u & 2) !== 0)
            u = u & 1 | 2,
            i.flags |= 128;
        else {
            if (n !== null && (n.flags & 128) !== 0)
                e: for (n = i.child; n !== null; ) {
                    if (n.tag === 13)
                        n.memoizedState !== null && Rg(n, a, i);
                    else if (n.tag === 19)
                        Rg(n, a, i);
                    else if (n.child !== null) {
                        n.child.return = n,
                        n = n.child;
                        continue
                    }
                    if (n === i)
                        break e;
                    for (; n.sibling === null; ) {
                        if (n.return === null || n.return === i)
                            break e;
                        n = n.return
                    }
                    n.sibling.return = n.return,
                    n = n.sibling
                }
            u &= 1
        }
        switch (ie(Ct, u),
        h) {
        case "forwards":
            for (a = i.child,
            h = null; a !== null; )
                n = a.alternate,
                n !== null && bu(n) === null && (h = a),
                a = a.sibling;
            a = h,
            a === null ? (h = i.child,
            i.child = null) : (h = a.sibling,
            a.sibling = null),
            vh(i, !1, h, a, g);
            break;
        case "backwards":
            for (a = null,
            h = i.child,
            i.child = null; h !== null; ) {
                if (n = h.alternate,
                n !== null && bu(n) === null) {
                    i.child = h;
                    break
                }
                n = h.sibling,
                h.sibling = a,
                a = h,
                h = n
            }
            vh(i, !0, a, null, g);
            break;
        case "together":
            vh(i, !1, null, null, void 0);
            break;
        default:
            i.memoizedState = null
        }
        return i.child
    }
    function Ni(n, i, a) {
        if (n !== null && (i.dependencies = n.dependencies),
        hr |= i.lanes,
        (a & i.childLanes) === 0)
            if (n !== null) {
                if (Sa(n, i, a, !1),
                (a & i.childLanes) === 0)
                    return null
            } else
                return null;
        if (n !== null && i.child !== n.child)
            throw Error(s(153));
        if (i.child !== null) {
            for (n = i.child,
            a = Ci(n, n.pendingProps),
            i.child = a,
            a.return = i; n.sibling !== null; )
                n = n.sibling,
                a = a.sibling = Ci(n, n.pendingProps),
                a.return = i;
            a.sibling = null
        }
        return i.child
    }
    function _h(n, i) {
        return (n.lanes & i) !== 0 ? !0 : (n = n.dependencies,
        !!(n !== null && hu(n)))
    }
    function uS(n, i, a) {
        switch (i.tag) {
        case 3:
            We(i, i.stateNode.containerInfo),
            tr(i, At, n.memoizedState.cache),
            Ta();
            break;
        case 27:
        case 5:
            Qi(i);
            break;
        case 4:
            We(i, i.stateNode.containerInfo);
            break;
        case 10:
            tr(i, i.type, i.memoizedProps.value);
            break;
        case 13:
            var u = i.memoizedState;
            if (u !== null)
                return u.dehydrated !== null ? (or(i),
                i.flags |= 128,
                null) : (a & i.child.childLanes) !== 0 ? Cg(n, i, a) : (or(i),
                n = Ni(n, i, a),
                n !== null ? n.sibling : null);
            or(i);
            break;
        case 19:
            var h = (n.flags & 128) !== 0;
            if (u = (a & i.childLanes) !== 0,
            u || (Sa(n, i, a, !1),
            u = (a & i.childLanes) !== 0),
            h) {
                if (u)
                    return Ig(n, i, a);
                i.flags |= 128
            }
            if (h = i.memoizedState,
            h !== null && (h.rendering = null,
            h.tail = null,
            h.lastEffect = null),
            ie(Ct, Ct.current),
            u)
                break;
            return null;
        case 22:
        case 23:
            return i.lanes = 0,
            _g(n, i, a);
        case 24:
            tr(i, At, n.memoizedState.cache)
        }
        return Ni(n, i, a)
    }
    function wg(n, i, a) {
        if (n !== null)
            if (n.memoizedProps !== i.pendingProps)
                bt = !0;
            else {
                if (!_h(n, a) && (i.flags & 128) === 0)
                    return bt = !1,
                    uS(n, i, a);
                bt = (n.flags & 131072) !== 0
            }
        else
            bt = !1,
            qe && (i.flags & 1048576) !== 0 && im(i, fu, i.index);
        switch (i.lanes = 0,
        i.tag) {
        case 16:
            e: {
                n = i.pendingProps;
                var u = i.elementType
                  , h = u._init;
                if (u = h(u._payload),
                i.type = u,
                typeof u == "function")
                    bf(u) ? (n = vs(u, n),
                    i.tag = 1,
                    i = Sg(null, i, u, n, a)) : (i.tag = 0,
                    i = hh(null, i, u, n, a));
                else {
                    if (u != null) {
                        if (h = u.$$typeof,
                        h === ue) {
                            i.tag = 11,
                            i = gg(null, i, u, n, a);
                            break e
                        } else if (h === U) {
                            i.tag = 14,
                            i = yg(null, i, u, n, a);
                            break e
                        }
                    }
                    throw i = $e(u) || u,
                    Error(s(306, i, ""))
                }
            }
            return i;
        case 0:
            return hh(n, i, i.type, i.pendingProps, a);
        case 1:
            return u = i.type,
            h = vs(u, i.pendingProps),
            Sg(n, i, u, h, a);
        case 3:
            e: {
                if (We(i, i.stateNode.containerInfo),
                n === null)
                    throw Error(s(387));
                u = i.pendingProps;
                var g = i.memoizedState;
                h = g.element,
                Ff(n, i),
                Da(i, u, null, a);
                var S = i.memoizedState;
                if (u = S.cache,
                tr(i, At, u),
                u !== g.cache && Uf(i, [At], a, !0),
                ba(),
                u = S.element,
                g.isDehydrated)
                    if (g = {
                        element: u,
                        isDehydrated: !1,
                        cache: S.cache
                    },
                    i.updateQueue.baseState = g,
                    i.memoizedState = g,
                    i.flags & 256) {
                        i = Ag(n, i, u, a);
                        break e
                    } else if (u !== h) {
                        h = Rn(Error(s(424)), i),
                        Ea(h),
                        i = Ag(n, i, u, a);
                        break e
                    } else {
                        switch (n = i.stateNode.containerInfo,
                        n.nodeType) {
                        case 9:
                            n = n.body;
                            break;
                        default:
                            n = n.nodeName === "HTML" ? n.ownerDocument.body : n
                        }
                        for (ot = Ln(n.firstChild),
                        en = i,
                        qe = !0,
                        hs = null,
                        ni = !0,
                        a = sg(i, null, u, a),
                        i.child = a; a; )
                            a.flags = a.flags & -3 | 4096,
                            a = a.sibling
                    }
                else {
                    if (Ta(),
                    u === h) {
                        i = Ni(n, i, a);
                        break e
                    }
                    Ut(n, i, u, a)
                }
                i = i.child
            }
            return i;
        case 26:
            return Nu(n, i),
            n === null ? (a = Ny(i.type, null, i.pendingProps, null)) ? i.memoizedState = a : qe || (a = i.type,
            n = i.pendingProps,
            u = Ku(Te.current).createElement(a),
            u[Tt] = i,
            u[pt] = n,
            Lt(u, a, n),
            ct(u),
            i.stateNode = u) : i.memoizedState = Ny(i.type, n.memoizedProps, i.pendingProps, n.memoizedState),
            null;
        case 27:
            return Qi(i),
            n === null && qe && (u = i.stateNode = by(i.type, i.pendingProps, Te.current),
            en = i,
            ni = !0,
            h = ot,
            gr(i.type) ? (Zh = h,
            ot = Ln(u.firstChild)) : ot = h),
            Ut(n, i, i.pendingProps.children, a),
            Nu(n, i),
            n === null && (i.flags |= 4194304),
            i.child;
        case 5:
            return n === null && qe && ((h = u = ot) && (u = kS(u, i.type, i.pendingProps, ni),
            u !== null ? (i.stateNode = u,
            en = i,
            ot = Ln(u.firstChild),
            ni = !1,
            h = !0) : h = !1),
            h || ds(i)),
            Qi(i),
            h = i.type,
            g = i.pendingProps,
            S = n !== null ? n.memoizedProps : null,
            u = g.children,
            $h(h, g) ? u = null : S !== null && $h(h, S) && (i.flags |= 32),
            i.memoizedState !== null && (h = Xf(n, i, tS, null, null, a),
            ja._currentValue = h),
            Nu(n, i),
            Ut(n, i, u, a),
            i.child;
        case 6:
            return n === null && qe && ((n = a = ot) && (a = LS(a, i.pendingProps, ni),
            a !== null ? (i.stateNode = a,
            en = i,
            ot = null,
            n = !0) : n = !1),
            n || ds(i)),
            null;
        case 13:
            return Cg(n, i, a);
        case 4:
            return We(i, i.stateNode.containerInfo),
            u = i.pendingProps,
            n === null ? i.child = go(i, null, u, a) : Ut(n, i, u, a),
            i.child;
        case 11:
            return gg(n, i, i.type, i.pendingProps, a);
        case 7:
            return Ut(n, i, i.pendingProps, a),
            i.child;
        case 8:
            return Ut(n, i, i.pendingProps.children, a),
            i.child;
        case 12:
            return Ut(n, i, i.pendingProps.children, a),
            i.child;
        case 10:
            return u = i.pendingProps,
            tr(i, i.type, u.value),
            Ut(n, i, u.children, a),
            i.child;
        case 9:
            return h = i.type._context,
            u = i.pendingProps.children,
            ms(i),
            h = Gt(h),
            u = u(h),
            i.flags |= 1,
            Ut(n, i, u, a),
            i.child;
        case 14:
            return yg(n, i, i.type, i.pendingProps, a);
        case 15:
            return vg(n, i, i.type, i.pendingProps, a);
        case 19:
            return Ig(n, i, a);
        case 31:
            return u = i.pendingProps,
            a = i.mode,
            u = {
                mode: u.mode,
                children: u.children
            },
            n === null ? (a = xu(u, a),
            a.ref = i.ref,
            i.child = a,
            a.return = i,
            i = a) : (a = Ci(n.child, u),
            a.ref = i.ref,
            i.child = a,
            a.return = i,
            i = a),
            i;
        case 22:
            return _g(n, i, a);
        case 24:
            return ms(i),
            u = Gt(At),
            n === null ? (h = Bf(),
            h === null && (h = Ze,
            g = kf(),
            h.pooledCache = g,
            g.refCount++,
            g !== null && (h.pooledCacheLanes |= a),
            h = g),
            i.memoizedState = {
                parent: u,
                cache: h
            },
            zf(i),
            tr(i, At, h)) : ((n.lanes & a) !== 0 && (Ff(n, i),
            Da(i, null, null, a),
            ba()),
            h = n.memoizedState,
            g = i.memoizedState,
            h.parent !== u ? (h = {
                parent: u,
                cache: u
            },
            i.memoizedState = h,
            i.lanes === 0 && (i.memoizedState = i.updateQueue.baseState = h),
            tr(i, At, u)) : (u = g.cache,
            tr(i, At, u),
            u !== h.cache && Uf(i, [At], a, !0))),
            Ut(n, i, i.pendingProps.children, a),
            i.child;
        case 29:
            throw i.pendingProps
        }
        throw Error(s(156, i.tag))
    }
    function xi(n) {
        n.flags |= 4
    }
    function bg(n, i) {
        if (i.type !== "stylesheet" || (i.state.loading & 4) !== 0)
            n.flags &= -16777217;
        else if (n.flags |= 16777216,
        !Uy(i)) {
            if (i = Dn.current,
            i !== null && ((Ve & 4194048) === Ve ? ii !== null : (Ve & 62914560) !== Ve && (Ve & 536870912) === 0 || i !== ii))
                throw Ia = qf,
                fm;
            n.flags |= 8192
        }
    }
    function Pu(n, i) {
        i !== null && (n.flags |= 4),
        n.flags & 16384 && (i = n.tag !== 22 ? Zo() : 536870912,
        n.lanes |= i,
        To |= i)
    }
    function Ua(n, i) {
        if (!qe)
            switch (n.tailMode) {
            case "hidden":
                i = n.tail;
                for (var a = null; i !== null; )
                    i.alternate !== null && (a = i),
                    i = i.sibling;
                a === null ? n.tail = null : a.sibling = null;
                break;
            case "collapsed":
                a = n.tail;
                for (var u = null; a !== null; )
                    a.alternate !== null && (u = a),
                    a = a.sibling;
                u === null ? i || n.tail === null ? n.tail = null : n.tail.sibling = null : u.sibling = null
            }
    }
    function rt(n) {
        var i = n.alternate !== null && n.alternate.child === n.child
          , a = 0
          , u = 0;
        if (i)
            for (var h = n.child; h !== null; )
                a |= h.lanes | h.childLanes,
                u |= h.subtreeFlags & 65011712,
                u |= h.flags & 65011712,
                h.return = n,
                h = h.sibling;
        else
            for (h = n.child; h !== null; )
                a |= h.lanes | h.childLanes,
                u |= h.subtreeFlags,
                u |= h.flags,
                h.return = n,
                h = h.sibling;
        return n.subtreeFlags |= u,
        n.childLanes = a,
        i
    }
    function cS(n, i, a) {
        var u = i.pendingProps;
        switch (xf(i),
        i.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return rt(i),
            null;
        case 1:
            return rt(i),
            null;
        case 3:
            return a = i.stateNode,
            u = null,
            n !== null && (u = n.memoizedState.cache),
            i.memoizedState.cache !== u && (i.flags |= 2048),
            bi(At),
            Gn(),
            a.pendingContext && (a.context = a.pendingContext,
            a.pendingContext = null),
            (n === null || n.child === null) && (_a(i) ? xi(i) : n === null || n.memoizedState.isDehydrated && (i.flags & 256) === 0 || (i.flags |= 1024,
            om())),
            rt(i),
            null;
        case 26:
            return a = i.memoizedState,
            n === null ? (xi(i),
            a !== null ? (rt(i),
            bg(i, a)) : (rt(i),
            i.flags &= -16777217)) : a ? a !== n.memoizedState ? (xi(i),
            rt(i),
            bg(i, a)) : (rt(i),
            i.flags &= -16777217) : (n.memoizedProps !== u && xi(i),
            rt(i),
            i.flags &= -16777217),
            null;
        case 27:
            fi(i),
            a = Te.current;
            var h = i.type;
            if (n !== null && i.stateNode != null)
                n.memoizedProps !== u && xi(i);
            else {
                if (!u) {
                    if (i.stateNode === null)
                        throw Error(s(166));
                    return rt(i),
                    null
                }
                n = me.current,
                _a(i) ? rm(i) : (n = by(h, u, a),
                i.stateNode = n,
                xi(i))
            }
            return rt(i),
            null;
        case 5:
            if (fi(i),
            a = i.type,
            n !== null && i.stateNode != null)
                n.memoizedProps !== u && xi(i);
            else {
                if (!u) {
                    if (i.stateNode === null)
                        throw Error(s(166));
                    return rt(i),
                    null
                }
                if (n = me.current,
                _a(i))
                    rm(i);
                else {
                    switch (h = Ku(Te.current),
                    n) {
                    case 1:
                        n = h.createElementNS("http://www.w3.org/2000/svg", a);
                        break;
                    case 2:
                        n = h.createElementNS("http://www.w3.org/1998/Math/MathML", a);
                        break;
                    default:
                        switch (a) {
                        case "svg":
                            n = h.createElementNS("http://www.w3.org/2000/svg", a);
                            break;
                        case "math":
                            n = h.createElementNS("http://www.w3.org/1998/Math/MathML", a);
                            break;
                        case "script":
                            n = h.createElement("div"),
                            n.innerHTML = "<script><\/script>",
                            n = n.removeChild(n.firstChild);
                            break;
                        case "select":
                            n = typeof u.is == "string" ? h.createElement("select", {
                                is: u.is
                            }) : h.createElement("select"),
                            u.multiple ? n.multiple = !0 : u.size && (n.size = u.size);
                            break;
                        default:
                            n = typeof u.is == "string" ? h.createElement(a, {
                                is: u.is
                            }) : h.createElement(a)
                        }
                    }
                    n[Tt] = i,
                    n[pt] = u;
                    e: for (h = i.child; h !== null; ) {
                        if (h.tag === 5 || h.tag === 6)
                            n.appendChild(h.stateNode);
                        else if (h.tag !== 4 && h.tag !== 27 && h.child !== null) {
                            h.child.return = h,
                            h = h.child;
                            continue
                        }
                        if (h === i)
                            break e;
                        for (; h.sibling === null; ) {
                            if (h.return === null || h.return === i)
                                break e;
                            h = h.return
                        }
                        h.sibling.return = h.return,
                        h = h.sibling
                    }
                    i.stateNode = n;
                    e: switch (Lt(n, a, u),
                    a) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        n = !!u.autoFocus;
                        break e;
                    case "img":
                        n = !0;
                        break e;
                    default:
                        n = !1
                    }
                    n && xi(i)
                }
            }
            return rt(i),
            i.flags &= -16777217,
            null;
        case 6:
            if (n && i.stateNode != null)
                n.memoizedProps !== u && xi(i);
            else {
                if (typeof u != "string" && i.stateNode === null)
                    throw Error(s(166));
                if (n = Te.current,
                _a(i)) {
                    if (n = i.stateNode,
                    a = i.memoizedProps,
                    u = null,
                    h = en,
                    h !== null)
                        switch (h.tag) {
                        case 27:
                        case 5:
                            u = h.memoizedProps
                        }
                    n[Tt] = i,
                    n = !!(n.nodeValue === a || u !== null && u.suppressHydrationWarning === !0 || Ey(n.nodeValue, a)),
                    n || ds(i)
                } else
                    n = Ku(n).createTextNode(u),
                    n[Tt] = i,
                    i.stateNode = n
            }
            return rt(i),
            null;
        case 13:
            if (u = i.memoizedState,
            n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
                if (h = _a(i),
                u !== null && u.dehydrated !== null) {
                    if (n === null) {
                        if (!h)
                            throw Error(s(318));
                        if (h = i.memoizedState,
                        h = h !== null ? h.dehydrated : null,
                        !h)
                            throw Error(s(317));
                        h[Tt] = i
                    } else
                        Ta(),
                        (i.flags & 128) === 0 && (i.memoizedState = null),
                        i.flags |= 4;
                    rt(i),
                    h = !1
                } else
                    h = om(),
                    n !== null && n.memoizedState !== null && (n.memoizedState.hydrationErrors = h),
                    h = !0;
                if (!h)
                    return i.flags & 256 ? (Mi(i),
                    i) : (Mi(i),
                    null)
            }
            if (Mi(i),
            (i.flags & 128) !== 0)
                return i.lanes = a,
                i;
            if (a = u !== null,
            n = n !== null && n.memoizedState !== null,
            a) {
                u = i.child,
                h = null,
                u.alternate !== null && u.alternate.memoizedState !== null && u.alternate.memoizedState.cachePool !== null && (h = u.alternate.memoizedState.cachePool.pool);
                var g = null;
                u.memoizedState !== null && u.memoizedState.cachePool !== null && (g = u.memoizedState.cachePool.pool),
                g !== h && (u.flags |= 2048)
            }
            return a !== n && a && (i.child.flags |= 8192),
            Pu(i, i.updateQueue),
            rt(i),
            null;
        case 4:
            return Gn(),
            n === null && Gh(i.stateNode.containerInfo),
            rt(i),
            null;
        case 10:
            return bi(i.type),
            rt(i),
            null;
        case 19:
            if (ae(Ct),
            h = i.memoizedState,
            h === null)
                return rt(i),
                null;
            if (u = (i.flags & 128) !== 0,
            g = h.rendering,
            g === null)
                if (u)
                    Ua(h, !1);
                else {
                    if (at !== 0 || n !== null && (n.flags & 128) !== 0)
                        for (n = i.child; n !== null; ) {
                            if (g = bu(n),
                            g !== null) {
                                for (i.flags |= 128,
                                Ua(h, !1),
                                n = g.updateQueue,
                                i.updateQueue = n,
                                Pu(i, n),
                                i.subtreeFlags = 0,
                                n = a,
                                a = i.child; a !== null; )
                                    nm(a, n),
                                    a = a.sibling;
                                return ie(Ct, Ct.current & 1 | 2),
                                i.child
                            }
                            n = n.sibling
                        }
                    h.tail !== null && _n() > Uu && (i.flags |= 128,
                    u = !0,
                    Ua(h, !1),
                    i.lanes = 4194304)
                }
            else {
                if (!u)
                    if (n = bu(g),
                    n !== null) {
                        if (i.flags |= 128,
                        u = !0,
                        n = n.updateQueue,
                        i.updateQueue = n,
                        Pu(i, n),
                        Ua(h, !0),
                        h.tail === null && h.tailMode === "hidden" && !g.alternate && !qe)
                            return rt(i),
                            null
                    } else
                        2 * _n() - h.renderingStartTime > Uu && a !== 536870912 && (i.flags |= 128,
                        u = !0,
                        Ua(h, !1),
                        i.lanes = 4194304);
                h.isBackwards ? (g.sibling = i.child,
                i.child = g) : (n = h.last,
                n !== null ? n.sibling = g : i.child = g,
                h.last = g)
            }
            return h.tail !== null ? (i = h.tail,
            h.rendering = i,
            h.tail = i.sibling,
            h.renderingStartTime = _n(),
            i.sibling = null,
            n = Ct.current,
            ie(Ct, u ? n & 1 | 2 : n & 1),
            i) : (rt(i),
            null);
        case 22:
        case 23:
            return Mi(i),
            Kf(),
            u = i.memoizedState !== null,
            n !== null ? n.memoizedState !== null !== u && (i.flags |= 8192) : u && (i.flags |= 8192),
            u ? (a & 536870912) !== 0 && (i.flags & 128) === 0 && (rt(i),
            i.subtreeFlags & 6 && (i.flags |= 8192)) : rt(i),
            a = i.updateQueue,
            a !== null && Pu(i, a.retryQueue),
            a = null,
            n !== null && n.memoizedState !== null && n.memoizedState.cachePool !== null && (a = n.memoizedState.cachePool.pool),
            u = null,
            i.memoizedState !== null && i.memoizedState.cachePool !== null && (u = i.memoizedState.cachePool.pool),
            u !== a && (i.flags |= 2048),
            n !== null && ae(gs),
            null;
        case 24:
            return a = null,
            n !== null && (a = n.memoizedState.cache),
            i.memoizedState.cache !== a && (i.flags |= 2048),
            bi(At),
            rt(i),
            null;
        case 25:
            return null;
        case 30:
            return null
        }
        throw Error(s(156, i.tag))
    }
    function fS(n, i) {
        switch (xf(i),
        i.tag) {
        case 1:
            return n = i.flags,
            n & 65536 ? (i.flags = n & -65537 | 128,
            i) : null;
        case 3:
            return bi(At),
            Gn(),
            n = i.flags,
            (n & 65536) !== 0 && (n & 128) === 0 ? (i.flags = n & -65537 | 128,
            i) : null;
        case 26:
        case 27:
        case 5:
            return fi(i),
            null;
        case 13:
            if (Mi(i),
            n = i.memoizedState,
            n !== null && n.dehydrated !== null) {
                if (i.alternate === null)
                    throw Error(s(340));
                Ta()
            }
            return n = i.flags,
            n & 65536 ? (i.flags = n & -65537 | 128,
            i) : null;
        case 19:
            return ae(Ct),
            null;
        case 4:
            return Gn(),
            null;
        case 10:
            return bi(i.type),
            null;
        case 22:
        case 23:
            return Mi(i),
            Kf(),
            n !== null && ae(gs),
            n = i.flags,
            n & 65536 ? (i.flags = n & -65537 | 128,
            i) : null;
        case 24:
            return bi(At),
            null;
        case 25:
            return null;
        default:
            return null
        }
    }
    function Dg(n, i) {
        switch (xf(i),
        i.tag) {
        case 3:
            bi(At),
            Gn();
            break;
        case 26:
        case 27:
        case 5:
            fi(i);
            break;
        case 4:
            Gn();
            break;
        case 13:
            Mi(i);
            break;
        case 19:
            ae(Ct);
            break;
        case 10:
            bi(i.type);
            break;
        case 22:
        case 23:
            Mi(i),
            Kf(),
            n !== null && ae(gs);
            break;
        case 24:
            bi(At)
        }
    }
    function ka(n, i) {
        try {
            var a = i.updateQueue
              , u = a !== null ? a.lastEffect : null;
            if (u !== null) {
                var h = u.next;
                a = h;
                do {
                    if ((a.tag & n) === n) {
                        u = void 0;
                        var g = a.create
                          , S = a.inst;
                        u = g(),
                        S.destroy = u
                    }
                    a = a.next
                } while (a !== h)
            }
        } catch (C) {
            Je(i, i.return, C)
        }
    }
    function lr(n, i, a) {
        try {
            var u = i.updateQueue
              , h = u !== null ? u.lastEffect : null;
            if (h !== null) {
                var g = h.next;
                u = g;
                do {
                    if ((u.tag & n) === n) {
                        var S = u.inst
                          , C = S.destroy;
                        if (C !== void 0) {
                            S.destroy = void 0,
                            h = i;
                            var D = a
                              , H = C;
                            try {
                                H()
                            } catch ($) {
                                Je(h, D, $)
                            }
                        }
                    }
                    u = u.next
                } while (u !== g)
            }
        } catch ($) {
            Je(i, i.return, $)
        }
    }
    function Mg(n) {
        var i = n.updateQueue;
        if (i !== null) {
            var a = n.stateNode;
            try {
                ym(i, a)
            } catch (u) {
                Je(n, n.return, u)
            }
        }
    }
    function Ng(n, i, a) {
        a.props = vs(n.type, n.memoizedProps),
        a.state = n.memoizedState;
        try {
            a.componentWillUnmount()
        } catch (u) {
            Je(n, i, u)
        }
    }
    function La(n, i) {
        try {
            var a = n.ref;
            if (a !== null) {
                switch (n.tag) {
                case 26:
                case 27:
                case 5:
                    var u = n.stateNode;
                    break;
                case 30:
                    u = n.stateNode;
                    break;
                default:
                    u = n.stateNode
                }
                typeof a == "function" ? n.refCleanup = a(u) : a.current = u
            }
        } catch (h) {
            Je(n, i, h)
        }
    }
    function ri(n, i) {
        var a = n.ref
          , u = n.refCleanup;
        if (a !== null)
            if (typeof u == "function")
                try {
                    u()
                } catch (h) {
                    Je(n, i, h)
                } finally {
                    n.refCleanup = null,
                    n = n.alternate,
                    n != null && (n.refCleanup = null)
                }
            else if (typeof a == "function")
                try {
                    a(null)
                } catch (h) {
                    Je(n, i, h)
                }
            else
                a.current = null
    }
    function xg(n) {
        var i = n.type
          , a = n.memoizedProps
          , u = n.stateNode;
        try {
            e: switch (i) {
            case "button":
            case "input":
            case "select":
            case "textarea":
                a.autoFocus && u.focus();
                break e;
            case "img":
                a.src ? u.src = a.src : a.srcSet && (u.srcset = a.srcSet)
            }
        } catch (h) {
            Je(n, n.return, h)
        }
    }
    function Th(n, i, a) {
        try {
            var u = n.stateNode;
            xS(u, n.type, a, i),
            u[pt] = i
        } catch (h) {
            Je(n, n.return, h)
        }
    }
    function Pg(n) {
        return n.tag === 5 || n.tag === 3 || n.tag === 26 || n.tag === 27 && gr(n.type) || n.tag === 4
    }
    function Eh(n) {
        e: for (; ; ) {
            for (; n.sibling === null; ) {
                if (n.return === null || Pg(n.return))
                    return null;
                n = n.return
            }
            for (n.sibling.return = n.return,
            n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18; ) {
                if (n.tag === 27 && gr(n.type) || n.flags & 2 || n.child === null || n.tag === 4)
                    continue e;
                n.child.return = n,
                n = n.child
            }
            if (!(n.flags & 2))
                return n.stateNode
        }
    }
    function Sh(n, i, a) {
        var u = n.tag;
        if (u === 5 || u === 6)
            n = n.stateNode,
            i ? (a.nodeType === 9 ? a.body : a.nodeName === "HTML" ? a.ownerDocument.body : a).insertBefore(n, i) : (i = a.nodeType === 9 ? a.body : a.nodeName === "HTML" ? a.ownerDocument.body : a,
            i.appendChild(n),
            a = a._reactRootContainer,
            a != null || i.onclick !== null || (i.onclick = Yu));
        else if (u !== 4 && (u === 27 && gr(n.type) && (a = n.stateNode,
        i = null),
        n = n.child,
        n !== null))
            for (Sh(n, i, a),
            n = n.sibling; n !== null; )
                Sh(n, i, a),
                n = n.sibling
    }
    function Ou(n, i, a) {
        var u = n.tag;
        if (u === 5 || u === 6)
            n = n.stateNode,
            i ? a.insertBefore(n, i) : a.appendChild(n);
        else if (u !== 4 && (u === 27 && gr(n.type) && (a = n.stateNode),
        n = n.child,
        n !== null))
            for (Ou(n, i, a),
            n = n.sibling; n !== null; )
                Ou(n, i, a),
                n = n.sibling
    }
    function Og(n) {
        var i = n.stateNode
          , a = n.memoizedProps;
        try {
            for (var u = n.type, h = i.attributes; h.length; )
                i.removeAttributeNode(h[0]);
            Lt(i, u, a),
            i[Tt] = n,
            i[pt] = a
        } catch (g) {
            Je(n, n.return, g)
        }
    }
    var Pi = !1
      , ht = !1
      , Ah = !1
      , Vg = typeof WeakSet == "function" ? WeakSet : Set
      , Dt = null;
    function hS(n, i) {
        if (n = n.containerInfo,
        Qh = Wu,
        n = Kp(n),
        Ef(n)) {
            if ("selectionStart"in n)
                var a = {
                    start: n.selectionStart,
                    end: n.selectionEnd
                };
            else
                e: {
                    a = (a = n.ownerDocument) && a.defaultView || window;
                    var u = a.getSelection && a.getSelection();
                    if (u && u.rangeCount !== 0) {
                        a = u.anchorNode;
                        var h = u.anchorOffset
                          , g = u.focusNode;
                        u = u.focusOffset;
                        try {
                            a.nodeType,
                            g.nodeType
                        } catch {
                            a = null;
                            break e
                        }
                        var S = 0
                          , C = -1
                          , D = -1
                          , H = 0
                          , $ = 0
                          , W = n
                          , Y = null;
                        t: for (; ; ) {
                            for (var K; W !== a || h !== 0 && W.nodeType !== 3 || (C = S + h),
                            W !== g || u !== 0 && W.nodeType !== 3 || (D = S + u),
                            W.nodeType === 3 && (S += W.nodeValue.length),
                            (K = W.firstChild) !== null; )
                                Y = W,
                                W = K;
                            for (; ; ) {
                                if (W === n)
                                    break t;
                                if (Y === a && ++H === h && (C = S),
                                Y === g && ++$ === u && (D = S),
                                (K = W.nextSibling) !== null)
                                    break;
                                W = Y,
                                Y = W.parentNode
                            }
                            W = K
                        }
                        a = C === -1 || D === -1 ? null : {
                            start: C,
                            end: D
                        }
                    } else
                        a = null
                }
            a = a || {
                start: 0,
                end: 0
            }
        } else
            a = null;
        for (Xh = {
            focusedElem: n,
            selectionRange: a
        },
        Wu = !1,
        Dt = i; Dt !== null; )
            if (i = Dt,
            n = i.child,
            (i.subtreeFlags & 1024) !== 0 && n !== null)
                n.return = i,
                Dt = n;
            else
                for (; Dt !== null; ) {
                    switch (i = Dt,
                    g = i.alternate,
                    n = i.flags,
                    i.tag) {
                    case 0:
                        break;
                    case 11:
                    case 15:
                        break;
                    case 1:
                        if ((n & 1024) !== 0 && g !== null) {
                            n = void 0,
                            a = i,
                            h = g.memoizedProps,
                            g = g.memoizedState,
                            u = a.stateNode;
                            try {
                                var _e = vs(a.type, h, a.elementType === a.type);
                                n = u.getSnapshotBeforeUpdate(_e, g),
                                u.__reactInternalSnapshotBeforeUpdate = n
                            } catch (ge) {
                                Je(a, a.return, ge)
                            }
                        }
                        break;
                    case 3:
                        if ((n & 1024) !== 0) {
                            if (n = i.stateNode.containerInfo,
                            a = n.nodeType,
                            a === 9)
                                jh(n);
                            else if (a === 1)
                                switch (n.nodeName) {
                                case "HEAD":
                                case "HTML":
                                case "BODY":
                                    jh(n);
                                    break;
                                default:
                                    n.textContent = ""
                                }
                        }
                        break;
                    case 5:
                    case 26:
                    case 27:
                    case 6:
                    case 4:
                    case 17:
                        break;
                    default:
                        if ((n & 1024) !== 0)
                            throw Error(s(163))
                    }
                    if (n = i.sibling,
                    n !== null) {
                        n.return = i.return,
                        Dt = n;
                        break
                    }
                    Dt = i.return
                }
    }
    function Ug(n, i, a) {
        var u = a.flags;
        switch (a.tag) {
        case 0:
        case 11:
        case 15:
            ur(n, a),
            u & 4 && ka(5, a);
            break;
        case 1:
            if (ur(n, a),
            u & 4)
                if (n = a.stateNode,
                i === null)
                    try {
                        n.componentDidMount()
                    } catch (S) {
                        Je(a, a.return, S)
                    }
                else {
                    var h = vs(a.type, i.memoizedProps);
                    i = i.memoizedState;
                    try {
                        n.componentDidUpdate(h, i, n.__reactInternalSnapshotBeforeUpdate)
                    } catch (S) {
                        Je(a, a.return, S)
                    }
                }
            u & 64 && Mg(a),
            u & 512 && La(a, a.return);
            break;
        case 3:
            if (ur(n, a),
            u & 64 && (n = a.updateQueue,
            n !== null)) {
                if (i = null,
                a.child !== null)
                    switch (a.child.tag) {
                    case 27:
                    case 5:
                        i = a.child.stateNode;
                        break;
                    case 1:
                        i = a.child.stateNode
                    }
                try {
                    ym(n, i)
                } catch (S) {
                    Je(a, a.return, S)
                }
            }
            break;
        case 27:
            i === null && u & 4 && Og(a);
        case 26:
        case 5:
            ur(n, a),
            i === null && u & 4 && xg(a),
            u & 512 && La(a, a.return);
            break;
        case 12:
            ur(n, a);
            break;
        case 13:
            ur(n, a),
            u & 4 && Bg(n, a),
            u & 64 && (n = a.memoizedState,
            n !== null && (n = n.dehydrated,
            n !== null && (a = ES.bind(null, a),
            BS(n, a))));
            break;
        case 22:
            if (u = a.memoizedState !== null || Pi,
            !u) {
                i = i !== null && i.memoizedState !== null || ht,
                h = Pi;
                var g = ht;
                Pi = u,
                (ht = i) && !g ? cr(n, a, (a.subtreeFlags & 8772) !== 0) : ur(n, a),
                Pi = h,
                ht = g
            }
            break;
        case 30:
            break;
        default:
            ur(n, a)
        }
    }
    function kg(n) {
        var i = n.alternate;
        i !== null && (n.alternate = null,
        kg(i)),
        n.child = null,
        n.deletions = null,
        n.sibling = null,
        n.tag === 5 && (i = n.stateNode,
        i !== null && ji(i)),
        n.stateNode = null,
        n.return = null,
        n.dependencies = null,
        n.memoizedProps = null,
        n.memoizedState = null,
        n.pendingProps = null,
        n.stateNode = null,
        n.updateQueue = null
    }
    var nt = null
      , nn = !1;
    function Oi(n, i, a) {
        for (a = a.child; a !== null; )
            Lg(n, i, a),
            a = a.sibling
    }
    function Lg(n, i, a) {
        if (Fe && typeof Fe.onCommitFiberUnmount == "function")
            try {
                Fe.onCommitFiberUnmount(st, a)
            } catch {}
        switch (a.tag) {
        case 26:
            ht || ri(a, i),
            Oi(n, i, a),
            a.memoizedState ? a.memoizedState.count-- : a.stateNode && (a = a.stateNode,
            a.parentNode.removeChild(a));
            break;
        case 27:
            ht || ri(a, i);
            var u = nt
              , h = nn;
            gr(a.type) && (nt = a.stateNode,
            nn = !1),
            Oi(n, i, a),
            Qa(a.stateNode),
            nt = u,
            nn = h;
            break;
        case 5:
            ht || ri(a, i);
        case 6:
            if (u = nt,
            h = nn,
            nt = null,
            Oi(n, i, a),
            nt = u,
            nn = h,
            nt !== null)
                if (nn)
                    try {
                        (nt.nodeType === 9 ? nt.body : nt.nodeName === "HTML" ? nt.ownerDocument.body : nt).removeChild(a.stateNode)
                    } catch (g) {
                        Je(a, i, g)
                    }
                else
                    try {
                        nt.removeChild(a.stateNode)
                    } catch (g) {
                        Je(a, i, g)
                    }
            break;
        case 18:
            nt !== null && (nn ? (n = nt,
            Iy(n.nodeType === 9 ? n.body : n.nodeName === "HTML" ? n.ownerDocument.body : n, a.stateNode),
            tl(n)) : Iy(nt, a.stateNode));
            break;
        case 4:
            u = nt,
            h = nn,
            nt = a.stateNode.containerInfo,
            nn = !0,
            Oi(n, i, a),
            nt = u,
            nn = h;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            ht || lr(2, a, i),
            ht || lr(4, a, i),
            Oi(n, i, a);
            break;
        case 1:
            ht || (ri(a, i),
            u = a.stateNode,
            typeof u.componentWillUnmount == "function" && Ng(a, i, u)),
            Oi(n, i, a);
            break;
        case 21:
            Oi(n, i, a);
            break;
        case 22:
            ht = (u = ht) || a.memoizedState !== null,
            Oi(n, i, a),
            ht = u;
            break;
        default:
            Oi(n, i, a)
        }
    }
    function Bg(n, i) {
        if (i.memoizedState === null && (n = i.alternate,
        n !== null && (n = n.memoizedState,
        n !== null && (n = n.dehydrated,
        n !== null))))
            try {
                tl(n)
            } catch (a) {
                Je(i, i.return, a)
            }
    }
    function dS(n) {
        switch (n.tag) {
        case 13:
        case 19:
            var i = n.stateNode;
            return i === null && (i = n.stateNode = new Vg),
            i;
        case 22:
            return n = n.stateNode,
            i = n._retryCache,
            i === null && (i = n._retryCache = new Vg),
            i;
        default:
            throw Error(s(435, n.tag))
        }
    }
    function Ch(n, i) {
        var a = dS(n);
        i.forEach(function(u) {
            var h = SS.bind(null, n, u);
            a.has(u) || (a.add(u),
            u.then(h, h))
        })
    }
    function hn(n, i) {
        var a = i.deletions;
        if (a !== null)
            for (var u = 0; u < a.length; u++) {
                var h = a[u]
                  , g = n
                  , S = i
                  , C = S;
                e: for (; C !== null; ) {
                    switch (C.tag) {
                    case 27:
                        if (gr(C.type)) {
                            nt = C.stateNode,
                            nn = !1;
                            break e
                        }
                        break;
                    case 5:
                        nt = C.stateNode,
                        nn = !1;
                        break e;
                    case 3:
                    case 4:
                        nt = C.stateNode.containerInfo,
                        nn = !0;
                        break e
                    }
                    C = C.return
                }
                if (nt === null)
                    throw Error(s(160));
                Lg(g, S, h),
                nt = null,
                nn = !1,
                g = h.alternate,
                g !== null && (g.return = null),
                h.return = null
            }
        if (i.subtreeFlags & 13878)
            for (i = i.child; i !== null; )
                qg(i, n),
                i = i.sibling
    }
    var kn = null;
    function qg(n, i) {
        var a = n.alternate
          , u = n.flags;
        switch (n.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            hn(i, n),
            dn(n),
            u & 4 && (lr(3, n, n.return),
            ka(3, n),
            lr(5, n, n.return));
            break;
        case 1:
            hn(i, n),
            dn(n),
            u & 512 && (ht || a === null || ri(a, a.return)),
            u & 64 && Pi && (n = n.updateQueue,
            n !== null && (u = n.callbacks,
            u !== null && (a = n.shared.hiddenCallbacks,
            n.shared.hiddenCallbacks = a === null ? u : a.concat(u))));
            break;
        case 26:
            var h = kn;
            if (hn(i, n),
            dn(n),
            u & 512 && (ht || a === null || ri(a, a.return)),
            u & 4) {
                var g = a !== null ? a.memoizedState : null;
                if (u = n.memoizedState,
                a === null)
                    if (u === null)
                        if (n.stateNode === null) {
                            e: {
                                u = n.type,
                                a = n.memoizedProps,
                                h = h.ownerDocument || h;
                                t: switch (u) {
                                case "title":
                                    g = h.getElementsByTagName("title")[0],
                                    (!g || g[Qr] || g[Tt] || g.namespaceURI === "http://www.w3.org/2000/svg" || g.hasAttribute("itemprop")) && (g = h.createElement(u),
                                    h.head.insertBefore(g, h.querySelector("head > title"))),
                                    Lt(g, u, a),
                                    g[Tt] = n,
                                    ct(g),
                                    u = g;
                                    break e;
                                case "link":
                                    var S = Oy("link", "href", h).get(u + (a.href || ""));
                                    if (S) {
                                        for (var C = 0; C < S.length; C++)
                                            if (g = S[C],
                                            g.getAttribute("href") === (a.href == null || a.href === "" ? null : a.href) && g.getAttribute("rel") === (a.rel == null ? null : a.rel) && g.getAttribute("title") === (a.title == null ? null : a.title) && g.getAttribute("crossorigin") === (a.crossOrigin == null ? null : a.crossOrigin)) {
                                                S.splice(C, 1);
                                                break t
                                            }
                                    }
                                    g = h.createElement(u),
                                    Lt(g, u, a),
                                    h.head.appendChild(g);
                                    break;
                                case "meta":
                                    if (S = Oy("meta", "content", h).get(u + (a.content || ""))) {
                                        for (C = 0; C < S.length; C++)
                                            if (g = S[C],
                                            g.getAttribute("content") === (a.content == null ? null : "" + a.content) && g.getAttribute("name") === (a.name == null ? null : a.name) && g.getAttribute("property") === (a.property == null ? null : a.property) && g.getAttribute("http-equiv") === (a.httpEquiv == null ? null : a.httpEquiv) && g.getAttribute("charset") === (a.charSet == null ? null : a.charSet)) {
                                                S.splice(C, 1);
                                                break t
                                            }
                                    }
                                    g = h.createElement(u),
                                    Lt(g, u, a),
                                    h.head.appendChild(g);
                                    break;
                                default:
                                    throw Error(s(468, u))
                                }
                                g[Tt] = n,
                                ct(g),
                                u = g
                            }
                            n.stateNode = u
                        } else
                            Vy(h, n.type, n.stateNode);
                    else
                        n.stateNode = Py(h, u, n.memoizedProps);
                else
                    g !== u ? (g === null ? a.stateNode !== null && (a = a.stateNode,
                    a.parentNode.removeChild(a)) : g.count--,
                    u === null ? Vy(h, n.type, n.stateNode) : Py(h, u, n.memoizedProps)) : u === null && n.stateNode !== null && Th(n, n.memoizedProps, a.memoizedProps)
            }
            break;
        case 27:
            hn(i, n),
            dn(n),
            u & 512 && (ht || a === null || ri(a, a.return)),
            a !== null && u & 4 && Th(n, n.memoizedProps, a.memoizedProps);
            break;
        case 5:
            if (hn(i, n),
            dn(n),
            u & 512 && (ht || a === null || ri(a, a.return)),
            n.flags & 32) {
                h = n.stateNode;
                try {
                    En(h, "")
                } catch (K) {
                    Je(n, n.return, K)
                }
            }
            u & 4 && n.stateNode != null && (h = n.memoizedProps,
            Th(n, h, a !== null ? a.memoizedProps : h)),
            u & 1024 && (Ah = !0);
            break;
        case 6:
            if (hn(i, n),
            dn(n),
            u & 4) {
                if (n.stateNode === null)
                    throw Error(s(162));
                u = n.memoizedProps,
                a = n.stateNode;
                try {
                    a.nodeValue = u
                } catch (K) {
                    Je(n, n.return, K)
                }
            }
            break;
        case 3:
            if ($u = null,
            h = kn,
            kn = Qu(i.containerInfo),
            hn(i, n),
            kn = h,
            dn(n),
            u & 4 && a !== null && a.memoizedState.isDehydrated)
                try {
                    tl(i.containerInfo)
                } catch (K) {
                    Je(n, n.return, K)
                }
            Ah && (Ah = !1,
            zg(n));
            break;
        case 4:
            u = kn,
            kn = Qu(n.stateNode.containerInfo),
            hn(i, n),
            dn(n),
            kn = u;
            break;
        case 12:
            hn(i, n),
            dn(n);
            break;
        case 13:
            hn(i, n),
            dn(n),
            n.child.flags & 8192 && n.memoizedState !== null != (a !== null && a.memoizedState !== null) && (Mh = _n()),
            u & 4 && (u = n.updateQueue,
            u !== null && (n.updateQueue = null,
            Ch(n, u)));
            break;
        case 22:
            h = n.memoizedState !== null;
            var D = a !== null && a.memoizedState !== null
              , H = Pi
              , $ = ht;
            if (Pi = H || h,
            ht = $ || D,
            hn(i, n),
            ht = $,
            Pi = H,
            dn(n),
            u & 8192)
                e: for (i = n.stateNode,
                i._visibility = h ? i._visibility & -2 : i._visibility | 1,
                h && (a === null || D || Pi || ht || _s(n)),
                a = null,
                i = n; ; ) {
                    if (i.tag === 5 || i.tag === 26) {
                        if (a === null) {
                            D = a = i;
                            try {
                                if (g = D.stateNode,
                                h)
                                    S = g.style,
                                    typeof S.setProperty == "function" ? S.setProperty("display", "none", "important") : S.display = "none";
                                else {
                                    C = D.stateNode;
                                    var W = D.memoizedProps.style
                                      , Y = W != null && W.hasOwnProperty("display") ? W.display : null;
                                    C.style.display = Y == null || typeof Y == "boolean" ? "" : ("" + Y).trim()
                                }
                            } catch (K) {
                                Je(D, D.return, K)
                            }
                        }
                    } else if (i.tag === 6) {
                        if (a === null) {
                            D = i;
                            try {
                                D.stateNode.nodeValue = h ? "" : D.memoizedProps
                            } catch (K) {
                                Je(D, D.return, K)
                            }
                        }
                    } else if ((i.tag !== 22 && i.tag !== 23 || i.memoizedState === null || i === n) && i.child !== null) {
                        i.child.return = i,
                        i = i.child;
                        continue
                    }
                    if (i === n)
                        break e;
                    for (; i.sibling === null; ) {
                        if (i.return === null || i.return === n)
                            break e;
                        a === i && (a = null),
                        i = i.return
                    }
                    a === i && (a = null),
                    i.sibling.return = i.return,
                    i = i.sibling
                }
            u & 4 && (u = n.updateQueue,
            u !== null && (a = u.retryQueue,
            a !== null && (u.retryQueue = null,
            Ch(n, a))));
            break;
        case 19:
            hn(i, n),
            dn(n),
            u & 4 && (u = n.updateQueue,
            u !== null && (n.updateQueue = null,
            Ch(n, u)));
            break;
        case 30:
            break;
        case 21:
            break;
        default:
            hn(i, n),
            dn(n)
        }
    }
    function dn(n) {
        var i = n.flags;
        if (i & 2) {
            try {
                for (var a, u = n.return; u !== null; ) {
                    if (Pg(u)) {
                        a = u;
                        break
                    }
                    u = u.return
                }
                if (a == null)
                    throw Error(s(160));
                switch (a.tag) {
                case 27:
                    var h = a.stateNode
                      , g = Eh(n);
                    Ou(n, g, h);
                    break;
                case 5:
                    var S = a.stateNode;
                    a.flags & 32 && (En(S, ""),
                    a.flags &= -33);
                    var C = Eh(n);
                    Ou(n, C, S);
                    break;
                case 3:
                case 4:
                    var D = a.stateNode.containerInfo
                      , H = Eh(n);
                    Sh(n, H, D);
                    break;
                default:
                    throw Error(s(161))
                }
            } catch ($) {
                Je(n, n.return, $)
            }
            n.flags &= -3
        }
        i & 4096 && (n.flags &= -4097)
    }
    function zg(n) {
        if (n.subtreeFlags & 1024)
            for (n = n.child; n !== null; ) {
                var i = n;
                zg(i),
                i.tag === 5 && i.flags & 1024 && i.stateNode.reset(),
                n = n.sibling
            }
    }
    function ur(n, i) {
        if (i.subtreeFlags & 8772)
            for (i = i.child; i !== null; )
                Ug(n, i.alternate, i),
                i = i.sibling
    }
    function _s(n) {
        for (n = n.child; n !== null; ) {
            var i = n;
            switch (i.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                lr(4, i, i.return),
                _s(i);
                break;
            case 1:
                ri(i, i.return);
                var a = i.stateNode;
                typeof a.componentWillUnmount == "function" && Ng(i, i.return, a),
                _s(i);
                break;
            case 27:
                Qa(i.stateNode);
            case 26:
            case 5:
                ri(i, i.return),
                _s(i);
                break;
            case 22:
                i.memoizedState === null && _s(i);
                break;
            case 30:
                _s(i);
                break;
            default:
                _s(i)
            }
            n = n.sibling
        }
    }
    function cr(n, i, a) {
        for (a = a && (i.subtreeFlags & 8772) !== 0,
        i = i.child; i !== null; ) {
            var u = i.alternate
              , h = n
              , g = i
              , S = g.flags;
            switch (g.tag) {
            case 0:
            case 11:
            case 15:
                cr(h, g, a),
                ka(4, g);
                break;
            case 1:
                if (cr(h, g, a),
                u = g,
                h = u.stateNode,
                typeof h.componentDidMount == "function")
                    try {
                        h.componentDidMount()
                    } catch (H) {
                        Je(u, u.return, H)
                    }
                if (u = g,
                h = u.updateQueue,
                h !== null) {
                    var C = u.stateNode;
                    try {
                        var D = h.shared.hiddenCallbacks;
                        if (D !== null)
                            for (h.shared.hiddenCallbacks = null,
                            h = 0; h < D.length; h++)
                                gm(D[h], C)
                    } catch (H) {
                        Je(u, u.return, H)
                    }
                }
                a && S & 64 && Mg(g),
                La(g, g.return);
                break;
            case 27:
                Og(g);
            case 26:
            case 5:
                cr(h, g, a),
                a && u === null && S & 4 && xg(g),
                La(g, g.return);
                break;
            case 12:
                cr(h, g, a);
                break;
            case 13:
                cr(h, g, a),
                a && S & 4 && Bg(h, g);
                break;
            case 22:
                g.memoizedState === null && cr(h, g, a),
                La(g, g.return);
                break;
            case 30:
                break;
            default:
                cr(h, g, a)
            }
            i = i.sibling
        }
    }
    function Rh(n, i) {
        var a = null;
        n !== null && n.memoizedState !== null && n.memoizedState.cachePool !== null && (a = n.memoizedState.cachePool.pool),
        n = null,
        i.memoizedState !== null && i.memoizedState.cachePool !== null && (n = i.memoizedState.cachePool.pool),
        n !== a && (n != null && n.refCount++,
        a != null && Aa(a))
    }
    function Ih(n, i) {
        n = null,
        i.alternate !== null && (n = i.alternate.memoizedState.cache),
        i = i.memoizedState.cache,
        i !== n && (i.refCount++,
        n != null && Aa(n))
    }
    function si(n, i, a, u) {
        if (i.subtreeFlags & 10256)
            for (i = i.child; i !== null; )
                Fg(n, i, a, u),
                i = i.sibling
    }
    function Fg(n, i, a, u) {
        var h = i.flags;
        switch (i.tag) {
        case 0:
        case 11:
        case 15:
            si(n, i, a, u),
            h & 2048 && ka(9, i);
            break;
        case 1:
            si(n, i, a, u);
            break;
        case 3:
            si(n, i, a, u),
            h & 2048 && (n = null,
            i.alternate !== null && (n = i.alternate.memoizedState.cache),
            i = i.memoizedState.cache,
            i !== n && (i.refCount++,
            n != null && Aa(n)));
            break;
        case 12:
            if (h & 2048) {
                si(n, i, a, u),
                n = i.stateNode;
                try {
                    var g = i.memoizedProps
                      , S = g.id
                      , C = g.onPostCommit;
                    typeof C == "function" && C(S, i.alternate === null ? "mount" : "update", n.passiveEffectDuration, -0)
                } catch (D) {
                    Je(i, i.return, D)
                }
            } else
                si(n, i, a, u);
            break;
        case 13:
            si(n, i, a, u);
            break;
        case 23:
            break;
        case 22:
            g = i.stateNode,
            S = i.alternate,
            i.memoizedState !== null ? g._visibility & 2 ? si(n, i, a, u) : Ba(n, i) : g._visibility & 2 ? si(n, i, a, u) : (g._visibility |= 2,
            yo(n, i, a, u, (i.subtreeFlags & 10256) !== 0)),
            h & 2048 && Rh(S, i);
            break;
        case 24:
            si(n, i, a, u),
            h & 2048 && Ih(i.alternate, i);
            break;
        default:
            si(n, i, a, u)
        }
    }
    function yo(n, i, a, u, h) {
        for (h = h && (i.subtreeFlags & 10256) !== 0,
        i = i.child; i !== null; ) {
            var g = n
              , S = i
              , C = a
              , D = u
              , H = S.flags;
            switch (S.tag) {
            case 0:
            case 11:
            case 15:
                yo(g, S, C, D, h),
                ka(8, S);
                break;
            case 23:
                break;
            case 22:
                var $ = S.stateNode;
                S.memoizedState !== null ? $._visibility & 2 ? yo(g, S, C, D, h) : Ba(g, S) : ($._visibility |= 2,
                yo(g, S, C, D, h)),
                h && H & 2048 && Rh(S.alternate, S);
                break;
            case 24:
                yo(g, S, C, D, h),
                h && H & 2048 && Ih(S.alternate, S);
                break;
            default:
                yo(g, S, C, D, h)
            }
            i = i.sibling
        }
    }
    function Ba(n, i) {
        if (i.subtreeFlags & 10256)
            for (i = i.child; i !== null; ) {
                var a = n
                  , u = i
                  , h = u.flags;
                switch (u.tag) {
                case 22:
                    Ba(a, u),
                    h & 2048 && Rh(u.alternate, u);
                    break;
                case 24:
                    Ba(a, u),
                    h & 2048 && Ih(u.alternate, u);
                    break;
                default:
                    Ba(a, u)
                }
                i = i.sibling
            }
    }
    var qa = 8192;
    function vo(n) {
        if (n.subtreeFlags & qa)
            for (n = n.child; n !== null; )
                Hg(n),
                n = n.sibling
    }
    function Hg(n) {
        switch (n.tag) {
        case 26:
            vo(n),
            n.flags & qa && n.memoizedState !== null && WS(kn, n.memoizedState, n.memoizedProps);
            break;
        case 5:
            vo(n);
            break;
        case 3:
        case 4:
            var i = kn;
            kn = Qu(n.stateNode.containerInfo),
            vo(n),
            kn = i;
            break;
        case 22:
            n.memoizedState === null && (i = n.alternate,
            i !== null && i.memoizedState !== null ? (i = qa,
            qa = 16777216,
            vo(n),
            qa = i) : vo(n));
            break;
        default:
            vo(n)
        }
    }
    function Gg(n) {
        var i = n.alternate;
        if (i !== null && (n = i.child,
        n !== null)) {
            i.child = null;
            do
                i = n.sibling,
                n.sibling = null,
                n = i;
            while (n !== null)
        }
    }
    function za(n) {
        var i = n.deletions;
        if ((n.flags & 16) !== 0) {
            if (i !== null)
                for (var a = 0; a < i.length; a++) {
                    var u = i[a];
                    Dt = u,
                    Kg(u, n)
                }
            Gg(n)
        }
        if (n.subtreeFlags & 10256)
            for (n = n.child; n !== null; )
                Yg(n),
                n = n.sibling
    }
    function Yg(n) {
        switch (n.tag) {
        case 0:
        case 11:
        case 15:
            za(n),
            n.flags & 2048 && lr(9, n, n.return);
            break;
        case 3:
            za(n);
            break;
        case 12:
            za(n);
            break;
        case 22:
            var i = n.stateNode;
            n.memoizedState !== null && i._visibility & 2 && (n.return === null || n.return.tag !== 13) ? (i._visibility &= -3,
            Vu(n)) : za(n);
            break;
        default:
            za(n)
        }
    }
    function Vu(n) {
        var i = n.deletions;
        if ((n.flags & 16) !== 0) {
            if (i !== null)
                for (var a = 0; a < i.length; a++) {
                    var u = i[a];
                    Dt = u,
                    Kg(u, n)
                }
            Gg(n)
        }
        for (n = n.child; n !== null; ) {
            switch (i = n,
            i.tag) {
            case 0:
            case 11:
            case 15:
                lr(8, i, i.return),
                Vu(i);
                break;
            case 22:
                a = i.stateNode,
                a._visibility & 2 && (a._visibility &= -3,
                Vu(i));
                break;
            default:
                Vu(i)
            }
            n = n.sibling
        }
    }
    function Kg(n, i) {
        for (; Dt !== null; ) {
            var a = Dt;
            switch (a.tag) {
            case 0:
            case 11:
            case 15:
                lr(8, a, i);
                break;
            case 23:
            case 22:
                if (a.memoizedState !== null && a.memoizedState.cachePool !== null) {
                    var u = a.memoizedState.cachePool.pool;
                    u != null && u.refCount++
                }
                break;
            case 24:
                Aa(a.memoizedState.cache)
            }
            if (u = a.child,
            u !== null)
                u.return = a,
                Dt = u;
            else
                e: for (a = n; Dt !== null; ) {
                    u = Dt;
                    var h = u.sibling
                      , g = u.return;
                    if (kg(u),
                    u === a) {
                        Dt = null;
                        break e
                    }
                    if (h !== null) {
                        h.return = g,
                        Dt = h;
                        break e
                    }
                    Dt = g
                }
        }
    }
    var pS = {
        getCacheForType: function(n) {
            var i = Gt(At)
              , a = i.data.get(n);
            return a === void 0 && (a = n(),
            i.data.set(n, a)),
            a
        }
    }
      , mS = typeof WeakMap == "function" ? WeakMap : Map
      , He = 0
      , Ze = null
      , Me = null
      , Ve = 0
      , Ge = 0
      , pn = null
      , fr = !1
      , _o = !1
      , wh = !1
      , Vi = 0
      , at = 0
      , hr = 0
      , Ts = 0
      , bh = 0
      , Mn = 0
      , To = 0
      , Fa = null
      , rn = null
      , Dh = !1
      , Mh = 0
      , Uu = 1 / 0
      , ku = null
      , dr = null
      , kt = 0
      , pr = null
      , Eo = null
      , So = 0
      , Nh = 0
      , xh = null
      , Qg = null
      , Ha = 0
      , Ph = null;
    function mn() {
        if ((He & 2) !== 0 && Ve !== 0)
            return Ve & -Ve;
        if (X.T !== null) {
            var n = lo;
            return n !== 0 ? n : qh()
        }
        return $i()
    }
    function Xg() {
        Mn === 0 && (Mn = (Ve & 536870912) === 0 || qe ? Wo() : 536870912);
        var n = Dn.current;
        return n !== null && (n.flags |= 32),
        Mn
    }
    function gn(n, i, a) {
        (n === Ze && (Ge === 2 || Ge === 9) || n.cancelPendingCommit !== null) && (Ao(n, 0),
        mr(n, Ve, Mn, !1)),
        di(n, a),
        ((He & 2) === 0 || n !== Ze) && (n === Ze && ((He & 2) === 0 && (Ts |= a),
        at === 4 && mr(n, Ve, Mn, !1)),
        oi(n))
    }
    function $g(n, i, a) {
        if ((He & 6) !== 0)
            throw Error(s(327));
        var u = !a && (i & 124) === 0 && (i & n.expiredLanes) === 0 || Kr(n, i)
          , h = u ? vS(n, i) : Uh(n, i, !0)
          , g = u;
        do {
            if (h === 0) {
                _o && !u && mr(n, i, 0, !1);
                break
            } else {
                if (a = n.current.alternate,
                g && !gS(a)) {
                    h = Uh(n, i, !1),
                    g = !1;
                    continue
                }
                if (h === 2) {
                    if (g = i,
                    n.errorRecoveryDisabledLanes & g)
                        var S = 0;
                    else
                        S = n.pendingLanes & -536870913,
                        S = S !== 0 ? S : S & 536870912 ? 536870912 : 0;
                    if (S !== 0) {
                        i = S;
                        e: {
                            var C = n;
                            h = Fa;
                            var D = C.current.memoizedState.isDehydrated;
                            if (D && (Ao(C, S).flags |= 256),
                            S = Uh(C, S, !1),
                            S !== 2) {
                                if (wh && !D) {
                                    C.errorRecoveryDisabledLanes |= g,
                                    Ts |= g,
                                    h = 4;
                                    break e
                                }
                                g = rn,
                                rn = h,
                                g !== null && (rn === null ? rn = g : rn.push.apply(rn, g))
                            }
                            h = S
                        }
                        if (g = !1,
                        h !== 2)
                            continue
                    }
                }
                if (h === 1) {
                    Ao(n, 0),
                    mr(n, i, 0, !0);
                    break
                }
                e: {
                    switch (u = n,
                    g = h,
                    g) {
                    case 0:
                    case 1:
                        throw Error(s(345));
                    case 4:
                        if ((i & 4194048) !== i)
                            break;
                    case 6:
                        mr(u, i, Mn, !fr);
                        break e;
                    case 2:
                        rn = null;
                        break;
                    case 3:
                    case 5:
                        break;
                    default:
                        throw Error(s(329))
                    }
                    if ((i & 62914560) === i && (h = Mh + 300 - _n(),
                    10 < h)) {
                        if (mr(u, i, Mn, !fr),
                        Bs(u, 0, !0) !== 0)
                            break e;
                        u.timeoutHandle = Cy(Jg.bind(null, u, a, rn, ku, Dh, i, Mn, Ts, To, fr, g, 2, -0, 0), h);
                        break e
                    }
                    Jg(u, a, rn, ku, Dh, i, Mn, Ts, To, fr, g, 0, -0, 0)
                }
            }
            break
        } while (!0);
        oi(n)
    }
    function Jg(n, i, a, u, h, g, S, C, D, H, $, W, Y, K) {
        if (n.timeoutHandle = -1,
        W = i.subtreeFlags,
        (W & 8192 || (W & 16785408) === 16785408) && (Ja = {
            stylesheets: null,
            count: 0,
            unsuspend: jS
        },
        Hg(i),
        W = ZS(),
        W !== null)) {
            n.cancelPendingCommit = W(iy.bind(null, n, i, g, a, u, h, S, C, D, $, 1, Y, K)),
            mr(n, g, S, !H);
            return
        }
        iy(n, i, g, a, u, h, S, C, D)
    }
    function gS(n) {
        for (var i = n; ; ) {
            var a = i.tag;
            if ((a === 0 || a === 11 || a === 15) && i.flags & 16384 && (a = i.updateQueue,
            a !== null && (a = a.stores,
            a !== null)))
                for (var u = 0; u < a.length; u++) {
                    var h = a[u]
                      , g = h.getSnapshot;
                    h = h.value;
                    try {
                        if (!cn(g(), h))
                            return !1
                    } catch {
                        return !1
                    }
                }
            if (a = i.child,
            i.subtreeFlags & 16384 && a !== null)
                a.return = i,
                i = a;
            else {
                if (i === n)
                    break;
                for (; i.sibling === null; ) {
                    if (i.return === null || i.return === n)
                        return !0;
                    i = i.return
                }
                i.sibling.return = i.return,
                i = i.sibling
            }
        }
        return !0
    }
    function mr(n, i, a, u) {
        i &= ~bh,
        i &= ~Ts,
        n.suspendedLanes |= i,
        n.pingedLanes &= ~i,
        u && (n.warmLanes |= i),
        u = n.expirationTimes;
        for (var h = i; 0 < h; ) {
            var g = 31 - Ht(h)
              , S = 1 << g;
            u[g] = -1,
            h &= ~S
        }
        a !== 0 && Yn(n, a, i)
    }
    function Lu() {
        return (He & 6) === 0 ? (Ga(0),
        !1) : !0
    }
    function Oh() {
        if (Me !== null) {
            if (Ge === 0)
                var n = Me.return;
            else
                n = Me,
                wi = ps = null,
                jf(n),
                mo = null,
                Oa = 0,
                n = Me;
            for (; n !== null; )
                Dg(n.alternate, n),
                n = n.return;
            Me = null
        }
    }
    function Ao(n, i) {
        var a = n.timeoutHandle;
        a !== -1 && (n.timeoutHandle = -1,
        OS(a)),
        a = n.cancelPendingCommit,
        a !== null && (n.cancelPendingCommit = null,
        a()),
        Oh(),
        Ze = n,
        Me = a = Ci(n.current, null),
        Ve = i,
        Ge = 0,
        pn = null,
        fr = !1,
        _o = Kr(n, i),
        wh = !1,
        To = Mn = bh = Ts = hr = at = 0,
        rn = Fa = null,
        Dh = !1,
        (i & 8) !== 0 && (i |= i & 32);
        var u = n.entangledLanes;
        if (u !== 0)
            for (n = n.entanglements,
            u &= i; 0 < u; ) {
                var h = 31 - Ht(u)
                  , g = 1 << h;
                i |= n[h],
                u &= ~g
            }
        return Vi = i,
        ou(),
        a
    }
    function jg(n, i) {
        Ce = null,
        X.H = Ru,
        i === Ra || i === mu ? (i = pm(),
        Ge = 3) : i === fm ? (i = pm(),
        Ge = 4) : Ge = i === mg ? 8 : i !== null && typeof i == "object" && typeof i.then == "function" ? 6 : 1,
        pn = i,
        Me === null && (at = 1,
        Mu(n, Rn(i, n.current)))
    }
    function Wg() {
        var n = X.H;
        return X.H = Ru,
        n === null ? Ru : n
    }
    function Zg() {
        var n = X.A;
        return X.A = pS,
        n
    }
    function Vh() {
        at = 4,
        fr || (Ve & 4194048) !== Ve && Dn.current !== null || (_o = !0),
        (hr & 134217727) === 0 && (Ts & 134217727) === 0 || Ze === null || mr(Ze, Ve, Mn, !1)
    }
    function Uh(n, i, a) {
        var u = He;
        He |= 2;
        var h = Wg()
          , g = Zg();
        (Ze !== n || Ve !== i) && (ku = null,
        Ao(n, i)),
        i = !1;
        var S = at;
        e: do
            try {
                if (Ge !== 0 && Me !== null) {
                    var C = Me
                      , D = pn;
                    switch (Ge) {
                    case 8:
                        Oh(),
                        S = 6;
                        break e;
                    case 3:
                    case 2:
                    case 9:
                    case 6:
                        Dn.current === null && (i = !0);
                        var H = Ge;
                        if (Ge = 0,
                        pn = null,
                        Co(n, C, D, H),
                        a && _o) {
                            S = 0;
                            break e
                        }
                        break;
                    default:
                        H = Ge,
                        Ge = 0,
                        pn = null,
                        Co(n, C, D, H)
                    }
                }
                yS(),
                S = at;
                break
            } catch ($) {
                jg(n, $)
            }
        while (!0);
        return i && n.shellSuspendCounter++,
        wi = ps = null,
        He = u,
        X.H = h,
        X.A = g,
        Me === null && (Ze = null,
        Ve = 0,
        ou()),
        S
    }
    function yS() {
        for (; Me !== null; )
            ey(Me)
    }
    function vS(n, i) {
        var a = He;
        He |= 2;
        var u = Wg()
          , h = Zg();
        Ze !== n || Ve !== i ? (ku = null,
        Uu = _n() + 500,
        Ao(n, i)) : _o = Kr(n, i);
        e: do
            try {
                if (Ge !== 0 && Me !== null) {
                    i = Me;
                    var g = pn;
                    t: switch (Ge) {
                    case 1:
                        Ge = 0,
                        pn = null,
                        Co(n, i, g, 1);
                        break;
                    case 2:
                    case 9:
                        if (hm(g)) {
                            Ge = 0,
                            pn = null,
                            ty(i);
                            break
                        }
                        i = function() {
                            Ge !== 2 && Ge !== 9 || Ze !== n || (Ge = 7),
                            oi(n)
                        }
                        ,
                        g.then(i, i);
                        break e;
                    case 3:
                        Ge = 7;
                        break e;
                    case 4:
                        Ge = 5;
                        break e;
                    case 7:
                        hm(g) ? (Ge = 0,
                        pn = null,
                        ty(i)) : (Ge = 0,
                        pn = null,
                        Co(n, i, g, 7));
                        break;
                    case 5:
                        var S = null;
                        switch (Me.tag) {
                        case 26:
                            S = Me.memoizedState;
                        case 5:
                        case 27:
                            var C = Me;
                            if (!S || Uy(S)) {
                                Ge = 0,
                                pn = null;
                                var D = C.sibling;
                                if (D !== null)
                                    Me = D;
                                else {
                                    var H = C.return;
                                    H !== null ? (Me = H,
                                    Bu(H)) : Me = null
                                }
                                break t
                            }
                        }
                        Ge = 0,
                        pn = null,
                        Co(n, i, g, 5);
                        break;
                    case 6:
                        Ge = 0,
                        pn = null,
                        Co(n, i, g, 6);
                        break;
                    case 8:
                        Oh(),
                        at = 6;
                        break e;
                    default:
                        throw Error(s(462))
                    }
                }
                _S();
                break
            } catch ($) {
                jg(n, $)
            }
        while (!0);
        return wi = ps = null,
        X.H = u,
        X.A = h,
        He = a,
        Me !== null ? 0 : (Ze = null,
        Ve = 0,
        ou(),
        at)
    }
    function _S() {
        for (; Me !== null && !Xo(); )
            ey(Me)
    }
    function ey(n) {
        var i = wg(n.alternate, n, Vi);
        n.memoizedProps = n.pendingProps,
        i === null ? Bu(n) : Me = i
    }
    function ty(n) {
        var i = n
          , a = i.alternate;
        switch (i.tag) {
        case 15:
        case 0:
            i = Eg(a, i, i.pendingProps, i.type, void 0, Ve);
            break;
        case 11:
            i = Eg(a, i, i.pendingProps, i.type.render, i.ref, Ve);
            break;
        case 5:
            jf(i);
        default:
            Dg(a, i),
            i = Me = nm(i, Vi),
            i = wg(a, i, Vi)
        }
        n.memoizedProps = n.pendingProps,
        i === null ? Bu(n) : Me = i
    }
    function Co(n, i, a, u) {
        wi = ps = null,
        jf(i),
        mo = null,
        Oa = 0;
        var h = i.return;
        try {
            if (lS(n, h, i, a, Ve)) {
                at = 1,
                Mu(n, Rn(a, n.current)),
                Me = null;
                return
            }
        } catch (g) {
            if (h !== null)
                throw Me = h,
                g;
            at = 1,
            Mu(n, Rn(a, n.current)),
            Me = null;
            return
        }
        i.flags & 32768 ? (qe || u === 1 ? n = !0 : _o || (Ve & 536870912) !== 0 ? n = !1 : (fr = n = !0,
        (u === 2 || u === 9 || u === 3 || u === 6) && (u = Dn.current,
        u !== null && u.tag === 13 && (u.flags |= 16384))),
        ny(i, n)) : Bu(i)
    }
    function Bu(n) {
        var i = n;
        do {
            if ((i.flags & 32768) !== 0) {
                ny(i, fr);
                return
            }
            n = i.return;
            var a = cS(i.alternate, i, Vi);
            if (a !== null) {
                Me = a;
                return
            }
            if (i = i.sibling,
            i !== null) {
                Me = i;
                return
            }
            Me = i = n
        } while (i !== null);
        at === 0 && (at = 5)
    }
    function ny(n, i) {
        do {
            var a = fS(n.alternate, n);
            if (a !== null) {
                a.flags &= 32767,
                Me = a;
                return
            }
            if (a = n.return,
            a !== null && (a.flags |= 32768,
            a.subtreeFlags = 0,
            a.deletions = null),
            !i && (n = n.sibling,
            n !== null)) {
                Me = n;
                return
            }
            Me = n = a
        } while (n !== null);
        at = 6,
        Me = null
    }
    function iy(n, i, a, u, h, g, S, C, D) {
        n.cancelPendingCommit = null;
        do
            qu();
        while (kt !== 0);
        if ((He & 6) !== 0)
            throw Error(s(327));
        if (i !== null) {
            if (i === n.current)
                throw Error(s(177));
            if (g = i.lanes | i.childLanes,
            g |= If,
            ea(n, a, g, S, C, D),
            n === Ze && (Me = Ze = null,
            Ve = 0),
            Eo = i,
            pr = n,
            So = a,
            Nh = g,
            xh = h,
            Qg = u,
            (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0 ? (n.callbackNode = null,
            n.callbackPriority = 0,
            AS(Fr, function() {
                return ly(),
                null
            })) : (n.callbackNode = null,
            n.callbackPriority = 0),
            u = (i.flags & 13878) !== 0,
            (i.subtreeFlags & 13878) !== 0 || u) {
                u = X.T,
                X.T = null,
                h = oe.p,
                oe.p = 2,
                S = He,
                He |= 4;
                try {
                    hS(n, i, a)
                } finally {
                    He = S,
                    oe.p = h,
                    X.T = u
                }
            }
            kt = 1,
            ry(),
            sy(),
            oy()
        }
    }
    function ry() {
        if (kt === 1) {
            kt = 0;
            var n = pr
              , i = Eo
              , a = (i.flags & 13878) !== 0;
            if ((i.subtreeFlags & 13878) !== 0 || a) {
                a = X.T,
                X.T = null;
                var u = oe.p;
                oe.p = 2;
                var h = He;
                He |= 4;
                try {
                    qg(i, n);
                    var g = Xh
                      , S = Kp(n.containerInfo)
                      , C = g.focusedElem
                      , D = g.selectionRange;
                    if (S !== C && C && C.ownerDocument && Yp(C.ownerDocument.documentElement, C)) {
                        if (D !== null && Ef(C)) {
                            var H = D.start
                              , $ = D.end;
                            if ($ === void 0 && ($ = H),
                            "selectionStart"in C)
                                C.selectionStart = H,
                                C.selectionEnd = Math.min($, C.value.length);
                            else {
                                var W = C.ownerDocument || document
                                  , Y = W && W.defaultView || window;
                                if (Y.getSelection) {
                                    var K = Y.getSelection()
                                      , _e = C.textContent.length
                                      , ge = Math.min(D.start, _e)
                                      , Xe = D.end === void 0 ? ge : Math.min(D.end, _e);
                                    !K.extend && ge > Xe && (S = Xe,
                                    Xe = ge,
                                    ge = S);
                                    var L = Gp(C, ge)
                                      , O = Gp(C, Xe);
                                    if (L && O && (K.rangeCount !== 1 || K.anchorNode !== L.node || K.anchorOffset !== L.offset || K.focusNode !== O.node || K.focusOffset !== O.offset)) {
                                        var F = W.createRange();
                                        F.setStart(L.node, L.offset),
                                        K.removeAllRanges(),
                                        ge > Xe ? (K.addRange(F),
                                        K.extend(O.node, O.offset)) : (F.setEnd(O.node, O.offset),
                                        K.addRange(F))
                                    }
                                }
                            }
                        }
                        for (W = [],
                        K = C; K = K.parentNode; )
                            K.nodeType === 1 && W.push({
                                element: K,
                                left: K.scrollLeft,
                                top: K.scrollTop
                            });
                        for (typeof C.focus == "function" && C.focus(),
                        C = 0; C < W.length; C++) {
                            var j = W[C];
                            j.element.scrollLeft = j.left,
                            j.element.scrollTop = j.top
                        }
                    }
                    Wu = !!Qh,
                    Xh = Qh = null
                } finally {
                    He = h,
                    oe.p = u,
                    X.T = a
                }
            }
            n.current = i,
            kt = 2
        }
    }
    function sy() {
        if (kt === 2) {
            kt = 0;
            var n = pr
              , i = Eo
              , a = (i.flags & 8772) !== 0;
            if ((i.subtreeFlags & 8772) !== 0 || a) {
                a = X.T,
                X.T = null;
                var u = oe.p;
                oe.p = 2;
                var h = He;
                He |= 4;
                try {
                    Ug(n, i.alternate, i)
                } finally {
                    He = h,
                    oe.p = u,
                    X.T = a
                }
            }
            kt = 3
        }
    }
    function oy() {
        if (kt === 4 || kt === 3) {
            kt = 0,
            Vl();
            var n = pr
              , i = Eo
              , a = So
              , u = Qg;
            (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0 ? kt = 5 : (kt = 0,
            Eo = pr = null,
            ay(n, n.pendingLanes));
            var h = n.pendingLanes;
            if (h === 0 && (dr = null),
            qs(a),
            i = i.stateNode,
            Fe && typeof Fe.onCommitFiberRoot == "function")
                try {
                    Fe.onCommitFiberRoot(st, i, void 0, (i.current.flags & 128) === 128)
                } catch {}
            if (u !== null) {
                i = X.T,
                h = oe.p,
                oe.p = 2,
                X.T = null;
                try {
                    for (var g = n.onRecoverableError, S = 0; S < u.length; S++) {
                        var C = u[S];
                        g(C.value, {
                            componentStack: C.stack
                        })
                    }
                } finally {
                    X.T = i,
                    oe.p = h
                }
            }
            (So & 3) !== 0 && qu(),
            oi(n),
            h = n.pendingLanes,
            (a & 4194090) !== 0 && (h & 42) !== 0 ? n === Ph ? Ha++ : (Ha = 0,
            Ph = n) : Ha = 0,
            Ga(0)
        }
    }
    function ay(n, i) {
        (n.pooledCacheLanes &= i) === 0 && (i = n.pooledCache,
        i != null && (n.pooledCache = null,
        Aa(i)))
    }
    function qu(n) {
        return ry(),
        sy(),
        oy(),
        ly()
    }
    function ly() {
        if (kt !== 5)
            return !1;
        var n = pr
          , i = Nh;
        Nh = 0;
        var a = qs(So)
          , u = X.T
          , h = oe.p;
        try {
            oe.p = 32 > a ? 32 : a,
            X.T = null,
            a = xh,
            xh = null;
            var g = pr
              , S = So;
            if (kt = 0,
            Eo = pr = null,
            So = 0,
            (He & 6) !== 0)
                throw Error(s(331));
            var C = He;
            if (He |= 4,
            Yg(g.current),
            Fg(g, g.current, S, a),
            He = C,
            Ga(0, !1),
            Fe && typeof Fe.onPostCommitFiberRoot == "function")
                try {
                    Fe.onPostCommitFiberRoot(st, g)
                } catch {}
            return !0
        } finally {
            oe.p = h,
            X.T = u,
            ay(n, i)
        }
    }
    function uy(n, i, a) {
        i = Rn(a, i),
        i = fh(n.stateNode, i, 2),
        n = rr(n, i, 2),
        n !== null && (di(n, 2),
        oi(n))
    }
    function Je(n, i, a) {
        if (n.tag === 3)
            uy(n, n, a);
        else
            for (; i !== null; ) {
                if (i.tag === 3) {
                    uy(i, n, a);
                    break
                } else if (i.tag === 1) {
                    var u = i.stateNode;
                    if (typeof i.type.getDerivedStateFromError == "function" || typeof u.componentDidCatch == "function" && (dr === null || !dr.has(u))) {
                        n = Rn(a, n),
                        a = dg(2),
                        u = rr(i, a, 2),
                        u !== null && (pg(a, u, i, n),
                        di(u, 2),
                        oi(u));
                        break
                    }
                }
                i = i.return
            }
    }
    function kh(n, i, a) {
        var u = n.pingCache;
        if (u === null) {
            u = n.pingCache = new mS;
            var h = new Set;
            u.set(i, h)
        } else
            h = u.get(i),
            h === void 0 && (h = new Set,
            u.set(i, h));
        h.has(a) || (wh = !0,
        h.add(a),
        n = TS.bind(null, n, i, a),
        i.then(n, n))
    }
    function TS(n, i, a) {
        var u = n.pingCache;
        u !== null && u.delete(i),
        n.pingedLanes |= n.suspendedLanes & a,
        n.warmLanes &= ~a,
        Ze === n && (Ve & a) === a && (at === 4 || at === 3 && (Ve & 62914560) === Ve && 300 > _n() - Mh ? (He & 2) === 0 && Ao(n, 0) : bh |= a,
        To === Ve && (To = 0)),
        oi(n)
    }
    function cy(n, i) {
        i === 0 && (i = Zo()),
        n = ro(n, i),
        n !== null && (di(n, i),
        oi(n))
    }
    function ES(n) {
        var i = n.memoizedState
          , a = 0;
        i !== null && (a = i.retryLane),
        cy(n, a)
    }
    function SS(n, i) {
        var a = 0;
        switch (n.tag) {
        case 13:
            var u = n.stateNode
              , h = n.memoizedState;
            h !== null && (a = h.retryLane);
            break;
        case 19:
            u = n.stateNode;
            break;
        case 22:
            u = n.stateNode._retryCache;
            break;
        default:
            throw Error(s(314))
        }
        u !== null && u.delete(i),
        cy(n, a)
    }
    function AS(n, i) {
        return qr(n, i)
    }
    var zu = null
      , Ro = null
      , Lh = !1
      , Fu = !1
      , Bh = !1
      , Es = 0;
    function oi(n) {
        n !== Ro && n.next === null && (Ro === null ? zu = Ro = n : Ro = Ro.next = n),
        Fu = !0,
        Lh || (Lh = !0,
        RS())
    }
    function Ga(n, i) {
        if (!Bh && Fu) {
            Bh = !0;
            do
                for (var a = !1, u = zu; u !== null; ) {
                    if (n !== 0) {
                        var h = u.pendingLanes;
                        if (h === 0)
                            var g = 0;
                        else {
                            var S = u.suspendedLanes
                              , C = u.pingedLanes;
                            g = (1 << 31 - Ht(42 | n) + 1) - 1,
                            g &= h & ~(S & ~C),
                            g = g & 201326741 ? g & 201326741 | 1 : g ? g | 2 : 0
                        }
                        g !== 0 && (a = !0,
                        py(u, g))
                    } else
                        g = Ve,
                        g = Bs(u, u === Ze ? g : 0, u.cancelPendingCommit !== null || u.timeoutHandle !== -1),
                        (g & 3) === 0 || Kr(u, g) || (a = !0,
                        py(u, g));
                    u = u.next
                }
            while (a);
            Bh = !1
        }
    }
    function CS() {
        fy()
    }
    function fy() {
        Fu = Lh = !1;
        var n = 0;
        Es !== 0 && (PS() && (n = Es),
        Es = 0);
        for (var i = _n(), a = null, u = zu; u !== null; ) {
            var h = u.next
              , g = hy(u, i);
            g === 0 ? (u.next = null,
            a === null ? zu = h : a.next = h,
            h === null && (Ro = a)) : (a = u,
            (n !== 0 || (g & 3) !== 0) && (Fu = !0)),
            u = h
        }
        Ga(n)
    }
    function hy(n, i) {
        for (var a = n.suspendedLanes, u = n.pingedLanes, h = n.expirationTimes, g = n.pendingLanes & -62914561; 0 < g; ) {
            var S = 31 - Ht(g)
              , C = 1 << S
              , D = h[S];
            D === -1 ? ((C & a) === 0 || (C & u) !== 0) && (h[S] = jo(C, i)) : D <= i && (n.expiredLanes |= C),
            g &= ~C
        }
        if (i = Ze,
        a = Ve,
        a = Bs(n, n === i ? a : 0, n.cancelPendingCommit !== null || n.timeoutHandle !== -1),
        u = n.callbackNode,
        a === 0 || n === i && (Ge === 2 || Ge === 9) || n.cancelPendingCommit !== null)
            return u !== null && u !== null && zr(u),
            n.callbackNode = null,
            n.callbackPriority = 0;
        if ((a & 3) === 0 || Kr(n, a)) {
            if (i = a & -a,
            i === n.callbackPriority)
                return i;
            switch (u !== null && zr(u),
            qs(a)) {
            case 2:
            case 8:
                a = ks;
                break;
            case 32:
                a = Fr;
                break;
            case 268435456:
                a = Ls;
                break;
            default:
                a = Fr
            }
            return u = dy.bind(null, n),
            a = qr(a, u),
            n.callbackPriority = i,
            n.callbackNode = a,
            i
        }
        return u !== null && u !== null && zr(u),
        n.callbackPriority = 2,
        n.callbackNode = null,
        2
    }
    function dy(n, i) {
        if (kt !== 0 && kt !== 5)
            return n.callbackNode = null,
            n.callbackPriority = 0,
            null;
        var a = n.callbackNode;
        if (qu() && n.callbackNode !== a)
            return null;
        var u = Ve;
        return u = Bs(n, n === Ze ? u : 0, n.cancelPendingCommit !== null || n.timeoutHandle !== -1),
        u === 0 ? null : ($g(n, u, i),
        hy(n, _n()),
        n.callbackNode != null && n.callbackNode === a ? dy.bind(null, n) : null)
    }
    function py(n, i) {
        if (qu())
            return null;
        $g(n, i, !0)
    }
    function RS() {
        VS(function() {
            (He & 6) !== 0 ? qr($o, CS) : fy()
        })
    }
    function qh() {
        return Es === 0 && (Es = Wo()),
        Es
    }
    function my(n) {
        return n == null || typeof n == "symbol" || typeof n == "boolean" ? null : typeof n == "function" ? n : Ks("" + n)
    }
    function gy(n, i) {
        var a = i.ownerDocument.createElement("input");
        return a.name = i.name,
        a.value = i.value,
        n.id && a.setAttribute("form", n.id),
        i.parentNode.insertBefore(a, i),
        n = new FormData(n),
        a.parentNode.removeChild(a),
        n
    }
    function IS(n, i, a, u, h) {
        if (i === "submit" && a && a.stateNode === h) {
            var g = my((h[pt] || null).action)
              , S = u.submitter;
            S && (i = (i = S[pt] || null) ? my(i.formAction) : S.getAttribute("formAction"),
            i !== null && (g = i,
            S = null));
            var C = new Qs("action","action",null,u,h);
            n.push({
                event: C,
                listeners: [{
                    instance: null,
                    listener: function() {
                        if (u.defaultPrevented) {
                            if (Es !== 0) {
                                var D = S ? gy(h, S) : new FormData(h);
                                oh(a, {
                                    pending: !0,
                                    data: D,
                                    method: h.method,
                                    action: g
                                }, null, D)
                            }
                        } else
                            typeof g == "function" && (C.preventDefault(),
                            D = S ? gy(h, S) : new FormData(h),
                            oh(a, {
                                pending: !0,
                                data: D,
                                method: h.method,
                                action: g
                            }, g, D))
                    },
                    currentTarget: h
                }]
            })
        }
    }
    for (var zh = 0; zh < Rf.length; zh++) {
        var Fh = Rf[zh]
          , wS = Fh.toLowerCase()
          , bS = Fh[0].toUpperCase() + Fh.slice(1);
        Un(wS, "on" + bS)
    }
    Un($p, "onAnimationEnd"),
    Un(Jp, "onAnimationIteration"),
    Un(jp, "onAnimationStart"),
    Un("dblclick", "onDoubleClick"),
    Un("focusin", "onFocus"),
    Un("focusout", "onBlur"),
    Un(Y0, "onTransitionRun"),
    Un(K0, "onTransitionStart"),
    Un(Q0, "onTransitionCancel"),
    Un(Wp, "onTransitionEnd"),
    mi("onMouseEnter", ["mouseout", "mouseover"]),
    mi("onMouseLeave", ["mouseout", "mouseover"]),
    mi("onPointerEnter", ["pointerout", "pointerover"]),
    mi("onPointerLeave", ["pointerout", "pointerover"]),
    On("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
    On("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
    On("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    On("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
    On("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
    On("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var Ya = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
      , DS = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Ya));
    function yy(n, i) {
        i = (i & 4) !== 0;
        for (var a = 0; a < n.length; a++) {
            var u = n[a]
              , h = u.event;
            u = u.listeners;
            e: {
                var g = void 0;
                if (i)
                    for (var S = u.length - 1; 0 <= S; S--) {
                        var C = u[S]
                          , D = C.instance
                          , H = C.currentTarget;
                        if (C = C.listener,
                        D !== g && h.isPropagationStopped())
                            break e;
                        g = C,
                        h.currentTarget = H;
                        try {
                            g(h)
                        } catch ($) {
                            Du($)
                        }
                        h.currentTarget = null,
                        g = D
                    }
                else
                    for (S = 0; S < u.length; S++) {
                        if (C = u[S],
                        D = C.instance,
                        H = C.currentTarget,
                        C = C.listener,
                        D !== g && h.isPropagationStopped())
                            break e;
                        g = C,
                        h.currentTarget = H;
                        try {
                            g(h)
                        } catch ($) {
                            Du($)
                        }
                        h.currentTarget = null,
                        g = D
                    }
            }
        }
    }
    function Ne(n, i) {
        var a = i[na];
        a === void 0 && (a = i[na] = new Set);
        var u = n + "__bubble";
        a.has(u) || (vy(i, n, 2, !1),
        a.add(u))
    }
    function Hh(n, i, a) {
        var u = 0;
        i && (u |= 4),
        vy(a, n, u, i)
    }
    var Hu = "_reactListening" + Math.random().toString(36).slice(2);
    function Gh(n) {
        if (!n[Hu]) {
            n[Hu] = !0,
            ia.forEach(function(a) {
                a !== "selectionchange" && (DS.has(a) || Hh(a, !1, n),
                Hh(a, !0, n))
            });
            var i = n.nodeType === 9 ? n : n.ownerDocument;
            i === null || i[Hu] || (i[Hu] = !0,
            Hh("selectionchange", !1, i))
        }
    }
    function vy(n, i, a, u) {
        switch (Fy(i)) {
        case 2:
            var h = nA;
            break;
        case 8:
            h = iA;
            break;
        default:
            h = rd
        }
        a = h.bind(null, i, a, n),
        h = void 0,
        !An || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (h = !0),
        u ? h !== void 0 ? n.addEventListener(i, a, {
            capture: !0,
            passive: h
        }) : n.addEventListener(i, a, !0) : h !== void 0 ? n.addEventListener(i, a, {
            passive: h
        }) : n.addEventListener(i, a, !1)
    }
    function Yh(n, i, a, u, h) {
        var g = u;
        if ((i & 1) === 0 && (i & 2) === 0 && u !== null)
            e: for (; ; ) {
                if (u === null)
                    return;
                var S = u.tag;
                if (S === 3 || S === 4) {
                    var C = u.stateNode.containerInfo;
                    if (C === h)
                        break;
                    if (S === 4)
                        for (S = u.return; S !== null; ) {
                            var D = S.tag;
                            if ((D === 3 || D === 4) && S.stateNode.containerInfo === h)
                                return;
                            S = S.return
                        }
                    for (; C !== null; ) {
                        if (S = pi(C),
                        S === null)
                            return;
                        if (D = S.tag,
                        D === 5 || D === 6 || D === 26 || D === 27) {
                            u = g = S;
                            continue e
                        }
                        C = C.parentNode
                    }
                }
                u = u.return
            }
        Yl(function() {
            var H = g
              , $ = Sn(a)
              , W = [];
            e: {
                var Y = Zp.get(n);
                if (Y !== void 0) {
                    var K = Qs
                      , _e = n;
                    switch (n) {
                    case "keypress":
                        if (jn(a) === 0)
                            break e;
                    case "keydown":
                    case "keyup":
                        K = Zs;
                        break;
                    case "focusin":
                        _e = "focus",
                        K = Js;
                        break;
                    case "focusout":
                        _e = "blur",
                        K = Js;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        K = Js;
                        break;
                    case "click":
                        if (a.button === 2)
                            break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        K = Cn;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        K = yf;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        K = Zl;
                        break;
                    case $p:
                    case Jp:
                    case jp:
                        K = js;
                        break;
                    case Wp:
                        K = tu;
                        break;
                    case "scroll":
                    case "scrollend":
                        K = Kl;
                        break;
                    case "wheel":
                        K = eo;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        K = Ws;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        K = ma;
                        break;
                    case "toggle":
                    case "beforetoggle":
                        K = iu
                    }
                    var ge = (i & 4) !== 0
                      , Xe = !ge && (n === "scroll" || n === "scrollend")
                      , L = ge ? Y !== null ? Y + "Capture" : null : Y;
                    ge = [];
                    for (var O = H, F; O !== null; ) {
                        var j = O;
                        if (F = j.stateNode,
                        j = j.tag,
                        j !== 5 && j !== 26 && j !== 27 || F === null || L === null || (j = es(O, L),
                        j != null && ge.push(Ka(O, j, F))),
                        Xe)
                            break;
                        O = O.return
                    }
                    0 < ge.length && (Y = new K(Y,_e,null,a,$),
                    W.push({
                        event: Y,
                        listeners: ge
                    }))
                }
            }
            if ((i & 7) === 0) {
                e: {
                    if (Y = n === "mouseover" || n === "pointerover",
                    K = n === "mouseout" || n === "pointerout",
                    Y && a !== vi && (_e = a.relatedTarget || a.fromElement) && (pi(_e) || _e[Tn]))
                        break e;
                    if ((K || Y) && (Y = $.window === $ ? $ : (Y = $.ownerDocument) ? Y.defaultView || Y.parentWindow : window,
                    K ? (_e = a.relatedTarget || a.toElement,
                    K = H,
                    _e = _e ? pi(_e) : null,
                    _e !== null && (Xe = l(_e),
                    ge = _e.tag,
                    _e !== Xe || ge !== 5 && ge !== 27 && ge !== 6) && (_e = null)) : (K = null,
                    _e = H),
                    K !== _e)) {
                        if (ge = Cn,
                        j = "onMouseLeave",
                        L = "onMouseEnter",
                        O = "mouse",
                        (n === "pointerout" || n === "pointerover") && (ge = ma,
                        j = "onPointerLeave",
                        L = "onPointerEnter",
                        O = "pointer"),
                        Xe = K == null ? Y : Qn(K),
                        F = _e == null ? Y : Qn(_e),
                        Y = new ge(j,O + "leave",K,a,$),
                        Y.target = Xe,
                        Y.relatedTarget = F,
                        j = null,
                        pi($) === H && (ge = new ge(L,O + "enter",_e,a,$),
                        ge.target = F,
                        ge.relatedTarget = Xe,
                        j = ge),
                        Xe = j,
                        K && _e)
                            t: {
                                for (ge = K,
                                L = _e,
                                O = 0,
                                F = ge; F; F = Io(F))
                                    O++;
                                for (F = 0,
                                j = L; j; j = Io(j))
                                    F++;
                                for (; 0 < O - F; )
                                    ge = Io(ge),
                                    O--;
                                for (; 0 < F - O; )
                                    L = Io(L),
                                    F--;
                                for (; O--; ) {
                                    if (ge === L || L !== null && ge === L.alternate)
                                        break t;
                                    ge = Io(ge),
                                    L = Io(L)
                                }
                                ge = null
                            }
                        else
                            ge = null;
                        K !== null && _y(W, Y, K, ge, !1),
                        _e !== null && Xe !== null && _y(W, Xe, _e, ge, !0)
                    }
                }
                e: {
                    if (Y = H ? Qn(H) : window,
                    K = Y.nodeName && Y.nodeName.toLowerCase(),
                    K === "select" || K === "input" && Y.type === "file")
                        var ce = Lp;
                    else if (St(Y))
                        if (Bp)
                            ce = F0;
                        else {
                            ce = q0;
                            var be = B0
                        }
                    else
                        K = Y.nodeName,
                        !K || K.toLowerCase() !== "input" || Y.type !== "checkbox" && Y.type !== "radio" ? H && la(H.elementType) && (ce = Lp) : ce = z0;
                    if (ce && (ce = ce(n, H))) {
                        Ai(W, ce, a, $);
                        break e
                    }
                    be && be(n, Y, H),
                    n === "focusout" && H && Y.type === "number" && H.memoizedProps.value != null && Zi(Y, "number", Y.value)
                }
                switch (be = H ? Qn(H) : window,
                n) {
                case "focusin":
                    (St(be) || be.contentEditable === "true") && (to = be,
                    Sf = H,
                    va = null);
                    break;
                case "focusout":
                    va = Sf = to = null;
                    break;
                case "mousedown":
                    Af = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    Af = !1,
                    Qp(W, a, $);
                    break;
                case "selectionchange":
                    if (G0)
                        break;
                case "keydown":
                case "keyup":
                    Qp(W, a, $)
                }
                var de;
                if (ei)
                    e: {
                        switch (n) {
                        case "compositionstart":
                            var ye = "onCompositionStart";
                            break e;
                        case "compositionend":
                            ye = "onCompositionEnd";
                            break e;
                        case "compositionupdate":
                            ye = "onCompositionUpdate";
                            break e
                        }
                        ye = void 0
                    }
                else
                    Pe ? Q(n, a) && (ye = "onCompositionEnd") : n === "keydown" && a.keyCode === 229 && (ye = "onCompositionStart");
                ye && (E && a.locale !== "ko" && (Pe || ye !== "onCompositionStart" ? ye === "onCompositionEnd" && Pe && (de = ca()) : (Jn = $,
                er = "value"in Jn ? Jn.value : Jn.textContent,
                Pe = !0)),
                be = Gu(H, ye),
                0 < be.length && (ye = new da(ye,n,null,a,$),
                W.push({
                    event: ye,
                    listeners: be
                }),
                de ? ye.data = de : (de = re(a),
                de !== null && (ye.data = de)))),
                (de = _ ? Et(n, a) : Oe(n, a)) && (ye = Gu(H, "onBeforeInput"),
                0 < ye.length && (be = new da("onBeforeInput","beforeinput",null,a,$),
                W.push({
                    event: be,
                    listeners: ye
                }),
                be.data = de)),
                IS(W, n, H, a, $)
            }
            yy(W, i)
        })
    }
    function Ka(n, i, a) {
        return {
            instance: n,
            listener: i,
            currentTarget: a
        }
    }
    function Gu(n, i) {
        for (var a = i + "Capture", u = []; n !== null; ) {
            var h = n
              , g = h.stateNode;
            if (h = h.tag,
            h !== 5 && h !== 26 && h !== 27 || g === null || (h = es(n, a),
            h != null && u.unshift(Ka(n, h, g)),
            h = es(n, i),
            h != null && u.push(Ka(n, h, g))),
            n.tag === 3)
                return u;
            n = n.return
        }
        return []
    }
    function Io(n) {
        if (n === null)
            return null;
        do
            n = n.return;
        while (n && n.tag !== 5 && n.tag !== 27);
        return n || null
    }
    function _y(n, i, a, u, h) {
        for (var g = i._reactName, S = []; a !== null && a !== u; ) {
            var C = a
              , D = C.alternate
              , H = C.stateNode;
            if (C = C.tag,
            D !== null && D === u)
                break;
            C !== 5 && C !== 26 && C !== 27 || H === null || (D = H,
            h ? (H = es(a, g),
            H != null && S.unshift(Ka(a, H, D))) : h || (H = es(a, g),
            H != null && S.push(Ka(a, H, D)))),
            a = a.return
        }
        S.length !== 0 && n.push({
            event: i,
            listeners: S
        })
    }
    var MS = /\r\n?/g
      , NS = /\u0000|\uFFFD/g;
    function Ty(n) {
        return (typeof n == "string" ? n : "" + n).replace(MS, `
`).replace(NS, "")
    }
    function Ey(n, i) {
        return i = Ty(i),
        Ty(n) === i
    }
    function Yu() {}
    function Qe(n, i, a, u, h, g) {
        switch (a) {
        case "children":
            typeof u == "string" ? i === "body" || i === "textarea" && u === "" || En(n, u) : (typeof u == "number" || typeof u == "bigint") && i !== "body" && En(n, "" + u);
            break;
        case "className":
            Xn(n, "class", u);
            break;
        case "tabIndex":
            Xn(n, "tabindex", u);
            break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
            Xn(n, a, u);
            break;
        case "style":
            aa(n, u, g);
            break;
        case "data":
            if (i !== "object") {
                Xn(n, "data", u);
                break
            }
        case "src":
        case "href":
            if (u === "" && (i !== "a" || a !== "href")) {
                n.removeAttribute(a);
                break
            }
            if (u == null || typeof u == "function" || typeof u == "symbol" || typeof u == "boolean") {
                n.removeAttribute(a);
                break
            }
            u = Ks("" + u),
            n.setAttribute(a, u);
            break;
        case "action":
        case "formAction":
            if (typeof u == "function") {
                n.setAttribute(a, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                break
            } else
                typeof g == "function" && (a === "formAction" ? (i !== "input" && Qe(n, i, "name", h.name, h, null),
                Qe(n, i, "formEncType", h.formEncType, h, null),
                Qe(n, i, "formMethod", h.formMethod, h, null),
                Qe(n, i, "formTarget", h.formTarget, h, null)) : (Qe(n, i, "encType", h.encType, h, null),
                Qe(n, i, "method", h.method, h, null),
                Qe(n, i, "target", h.target, h, null)));
            if (u == null || typeof u == "symbol" || typeof u == "boolean") {
                n.removeAttribute(a);
                break
            }
            u = Ks("" + u),
            n.setAttribute(a, u);
            break;
        case "onClick":
            u != null && (n.onclick = Yu);
            break;
        case "onScroll":
            u != null && Ne("scroll", n);
            break;
        case "onScrollEnd":
            u != null && Ne("scrollend", n);
            break;
        case "dangerouslySetInnerHTML":
            if (u != null) {
                if (typeof u != "object" || !("__html"in u))
                    throw Error(s(61));
                if (a = u.__html,
                a != null) {
                    if (h.children != null)
                        throw Error(s(60));
                    n.innerHTML = a
                }
            }
            break;
        case "multiple":
            n.multiple = u && typeof u != "function" && typeof u != "symbol";
            break;
        case "muted":
            n.muted = u && typeof u != "function" && typeof u != "symbol";
            break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
            break;
        case "autoFocus":
            break;
        case "xlinkHref":
            if (u == null || typeof u == "function" || typeof u == "boolean" || typeof u == "symbol") {
                n.removeAttribute("xlink:href");
                break
            }
            a = Ks("" + u),
            n.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", a);
            break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
            u != null && typeof u != "function" && typeof u != "symbol" ? n.setAttribute(a, "" + u) : n.removeAttribute(a);
            break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
            u && typeof u != "function" && typeof u != "symbol" ? n.setAttribute(a, "") : n.removeAttribute(a);
            break;
        case "capture":
        case "download":
            u === !0 ? n.setAttribute(a, "") : u !== !1 && u != null && typeof u != "function" && typeof u != "symbol" ? n.setAttribute(a, u) : n.removeAttribute(a);
            break;
        case "cols":
        case "rows":
        case "size":
        case "span":
            u != null && typeof u != "function" && typeof u != "symbol" && !isNaN(u) && 1 <= u ? n.setAttribute(a, u) : n.removeAttribute(a);
            break;
        case "rowSpan":
        case "start":
            u == null || typeof u == "function" || typeof u == "symbol" || isNaN(u) ? n.removeAttribute(a) : n.setAttribute(a, u);
            break;
        case "popover":
            Ne("beforetoggle", n),
            Ne("toggle", n),
            Wi(n, "popover", u);
            break;
        case "xlinkActuate":
            Ot(n, "http://www.w3.org/1999/xlink", "xlink:actuate", u);
            break;
        case "xlinkArcrole":
            Ot(n, "http://www.w3.org/1999/xlink", "xlink:arcrole", u);
            break;
        case "xlinkRole":
            Ot(n, "http://www.w3.org/1999/xlink", "xlink:role", u);
            break;
        case "xlinkShow":
            Ot(n, "http://www.w3.org/1999/xlink", "xlink:show", u);
            break;
        case "xlinkTitle":
            Ot(n, "http://www.w3.org/1999/xlink", "xlink:title", u);
            break;
        case "xlinkType":
            Ot(n, "http://www.w3.org/1999/xlink", "xlink:type", u);
            break;
        case "xmlBase":
            Ot(n, "http://www.w3.org/XML/1998/namespace", "xml:base", u);
            break;
        case "xmlLang":
            Ot(n, "http://www.w3.org/XML/1998/namespace", "xml:lang", u);
            break;
        case "xmlSpace":
            Ot(n, "http://www.w3.org/XML/1998/namespace", "xml:space", u);
            break;
        case "is":
            Wi(n, "is", u);
            break;
        case "innerText":
        case "textContent":
            break;
        default:
            (!(2 < a.length) || a[0] !== "o" && a[0] !== "O" || a[1] !== "n" && a[1] !== "N") && (a = mf.get(a) || a,
            Wi(n, a, u))
        }
    }
    function Kh(n, i, a, u, h, g) {
        switch (a) {
        case "style":
            aa(n, u, g);
            break;
        case "dangerouslySetInnerHTML":
            if (u != null) {
                if (typeof u != "object" || !("__html"in u))
                    throw Error(s(61));
                if (a = u.__html,
                a != null) {
                    if (h.children != null)
                        throw Error(s(60));
                    n.innerHTML = a
                }
            }
            break;
        case "children":
            typeof u == "string" ? En(n, u) : (typeof u == "number" || typeof u == "bigint") && En(n, "" + u);
            break;
        case "onScroll":
            u != null && Ne("scroll", n);
            break;
        case "onScrollEnd":
            u != null && Ne("scrollend", n);
            break;
        case "onClick":
            u != null && (n.onclick = Yu);
            break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
            break;
        case "innerText":
        case "textContent":
            break;
        default:
            if (!zs.hasOwnProperty(a))
                e: {
                    if (a[0] === "o" && a[1] === "n" && (h = a.endsWith("Capture"),
                    i = a.slice(2, h ? a.length - 7 : void 0),
                    g = n[pt] || null,
                    g = g != null ? g[a] : null,
                    typeof g == "function" && n.removeEventListener(i, g, h),
                    typeof u == "function")) {
                        typeof g != "function" && g !== null && (a in n ? n[a] = null : n.hasAttribute(a) && n.removeAttribute(a)),
                        n.addEventListener(i, u, h);
                        break e
                    }
                    a in n ? n[a] = u : u === !0 ? n.setAttribute(a, "") : Wi(n, a, u)
                }
        }
    }
    function Lt(n, i, a) {
        switch (i) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "img":
            Ne("error", n),
            Ne("load", n);
            var u = !1, h = !1, g;
            for (g in a)
                if (a.hasOwnProperty(g)) {
                    var S = a[g];
                    if (S != null)
                        switch (g) {
                        case "src":
                            u = !0;
                            break;
                        case "srcSet":
                            h = !0;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            throw Error(s(137, i));
                        default:
                            Qe(n, i, g, S, a, null)
                        }
                }
            h && Qe(n, i, "srcSet", a.srcSet, a, null),
            u && Qe(n, i, "src", a.src, a, null);
            return;
        case "input":
            Ne("invalid", n);
            var C = g = S = h = null
              , D = null
              , H = null;
            for (u in a)
                if (a.hasOwnProperty(u)) {
                    var $ = a[u];
                    if ($ != null)
                        switch (u) {
                        case "name":
                            h = $;
                            break;
                        case "type":
                            S = $;
                            break;
                        case "checked":
                            D = $;
                            break;
                        case "defaultChecked":
                            H = $;
                            break;
                        case "value":
                            g = $;
                            break;
                        case "defaultValue":
                            C = $;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            if ($ != null)
                                throw Error(s(137, i));
                            break;
                        default:
                            Qe(n, i, u, $, a, null)
                        }
                }
            jr(n, g, C, D, H, S, h, !1),
            Ys(n);
            return;
        case "select":
            Ne("invalid", n),
            u = S = g = null;
            for (h in a)
                if (a.hasOwnProperty(h) && (C = a[h],
                C != null))
                    switch (h) {
                    case "value":
                        g = C;
                        break;
                    case "defaultValue":
                        S = C;
                        break;
                    case "multiple":
                        u = C;
                    default:
                        Qe(n, i, h, C, a, null)
                    }
            i = g,
            a = S,
            n.multiple = !!u,
            i != null ? yi(n, !!u, i, !1) : a != null && yi(n, !!u, a, !0);
            return;
        case "textarea":
            Ne("invalid", n),
            g = h = u = null;
            for (S in a)
                if (a.hasOwnProperty(S) && (C = a[S],
                C != null))
                    switch (S) {
                    case "value":
                        u = C;
                        break;
                    case "defaultValue":
                        h = C;
                        break;
                    case "children":
                        g = C;
                        break;
                    case "dangerouslySetInnerHTML":
                        if (C != null)
                            throw Error(s(91));
                        break;
                    default:
                        Qe(n, i, S, C, a, null)
                    }
            Wr(n, u, h, g),
            Ys(n);
            return;
        case "option":
            for (D in a)
                if (a.hasOwnProperty(D) && (u = a[D],
                u != null))
                    switch (D) {
                    case "selected":
                        n.selected = u && typeof u != "function" && typeof u != "symbol";
                        break;
                    default:
                        Qe(n, i, D, u, a, null)
                    }
            return;
        case "dialog":
            Ne("beforetoggle", n),
            Ne("toggle", n),
            Ne("cancel", n),
            Ne("close", n);
            break;
        case "iframe":
        case "object":
            Ne("load", n);
            break;
        case "video":
        case "audio":
            for (u = 0; u < Ya.length; u++)
                Ne(Ya[u], n);
            break;
        case "image":
            Ne("error", n),
            Ne("load", n);
            break;
        case "details":
            Ne("toggle", n);
            break;
        case "embed":
        case "source":
        case "link":
            Ne("error", n),
            Ne("load", n);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
            for (H in a)
                if (a.hasOwnProperty(H) && (u = a[H],
                u != null))
                    switch (H) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                        throw Error(s(137, i));
                    default:
                        Qe(n, i, H, u, a, null)
                    }
            return;
        default:
            if (la(i)) {
                for ($ in a)
                    a.hasOwnProperty($) && (u = a[$],
                    u !== void 0 && Kh(n, i, $, u, a, void 0));
                return
            }
        }
        for (C in a)
            a.hasOwnProperty(C) && (u = a[C],
            u != null && Qe(n, i, C, u, a, null))
    }
    function xS(n, i, a, u) {
        switch (i) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "input":
            var h = null
              , g = null
              , S = null
              , C = null
              , D = null
              , H = null
              , $ = null;
            for (K in a) {
                var W = a[K];
                if (a.hasOwnProperty(K) && W != null)
                    switch (K) {
                    case "checked":
                        break;
                    case "value":
                        break;
                    case "defaultValue":
                        D = W;
                    default:
                        u.hasOwnProperty(K) || Qe(n, i, K, null, u, W)
                    }
            }
            for (var Y in u) {
                var K = u[Y];
                if (W = a[Y],
                u.hasOwnProperty(Y) && (K != null || W != null))
                    switch (Y) {
                    case "type":
                        g = K;
                        break;
                    case "name":
                        h = K;
                        break;
                    case "checked":
                        H = K;
                        break;
                    case "defaultChecked":
                        $ = K;
                        break;
                    case "value":
                        S = K;
                        break;
                    case "defaultValue":
                        C = K;
                        break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (K != null)
                            throw Error(s(137, i));
                        break;
                    default:
                        K !== W && Qe(n, i, Y, K, u, W)
                    }
            }
            un(n, S, C, D, H, $, g, h);
            return;
        case "select":
            K = S = C = Y = null;
            for (g in a)
                if (D = a[g],
                a.hasOwnProperty(g) && D != null)
                    switch (g) {
                    case "value":
                        break;
                    case "multiple":
                        K = D;
                    default:
                        u.hasOwnProperty(g) || Qe(n, i, g, null, u, D)
                    }
            for (h in u)
                if (g = u[h],
                D = a[h],
                u.hasOwnProperty(h) && (g != null || D != null))
                    switch (h) {
                    case "value":
                        Y = g;
                        break;
                    case "defaultValue":
                        C = g;
                        break;
                    case "multiple":
                        S = g;
                    default:
                        g !== D && Qe(n, i, h, g, u, D)
                    }
            i = C,
            a = S,
            u = K,
            Y != null ? yi(n, !!a, Y, !1) : !!u != !!a && (i != null ? yi(n, !!a, i, !0) : yi(n, !!a, a ? [] : "", !1));
            return;
        case "textarea":
            K = Y = null;
            for (C in a)
                if (h = a[C],
                a.hasOwnProperty(C) && h != null && !u.hasOwnProperty(C))
                    switch (C) {
                    case "value":
                        break;
                    case "children":
                        break;
                    default:
                        Qe(n, i, C, null, u, h)
                    }
            for (S in u)
                if (h = u[S],
                g = a[S],
                u.hasOwnProperty(S) && (h != null || g != null))
                    switch (S) {
                    case "value":
                        Y = h;
                        break;
                    case "defaultValue":
                        K = h;
                        break;
                    case "children":
                        break;
                    case "dangerouslySetInnerHTML":
                        if (h != null)
                            throw Error(s(91));
                        break;
                    default:
                        h !== g && Qe(n, i, S, h, u, g)
                    }
            Ye(n, Y, K);
            return;
        case "option":
            for (var _e in a)
                if (Y = a[_e],
                a.hasOwnProperty(_e) && Y != null && !u.hasOwnProperty(_e))
                    switch (_e) {
                    case "selected":
                        n.selected = !1;
                        break;
                    default:
                        Qe(n, i, _e, null, u, Y)
                    }
            for (D in u)
                if (Y = u[D],
                K = a[D],
                u.hasOwnProperty(D) && Y !== K && (Y != null || K != null))
                    switch (D) {
                    case "selected":
                        n.selected = Y && typeof Y != "function" && typeof Y != "symbol";
                        break;
                    default:
                        Qe(n, i, D, Y, u, K)
                    }
            return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
            for (var ge in a)
                Y = a[ge],
                a.hasOwnProperty(ge) && Y != null && !u.hasOwnProperty(ge) && Qe(n, i, ge, null, u, Y);
            for (H in u)
                if (Y = u[H],
                K = a[H],
                u.hasOwnProperty(H) && Y !== K && (Y != null || K != null))
                    switch (H) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (Y != null)
                            throw Error(s(137, i));
                        break;
                    default:
                        Qe(n, i, H, Y, u, K)
                    }
            return;
        default:
            if (la(i)) {
                for (var Xe in a)
                    Y = a[Xe],
                    a.hasOwnProperty(Xe) && Y !== void 0 && !u.hasOwnProperty(Xe) && Kh(n, i, Xe, void 0, u, Y);
                for ($ in u)
                    Y = u[$],
                    K = a[$],
                    !u.hasOwnProperty($) || Y === K || Y === void 0 && K === void 0 || Kh(n, i, $, Y, u, K);
                return
            }
        }
        for (var L in a)
            Y = a[L],
            a.hasOwnProperty(L) && Y != null && !u.hasOwnProperty(L) && Qe(n, i, L, null, u, Y);
        for (W in u)
            Y = u[W],
            K = a[W],
            !u.hasOwnProperty(W) || Y === K || Y == null && K == null || Qe(n, i, W, Y, u, K)
    }
    var Qh = null
      , Xh = null;
    function Ku(n) {
        return n.nodeType === 9 ? n : n.ownerDocument
    }
    function Sy(n) {
        switch (n) {
        case "http://www.w3.org/2000/svg":
            return 1;
        case "http://www.w3.org/1998/Math/MathML":
            return 2;
        default:
            return 0
        }
    }
    function Ay(n, i) {
        if (n === 0)
            switch (i) {
            case "svg":
                return 1;
            case "math":
                return 2;
            default:
                return 0
            }
        return n === 1 && i === "foreignObject" ? 0 : n
    }
    function $h(n, i) {
        return n === "textarea" || n === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.children == "bigint" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null
    }
    var Jh = null;
    function PS() {
        var n = window.event;
        return n && n.type === "popstate" ? n === Jh ? !1 : (Jh = n,
        !0) : (Jh = null,
        !1)
    }
    var Cy = typeof setTimeout == "function" ? setTimeout : void 0
      , OS = typeof clearTimeout == "function" ? clearTimeout : void 0
      , Ry = typeof Promise == "function" ? Promise : void 0
      , VS = typeof queueMicrotask == "function" ? queueMicrotask : typeof Ry < "u" ? function(n) {
        return Ry.resolve(null).then(n).catch(US)
    }
    : Cy;
    function US(n) {
        setTimeout(function() {
            throw n
        })
    }
    function gr(n) {
        return n === "head"
    }
    function Iy(n, i) {
        var a = i
          , u = 0
          , h = 0;
        do {
            var g = a.nextSibling;
            if (n.removeChild(a),
            g && g.nodeType === 8)
                if (a = g.data,
                a === "/$") {
                    if (0 < u && 8 > u) {
                        a = u;
                        var S = n.ownerDocument;
                        if (a & 1 && Qa(S.documentElement),
                        a & 2 && Qa(S.body),
                        a & 4)
                            for (a = S.head,
                            Qa(a),
                            S = a.firstChild; S; ) {
                                var C = S.nextSibling
                                  , D = S.nodeName;
                                S[Qr] || D === "SCRIPT" || D === "STYLE" || D === "LINK" && S.rel.toLowerCase() === "stylesheet" || a.removeChild(S),
                                S = C
                            }
                    }
                    if (h === 0) {
                        n.removeChild(g),
                        tl(i);
                        return
                    }
                    h--
                } else
                    a === "$" || a === "$?" || a === "$!" ? h++ : u = a.charCodeAt(0) - 48;
            else
                u = 0;
            a = g
        } while (a);
        tl(i)
    }
    function jh(n) {
        var i = n.firstChild;
        for (i && i.nodeType === 10 && (i = i.nextSibling); i; ) {
            var a = i;
            switch (i = i.nextSibling,
            a.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
                jh(a),
                ji(a);
                continue;
            case "SCRIPT":
            case "STYLE":
                continue;
            case "LINK":
                if (a.rel.toLowerCase() === "stylesheet")
                    continue
            }
            n.removeChild(a)
        }
    }
    function kS(n, i, a, u) {
        for (; n.nodeType === 1; ) {
            var h = a;
            if (n.nodeName.toLowerCase() !== i.toLowerCase()) {
                if (!u && (n.nodeName !== "INPUT" || n.type !== "hidden"))
                    break
            } else if (u) {
                if (!n[Qr])
                    switch (i) {
                    case "meta":
                        if (!n.hasAttribute("itemprop"))
                            break;
                        return n;
                    case "link":
                        if (g = n.getAttribute("rel"),
                        g === "stylesheet" && n.hasAttribute("data-precedence"))
                            break;
                        if (g !== h.rel || n.getAttribute("href") !== (h.href == null || h.href === "" ? null : h.href) || n.getAttribute("crossorigin") !== (h.crossOrigin == null ? null : h.crossOrigin) || n.getAttribute("title") !== (h.title == null ? null : h.title))
                            break;
                        return n;
                    case "style":
                        if (n.hasAttribute("data-precedence"))
                            break;
                        return n;
                    case "script":
                        if (g = n.getAttribute("src"),
                        (g !== (h.src == null ? null : h.src) || n.getAttribute("type") !== (h.type == null ? null : h.type) || n.getAttribute("crossorigin") !== (h.crossOrigin == null ? null : h.crossOrigin)) && g && n.hasAttribute("async") && !n.hasAttribute("itemprop"))
                            break;
                        return n;
                    default:
                        return n
                    }
            } else if (i === "input" && n.type === "hidden") {
                var g = h.name == null ? null : "" + h.name;
                if (h.type === "hidden" && n.getAttribute("name") === g)
                    return n
            } else
                return n;
            if (n = Ln(n.nextSibling),
            n === null)
                break
        }
        return null
    }
    function LS(n, i, a) {
        if (i === "")
            return null;
        for (; n.nodeType !== 3; )
            if ((n.nodeType !== 1 || n.nodeName !== "INPUT" || n.type !== "hidden") && !a || (n = Ln(n.nextSibling),
            n === null))
                return null;
        return n
    }
    function Wh(n) {
        return n.data === "$!" || n.data === "$?" && n.ownerDocument.readyState === "complete"
    }
    function BS(n, i) {
        var a = n.ownerDocument;
        if (n.data !== "$?" || a.readyState === "complete")
            i();
        else {
            var u = function() {
                i(),
                a.removeEventListener("DOMContentLoaded", u)
            };
            a.addEventListener("DOMContentLoaded", u),
            n._reactRetry = u
        }
    }
    function Ln(n) {
        for (; n != null; n = n.nextSibling) {
            var i = n.nodeType;
            if (i === 1 || i === 3)
                break;
            if (i === 8) {
                if (i = n.data,
                i === "$" || i === "$!" || i === "$?" || i === "F!" || i === "F")
                    break;
                if (i === "/$")
                    return null
            }
        }
        return n
    }
    var Zh = null;
    function wy(n) {
        n = n.previousSibling;
        for (var i = 0; n; ) {
            if (n.nodeType === 8) {
                var a = n.data;
                if (a === "$" || a === "$!" || a === "$?") {
                    if (i === 0)
                        return n;
                    i--
                } else
                    a === "/$" && i++
            }
            n = n.previousSibling
        }
        return null
    }
    function by(n, i, a) {
        switch (i = Ku(a),
        n) {
        case "html":
            if (n = i.documentElement,
            !n)
                throw Error(s(452));
            return n;
        case "head":
            if (n = i.head,
            !n)
                throw Error(s(453));
            return n;
        case "body":
            if (n = i.body,
            !n)
                throw Error(s(454));
            return n;
        default:
            throw Error(s(451))
        }
    }
    function Qa(n) {
        for (var i = n.attributes; i.length; )
            n.removeAttributeNode(i[0]);
        ji(n)
    }
    var Nn = new Map
      , Dy = new Set;
    function Qu(n) {
        return typeof n.getRootNode == "function" ? n.getRootNode() : n.nodeType === 9 ? n : n.ownerDocument
    }
    var Ui = oe.d;
    oe.d = {
        f: qS,
        r: zS,
        D: FS,
        C: HS,
        L: GS,
        m: YS,
        X: QS,
        S: KS,
        M: XS
    };
    function qS() {
        var n = Ui.f()
          , i = Lu();
        return n || i
    }
    function zS(n) {
        var i = Kn(n);
        i !== null && i.tag === 5 && i.type === "form" ? $m(i) : Ui.r(n)
    }
    var wo = typeof document > "u" ? null : document;
    function My(n, i, a) {
        var u = wo;
        if (u && typeof i == "string" && i) {
            var h = mt(i);
            h = 'link[rel="' + n + '"][href="' + h + '"]',
            typeof a == "string" && (h += '[crossorigin="' + a + '"]'),
            Dy.has(h) || (Dy.add(h),
            n = {
                rel: n,
                crossOrigin: a,
                href: i
            },
            u.querySelector(h) === null && (i = u.createElement("link"),
            Lt(i, "link", n),
            ct(i),
            u.head.appendChild(i)))
        }
    }
    function FS(n) {
        Ui.D(n),
        My("dns-prefetch", n, null)
    }
    function HS(n, i) {
        Ui.C(n, i),
        My("preconnect", n, i)
    }
    function GS(n, i, a) {
        Ui.L(n, i, a);
        var u = wo;
        if (u && n && i) {
            var h = 'link[rel="preload"][as="' + mt(i) + '"]';
            i === "image" && a && a.imageSrcSet ? (h += '[imagesrcset="' + mt(a.imageSrcSet) + '"]',
            typeof a.imageSizes == "string" && (h += '[imagesizes="' + mt(a.imageSizes) + '"]')) : h += '[href="' + mt(n) + '"]';
            var g = h;
            switch (i) {
            case "style":
                g = bo(n);
                break;
            case "script":
                g = Do(n)
            }
            Nn.has(g) || (n = T({
                rel: "preload",
                href: i === "image" && a && a.imageSrcSet ? void 0 : n,
                as: i
            }, a),
            Nn.set(g, n),
            u.querySelector(h) !== null || i === "style" && u.querySelector(Xa(g)) || i === "script" && u.querySelector($a(g)) || (i = u.createElement("link"),
            Lt(i, "link", n),
            ct(i),
            u.head.appendChild(i)))
        }
    }
    function YS(n, i) {
        Ui.m(n, i);
        var a = wo;
        if (a && n) {
            var u = i && typeof i.as == "string" ? i.as : "script"
              , h = 'link[rel="modulepreload"][as="' + mt(u) + '"][href="' + mt(n) + '"]'
              , g = h;
            switch (u) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
                g = Do(n)
            }
            if (!Nn.has(g) && (n = T({
                rel: "modulepreload",
                href: n
            }, i),
            Nn.set(g, n),
            a.querySelector(h) === null)) {
                switch (u) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                    if (a.querySelector($a(g)))
                        return
                }
                u = a.createElement("link"),
                Lt(u, "link", n),
                ct(u),
                a.head.appendChild(u)
            }
        }
    }
    function KS(n, i, a) {
        Ui.S(n, i, a);
        var u = wo;
        if (u && n) {
            var h = jt(u).hoistableStyles
              , g = bo(n);
            i = i || "default";
            var S = h.get(g);
            if (!S) {
                var C = {
                    loading: 0,
                    preload: null
                };
                if (S = u.querySelector(Xa(g)))
                    C.loading = 5;
                else {
                    n = T({
                        rel: "stylesheet",
                        href: n,
                        "data-precedence": i
                    }, a),
                    (a = Nn.get(g)) && ed(n, a);
                    var D = S = u.createElement("link");
                    ct(D),
                    Lt(D, "link", n),
                    D._p = new Promise(function(H, $) {
                        D.onload = H,
                        D.onerror = $
                    }
                    ),
                    D.addEventListener("load", function() {
                        C.loading |= 1
                    }),
                    D.addEventListener("error", function() {
                        C.loading |= 2
                    }),
                    C.loading |= 4,
                    Xu(S, i, u)
                }
                S = {
                    type: "stylesheet",
                    instance: S,
                    count: 1,
                    state: C
                },
                h.set(g, S)
            }
        }
    }
    function QS(n, i) {
        Ui.X(n, i);
        var a = wo;
        if (a && n) {
            var u = jt(a).hoistableScripts
              , h = Do(n)
              , g = u.get(h);
            g || (g = a.querySelector($a(h)),
            g || (n = T({
                src: n,
                async: !0
            }, i),
            (i = Nn.get(h)) && td(n, i),
            g = a.createElement("script"),
            ct(g),
            Lt(g, "link", n),
            a.head.appendChild(g)),
            g = {
                type: "script",
                instance: g,
                count: 1,
                state: null
            },
            u.set(h, g))
        }
    }
    function XS(n, i) {
        Ui.M(n, i);
        var a = wo;
        if (a && n) {
            var u = jt(a).hoistableScripts
              , h = Do(n)
              , g = u.get(h);
            g || (g = a.querySelector($a(h)),
            g || (n = T({
                src: n,
                async: !0,
                type: "module"
            }, i),
            (i = Nn.get(h)) && td(n, i),
            g = a.createElement("script"),
            ct(g),
            Lt(g, "link", n),
            a.head.appendChild(g)),
            g = {
                type: "script",
                instance: g,
                count: 1,
                state: null
            },
            u.set(h, g))
        }
    }
    function Ny(n, i, a, u) {
        var h = (h = Te.current) ? Qu(h) : null;
        if (!h)
            throw Error(s(446));
        switch (n) {
        case "meta":
        case "title":
            return null;
        case "style":
            return typeof a.precedence == "string" && typeof a.href == "string" ? (i = bo(a.href),
            a = jt(h).hoistableStyles,
            u = a.get(i),
            u || (u = {
                type: "style",
                instance: null,
                count: 0,
                state: null
            },
            a.set(i, u)),
            u) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
            };
        case "link":
            if (a.rel === "stylesheet" && typeof a.href == "string" && typeof a.precedence == "string") {
                n = bo(a.href);
                var g = jt(h).hoistableStyles
                  , S = g.get(n);
                if (S || (h = h.ownerDocument || h,
                S = {
                    type: "stylesheet",
                    instance: null,
                    count: 0,
                    state: {
                        loading: 0,
                        preload: null
                    }
                },
                g.set(n, S),
                (g = h.querySelector(Xa(n))) && !g._p && (S.instance = g,
                S.state.loading = 5),
                Nn.has(n) || (a = {
                    rel: "preload",
                    as: "style",
                    href: a.href,
                    crossOrigin: a.crossOrigin,
                    integrity: a.integrity,
                    media: a.media,
                    hrefLang: a.hrefLang,
                    referrerPolicy: a.referrerPolicy
                },
                Nn.set(n, a),
                g || $S(h, n, a, S.state))),
                i && u === null)
                    throw Error(s(528, ""));
                return S
            }
            if (i && u !== null)
                throw Error(s(529, ""));
            return null;
        case "script":
            return i = a.async,
            a = a.src,
            typeof a == "string" && i && typeof i != "function" && typeof i != "symbol" ? (i = Do(a),
            a = jt(h).hoistableScripts,
            u = a.get(i),
            u || (u = {
                type: "script",
                instance: null,
                count: 0,
                state: null
            },
            a.set(i, u)),
            u) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
            };
        default:
            throw Error(s(444, n))
        }
    }
    function bo(n) {
        return 'href="' + mt(n) + '"'
    }
    function Xa(n) {
        return 'link[rel="stylesheet"][' + n + "]"
    }
    function xy(n) {
        return T({}, n, {
            "data-precedence": n.precedence,
            precedence: null
        })
    }
    function $S(n, i, a, u) {
        n.querySelector('link[rel="preload"][as="style"][' + i + "]") ? u.loading = 1 : (i = n.createElement("link"),
        u.preload = i,
        i.addEventListener("load", function() {
            return u.loading |= 1
        }),
        i.addEventListener("error", function() {
            return u.loading |= 2
        }),
        Lt(i, "link", a),
        ct(i),
        n.head.appendChild(i))
    }
    function Do(n) {
        return '[src="' + mt(n) + '"]'
    }
    function $a(n) {
        return "script[async]" + n
    }
    function Py(n, i, a) {
        if (i.count++,
        i.instance === null)
            switch (i.type) {
            case "style":
                var u = n.querySelector('style[data-href~="' + mt(a.href) + '"]');
                if (u)
                    return i.instance = u,
                    ct(u),
                    u;
                var h = T({}, a, {
                    "data-href": a.href,
                    "data-precedence": a.precedence,
                    href: null,
                    precedence: null
                });
                return u = (n.ownerDocument || n).createElement("style"),
                ct(u),
                Lt(u, "style", h),
                Xu(u, a.precedence, n),
                i.instance = u;
            case "stylesheet":
                h = bo(a.href);
                var g = n.querySelector(Xa(h));
                if (g)
                    return i.state.loading |= 4,
                    i.instance = g,
                    ct(g),
                    g;
                u = xy(a),
                (h = Nn.get(h)) && ed(u, h),
                g = (n.ownerDocument || n).createElement("link"),
                ct(g);
                var S = g;
                return S._p = new Promise(function(C, D) {
                    S.onload = C,
                    S.onerror = D
                }
                ),
                Lt(g, "link", u),
                i.state.loading |= 4,
                Xu(g, a.precedence, n),
                i.instance = g;
            case "script":
                return g = Do(a.src),
                (h = n.querySelector($a(g))) ? (i.instance = h,
                ct(h),
                h) : (u = a,
                (h = Nn.get(g)) && (u = T({}, a),
                td(u, h)),
                n = n.ownerDocument || n,
                h = n.createElement("script"),
                ct(h),
                Lt(h, "link", u),
                n.head.appendChild(h),
                i.instance = h);
            case "void":
                return null;
            default:
                throw Error(s(443, i.type))
            }
        else
            i.type === "stylesheet" && (i.state.loading & 4) === 0 && (u = i.instance,
            i.state.loading |= 4,
            Xu(u, a.precedence, n));
        return i.instance
    }
    function Xu(n, i, a) {
        for (var u = a.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), h = u.length ? u[u.length - 1] : null, g = h, S = 0; S < u.length; S++) {
            var C = u[S];
            if (C.dataset.precedence === i)
                g = C;
            else if (g !== h)
                break
        }
        g ? g.parentNode.insertBefore(n, g.nextSibling) : (i = a.nodeType === 9 ? a.head : a,
        i.insertBefore(n, i.firstChild))
    }
    function ed(n, i) {
        n.crossOrigin == null && (n.crossOrigin = i.crossOrigin),
        n.referrerPolicy == null && (n.referrerPolicy = i.referrerPolicy),
        n.title == null && (n.title = i.title)
    }
    function td(n, i) {
        n.crossOrigin == null && (n.crossOrigin = i.crossOrigin),
        n.referrerPolicy == null && (n.referrerPolicy = i.referrerPolicy),
        n.integrity == null && (n.integrity = i.integrity)
    }
    var $u = null;
    function Oy(n, i, a) {
        if ($u === null) {
            var u = new Map
              , h = $u = new Map;
            h.set(a, u)
        } else
            h = $u,
            u = h.get(a),
            u || (u = new Map,
            h.set(a, u));
        if (u.has(n))
            return u;
        for (u.set(n, null),
        a = a.getElementsByTagName(n),
        h = 0; h < a.length; h++) {
            var g = a[h];
            if (!(g[Qr] || g[Tt] || n === "link" && g.getAttribute("rel") === "stylesheet") && g.namespaceURI !== "http://www.w3.org/2000/svg") {
                var S = g.getAttribute(i) || "";
                S = n + S;
                var C = u.get(S);
                C ? C.push(g) : u.set(S, [g])
            }
        }
        return u
    }
    function Vy(n, i, a) {
        n = n.ownerDocument || n,
        n.head.insertBefore(a, i === "title" ? n.querySelector("head > title") : null)
    }
    function JS(n, i, a) {
        if (a === 1 || i.itemProp != null)
            return !1;
        switch (n) {
        case "meta":
        case "title":
            return !0;
        case "style":
            if (typeof i.precedence != "string" || typeof i.href != "string" || i.href === "")
                break;
            return !0;
        case "link":
            if (typeof i.rel != "string" || typeof i.href != "string" || i.href === "" || i.onLoad || i.onError)
                break;
            switch (i.rel) {
            case "stylesheet":
                return n = i.disabled,
                typeof i.precedence == "string" && n == null;
            default:
                return !0
            }
        case "script":
            if (i.async && typeof i.async != "function" && typeof i.async != "symbol" && !i.onLoad && !i.onError && i.src && typeof i.src == "string")
                return !0
        }
        return !1
    }
    function Uy(n) {
        return !(n.type === "stylesheet" && (n.state.loading & 3) === 0)
    }
    var Ja = null;
    function jS() {}
    function WS(n, i, a) {
        if (Ja === null)
            throw Error(s(475));
        var u = Ja;
        if (i.type === "stylesheet" && (typeof a.media != "string" || matchMedia(a.media).matches !== !1) && (i.state.loading & 4) === 0) {
            if (i.instance === null) {
                var h = bo(a.href)
                  , g = n.querySelector(Xa(h));
                if (g) {
                    n = g._p,
                    n !== null && typeof n == "object" && typeof n.then == "function" && (u.count++,
                    u = Ju.bind(u),
                    n.then(u, u)),
                    i.state.loading |= 4,
                    i.instance = g,
                    ct(g);
                    return
                }
                g = n.ownerDocument || n,
                a = xy(a),
                (h = Nn.get(h)) && ed(a, h),
                g = g.createElement("link"),
                ct(g);
                var S = g;
                S._p = new Promise(function(C, D) {
                    S.onload = C,
                    S.onerror = D
                }
                ),
                Lt(g, "link", a),
                i.instance = g
            }
            u.stylesheets === null && (u.stylesheets = new Map),
            u.stylesheets.set(i, n),
            (n = i.state.preload) && (i.state.loading & 3) === 0 && (u.count++,
            i = Ju.bind(u),
            n.addEventListener("load", i),
            n.addEventListener("error", i))
        }
    }
    function ZS() {
        if (Ja === null)
            throw Error(s(475));
        var n = Ja;
        return n.stylesheets && n.count === 0 && nd(n, n.stylesheets),
        0 < n.count ? function(i) {
            var a = setTimeout(function() {
                if (n.stylesheets && nd(n, n.stylesheets),
                n.unsuspend) {
                    var u = n.unsuspend;
                    n.unsuspend = null,
                    u()
                }
            }, 6e4);
            return n.unsuspend = i,
            function() {
                n.unsuspend = null,
                clearTimeout(a)
            }
        }
        : null
    }
    function Ju() {
        if (this.count--,
        this.count === 0) {
            if (this.stylesheets)
                nd(this, this.stylesheets);
            else if (this.unsuspend) {
                var n = this.unsuspend;
                this.unsuspend = null,
                n()
            }
        }
    }
    var ju = null;
    function nd(n, i) {
        n.stylesheets = null,
        n.unsuspend !== null && (n.count++,
        ju = new Map,
        i.forEach(eA, n),
        ju = null,
        Ju.call(n))
    }
    function eA(n, i) {
        if (!(i.state.loading & 4)) {
            var a = ju.get(n);
            if (a)
                var u = a.get(null);
            else {
                a = new Map,
                ju.set(n, a);
                for (var h = n.querySelectorAll("link[data-precedence],style[data-precedence]"), g = 0; g < h.length; g++) {
                    var S = h[g];
                    (S.nodeName === "LINK" || S.getAttribute("media") !== "not all") && (a.set(S.dataset.precedence, S),
                    u = S)
                }
                u && a.set(null, u)
            }
            h = i.instance,
            S = h.getAttribute("data-precedence"),
            g = a.get(S) || u,
            g === u && a.set(null, h),
            a.set(S, h),
            this.count++,
            u = Ju.bind(this),
            h.addEventListener("load", u),
            h.addEventListener("error", u),
            g ? g.parentNode.insertBefore(h, g.nextSibling) : (n = n.nodeType === 9 ? n.head : n,
            n.insertBefore(h, n.firstChild)),
            i.state.loading |= 4
        }
    }
    var ja = {
        $$typeof: le,
        Provider: null,
        Consumer: null,
        _currentValue: pe,
        _currentValue2: pe,
        _threadCount: 0
    };
    function tA(n, i, a, u, h, g, S, C) {
        this.tag = 1,
        this.containerInfo = n,
        this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = -1,
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
        this.callbackPriority = 0,
        this.expirationTimes = hi(-1),
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = hi(0),
        this.hiddenUpdates = hi(null),
        this.identifierPrefix = u,
        this.onUncaughtError = h,
        this.onCaughtError = g,
        this.onRecoverableError = S,
        this.pooledCache = null,
        this.pooledCacheLanes = 0,
        this.formState = C,
        this.incompleteTransitions = new Map
    }
    function ky(n, i, a, u, h, g, S, C, D, H, $, W) {
        return n = new tA(n,i,a,S,C,D,H,W),
        i = 1,
        g === !0 && (i |= 24),
        g = fn(3, null, null, i),
        n.current = g,
        g.stateNode = n,
        i = kf(),
        i.refCount++,
        n.pooledCache = i,
        i.refCount++,
        g.memoizedState = {
            element: u,
            isDehydrated: a,
            cache: i
        },
        zf(g),
        n
    }
    function Ly(n) {
        return n ? (n = so,
        n) : so
    }
    function By(n, i, a, u, h, g) {
        h = Ly(h),
        u.context === null ? u.context = h : u.pendingContext = h,
        u = ir(i),
        u.payload = {
            element: a
        },
        g = g === void 0 ? null : g,
        g !== null && (u.callback = g),
        a = rr(n, u, i),
        a !== null && (gn(a, n, i),
        wa(a, n, i))
    }
    function qy(n, i) {
        if (n = n.memoizedState,
        n !== null && n.dehydrated !== null) {
            var a = n.retryLane;
            n.retryLane = a !== 0 && a < i ? a : i
        }
    }
    function id(n, i) {
        qy(n, i),
        (n = n.alternate) && qy(n, i)
    }
    function zy(n) {
        if (n.tag === 13) {
            var i = ro(n, 67108864);
            i !== null && gn(i, n, 67108864),
            id(n, 67108864)
        }
    }
    var Wu = !0;
    function nA(n, i, a, u) {
        var h = X.T;
        X.T = null;
        var g = oe.p;
        try {
            oe.p = 2,
            rd(n, i, a, u)
        } finally {
            oe.p = g,
            X.T = h
        }
    }
    function iA(n, i, a, u) {
        var h = X.T;
        X.T = null;
        var g = oe.p;
        try {
            oe.p = 8,
            rd(n, i, a, u)
        } finally {
            oe.p = g,
            X.T = h
        }
    }
    function rd(n, i, a, u) {
        if (Wu) {
            var h = sd(u);
            if (h === null)
                Yh(n, i, u, Zu, a),
                Hy(n, u);
            else if (sA(h, n, i, a, u))
                u.stopPropagation();
            else if (Hy(n, u),
            i & 4 && -1 < rA.indexOf(n)) {
                for (; h !== null; ) {
                    var g = Kn(h);
                    if (g !== null)
                        switch (g.tag) {
                        case 3:
                            if (g = g.stateNode,
                            g.current.memoizedState.isDehydrated) {
                                var S = Pn(g.pendingLanes);
                                if (S !== 0) {
                                    var C = g;
                                    for (C.pendingLanes |= 2,
                                    C.entangledLanes |= 2; S; ) {
                                        var D = 1 << 31 - Ht(S);
                                        C.entanglements[1] |= D,
                                        S &= ~D
                                    }
                                    oi(g),
                                    (He & 6) === 0 && (Uu = _n() + 500,
                                    Ga(0))
                                }
                            }
                            break;
                        case 13:
                            C = ro(g, 2),
                            C !== null && gn(C, g, 2),
                            Lu(),
                            id(g, 2)
                        }
                    if (g = sd(u),
                    g === null && Yh(n, i, u, Zu, a),
                    g === h)
                        break;
                    h = g
                }
                h !== null && u.stopPropagation()
            } else
                Yh(n, i, u, null, a)
        }
    }
    function sd(n) {
        return n = Sn(n),
        od(n)
    }
    var Zu = null;
    function od(n) {
        if (Zu = null,
        n = pi(n),
        n !== null) {
            var i = l(n);
            if (i === null)
                n = null;
            else {
                var a = i.tag;
                if (a === 13) {
                    if (n = f(i),
                    n !== null)
                        return n;
                    n = null
                } else if (a === 3) {
                    if (i.stateNode.current.memoizedState.isDehydrated)
                        return i.tag === 3 ? i.stateNode.containerInfo : null;
                    n = null
                } else
                    i !== n && (n = null)
            }
        }
        return Zu = n,
        null
    }
    function Fy(n) {
        switch (n) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 8;
        case "message":
            switch (uf()) {
            case $o:
                return 2;
            case ks:
                return 8;
            case Fr:
            case cf:
                return 32;
            case Ls:
                return 268435456;
            default:
                return 32
            }
        default:
            return 32
        }
    }
    var ad = !1
      , yr = null
      , vr = null
      , _r = null
      , Wa = new Map
      , Za = new Map
      , Tr = []
      , rA = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
    function Hy(n, i) {
        switch (n) {
        case "focusin":
        case "focusout":
            yr = null;
            break;
        case "dragenter":
        case "dragleave":
            vr = null;
            break;
        case "mouseover":
        case "mouseout":
            _r = null;
            break;
        case "pointerover":
        case "pointerout":
            Wa.delete(i.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            Za.delete(i.pointerId)
        }
    }
    function el(n, i, a, u, h, g) {
        return n === null || n.nativeEvent !== g ? (n = {
            blockedOn: i,
            domEventName: a,
            eventSystemFlags: u,
            nativeEvent: g,
            targetContainers: [h]
        },
        i !== null && (i = Kn(i),
        i !== null && zy(i)),
        n) : (n.eventSystemFlags |= u,
        i = n.targetContainers,
        h !== null && i.indexOf(h) === -1 && i.push(h),
        n)
    }
    function sA(n, i, a, u, h) {
        switch (i) {
        case "focusin":
            return yr = el(yr, n, i, a, u, h),
            !0;
        case "dragenter":
            return vr = el(vr, n, i, a, u, h),
            !0;
        case "mouseover":
            return _r = el(_r, n, i, a, u, h),
            !0;
        case "pointerover":
            var g = h.pointerId;
            return Wa.set(g, el(Wa.get(g) || null, n, i, a, u, h)),
            !0;
        case "gotpointercapture":
            return g = h.pointerId,
            Za.set(g, el(Za.get(g) || null, n, i, a, u, h)),
            !0
        }
        return !1
    }
    function Gy(n) {
        var i = pi(n.target);
        if (i !== null) {
            var a = l(i);
            if (a !== null) {
                if (i = a.tag,
                i === 13) {
                    if (i = f(a),
                    i !== null) {
                        n.blockedOn = i,
                        Ll(n.priority, function() {
                            if (a.tag === 13) {
                                var u = mn();
                                u = Xi(u);
                                var h = ro(a, u);
                                h !== null && gn(h, a, u),
                                id(a, u)
                            }
                        });
                        return
                    }
                } else if (i === 3 && a.stateNode.current.memoizedState.isDehydrated) {
                    n.blockedOn = a.tag === 3 ? a.stateNode.containerInfo : null;
                    return
                }
            }
        }
        n.blockedOn = null
    }
    function ec(n) {
        if (n.blockedOn !== null)
            return !1;
        for (var i = n.targetContainers; 0 < i.length; ) {
            var a = sd(n.nativeEvent);
            if (a === null) {
                a = n.nativeEvent;
                var u = new a.constructor(a.type,a);
                vi = u,
                a.target.dispatchEvent(u),
                vi = null
            } else
                return i = Kn(a),
                i !== null && zy(i),
                n.blockedOn = a,
                !1;
            i.shift()
        }
        return !0
    }
    function Yy(n, i, a) {
        ec(n) && a.delete(i)
    }
    function oA() {
        ad = !1,
        yr !== null && ec(yr) && (yr = null),
        vr !== null && ec(vr) && (vr = null),
        _r !== null && ec(_r) && (_r = null),
        Wa.forEach(Yy),
        Za.forEach(Yy)
    }
    function tc(n, i) {
        n.blockedOn === i && (n.blockedOn = null,
        ad || (ad = !0,
        r.unstable_scheduleCallback(r.unstable_NormalPriority, oA)))
    }
    var nc = null;
    function Ky(n) {
        nc !== n && (nc = n,
        r.unstable_scheduleCallback(r.unstable_NormalPriority, function() {
            nc === n && (nc = null);
            for (var i = 0; i < n.length; i += 3) {
                var a = n[i]
                  , u = n[i + 1]
                  , h = n[i + 2];
                if (typeof u != "function") {
                    if (od(u || a) === null)
                        continue;
                    break
                }
                var g = Kn(a);
                g !== null && (n.splice(i, 3),
                i -= 3,
                oh(g, {
                    pending: !0,
                    data: h,
                    method: a.method,
                    action: u
                }, u, h))
            }
        }))
    }
    function tl(n) {
        function i(D) {
            return tc(D, n)
        }
        yr !== null && tc(yr, n),
        vr !== null && tc(vr, n),
        _r !== null && tc(_r, n),
        Wa.forEach(i),
        Za.forEach(i);
        for (var a = 0; a < Tr.length; a++) {
            var u = Tr[a];
            u.blockedOn === n && (u.blockedOn = null)
        }
        for (; 0 < Tr.length && (a = Tr[0],
        a.blockedOn === null); )
            Gy(a),
            a.blockedOn === null && Tr.shift();
        if (a = (n.ownerDocument || n).$$reactFormReplay,
        a != null)
            for (u = 0; u < a.length; u += 3) {
                var h = a[u]
                  , g = a[u + 1]
                  , S = h[pt] || null;
                if (typeof g == "function")
                    S || Ky(a);
                else if (S) {
                    var C = null;
                    if (g && g.hasAttribute("formAction")) {
                        if (h = g,
                        S = g[pt] || null)
                            C = S.formAction;
                        else if (od(h) !== null)
                            continue
                    } else
                        C = S.action;
                    typeof C == "function" ? a[u + 1] = C : (a.splice(u, 3),
                    u -= 3),
                    Ky(a)
                }
            }
    }
    function ld(n) {
        this._internalRoot = n
    }
    ic.prototype.render = ld.prototype.render = function(n) {
        var i = this._internalRoot;
        if (i === null)
            throw Error(s(409));
        var a = i.current
          , u = mn();
        By(a, u, n, i, null, null)
    }
    ,
    ic.prototype.unmount = ld.prototype.unmount = function() {
        var n = this._internalRoot;
        if (n !== null) {
            this._internalRoot = null;
            var i = n.containerInfo;
            By(n.current, 2, null, n, null, null),
            Lu(),
            i[Tn] = null
        }
    }
    ;
    function ic(n) {
        this._internalRoot = n
    }
    ic.prototype.unstable_scheduleHydration = function(n) {
        if (n) {
            var i = $i();
            n = {
                blockedOn: null,
                target: n,
                priority: i
            };
            for (var a = 0; a < Tr.length && i !== 0 && i < Tr[a].priority; a++)
                ;
            Tr.splice(a, 0, n),
            a === 0 && Gy(n)
        }
    }
    ;
    var Qy = e.version;
    if (Qy !== "19.1.0")
        throw Error(s(527, Qy, "19.1.0"));
    oe.findDOMNode = function(n) {
        var i = n._reactInternals;
        if (i === void 0)
            throw typeof n.render == "function" ? Error(s(188)) : (n = Object.keys(n).join(","),
            Error(s(268, n)));
        return n = v(i),
        n = n !== null ? y(n) : null,
        n = n === null ? null : n.stateNode,
        n
    }
    ;
    var aA = {
        bundleType: 0,
        version: "19.1.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: X,
        reconcilerVersion: "19.1.0"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var rc = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!rc.isDisabled && rc.supportsFiber)
            try {
                st = rc.inject(aA),
                Fe = rc
            } catch {}
    }
    return il.createRoot = function(n, i) {
        if (!o(n))
            throw Error(s(299));
        var a = !1
          , u = ""
          , h = ug
          , g = cg
          , S = fg
          , C = null;
        return i != null && (i.unstable_strictMode === !0 && (a = !0),
        i.identifierPrefix !== void 0 && (u = i.identifierPrefix),
        i.onUncaughtError !== void 0 && (h = i.onUncaughtError),
        i.onCaughtError !== void 0 && (g = i.onCaughtError),
        i.onRecoverableError !== void 0 && (S = i.onRecoverableError),
        i.unstable_transitionCallbacks !== void 0 && (C = i.unstable_transitionCallbacks)),
        i = ky(n, 1, !1, null, null, a, u, h, g, S, C, null),
        n[Tn] = i.current,
        Gh(n),
        new ld(i)
    }
    ,
    il.hydrateRoot = function(n, i, a) {
        if (!o(n))
            throw Error(s(299));
        var u = !1
          , h = ""
          , g = ug
          , S = cg
          , C = fg
          , D = null
          , H = null;
        return a != null && (a.unstable_strictMode === !0 && (u = !0),
        a.identifierPrefix !== void 0 && (h = a.identifierPrefix),
        a.onUncaughtError !== void 0 && (g = a.onUncaughtError),
        a.onCaughtError !== void 0 && (S = a.onCaughtError),
        a.onRecoverableError !== void 0 && (C = a.onRecoverableError),
        a.unstable_transitionCallbacks !== void 0 && (D = a.unstable_transitionCallbacks),
        a.formState !== void 0 && (H = a.formState)),
        i = ky(n, 1, !0, i, a ?? null, u, h, g, S, C, D, H),
        i.context = Ly(null),
        a = i.current,
        u = mn(),
        u = Xi(u),
        h = ir(u),
        h.callback = null,
        rr(a, h, u),
        a = u,
        i.current.lanes = a,
        di(i, a),
        oi(i),
        n[Tn] = i.current,
        Gh(n),
        new ic(i)
    }
    ,
    il.version = "19.1.0",
    il
}
var iv;
function yA() {
    if (iv)
        return fd.exports;
    iv = 1;
    function r() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r)
            } catch (e) {
                console.error(e)
            }
    }
    return r(),
    fd.exports = gA(),
    fd.exports
}
var vA = yA();
const _A = "" + new URL("doctorpicture-XdAu9lob.png",import.meta.url).href
  , TA = "" + new URL("doctorhelp-CqkjM9ym.jpg",import.meta.url).href;
function EA({setPage: r}) {
    return b.jsxs(b.Fragment, {
        children: [b.jsxs("div", {
            id: "imgContainer",
            children: [b.jsx("img", {
                id: "topImg",
                alt: "doctor working",
                src: _A
            }), b.jsx("div", {
                id: "centered",
                children: b.jsx("h1", {
                    children: "Dr. Finder"
                })
            })]
        }), b.jsxs("div", {
            id: "infoBox",
            children: [b.jsx("div", {}), b.jsxs("div", {
                children: [b.jsx("h3", {
                    children: "About Us"
                }), b.jsx("p", {
                    children: "We are a non-profit organization that aims to help people gain access to medical advice from certified medical professionals on the go!"
                })]
            })]
        }), b.jsxs("div", {
            id: "greyInfoBox",
            children: [b.jsxs("div", {
                children: [b.jsx("p", {
                    children: "Normally you have to wait several days and spend a lot of money, just so that you could have a doctor answer your question about health. Fortunately, these constraints are reduced, because you can message them now!"
                }), b.jsx("button", {
                    onClick: () => r("login"),
                    children: "Find a Doctor"
                })]
            }), b.jsx("div", {
                children: b.jsx("img", {
                    alt: "doctor picture",
                    src: TA,
                    style: {
                        width: "40%"
                    }
                })
            })]
        }), b.jsxs("div", {
            id: "signUpBottom",
            children: [b.jsx("p", {
                style: {},
                children: "Want to Join?"
            }), b.jsx("button", {
                onClick: () => r("login"),
                children: "Sign Up Today"
            })]
        })]
    })
}
const SA = () => {}
;
var rv = {};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IT = function(r) {
    const e = [];
    let t = 0;
    for (let s = 0; s < r.length; s++) {
        let o = r.charCodeAt(s);
        o < 128 ? e[t++] = o : o < 2048 ? (e[t++] = o >> 6 | 192,
        e[t++] = o & 63 | 128) : (o & 64512) === 55296 && s + 1 < r.length && (r.charCodeAt(s + 1) & 64512) === 56320 ? (o = 65536 + ((o & 1023) << 10) + (r.charCodeAt(++s) & 1023),
        e[t++] = o >> 18 | 240,
        e[t++] = o >> 12 & 63 | 128,
        e[t++] = o >> 6 & 63 | 128,
        e[t++] = o & 63 | 128) : (e[t++] = o >> 12 | 224,
        e[t++] = o >> 6 & 63 | 128,
        e[t++] = o & 63 | 128)
    }
    return e
}
  , AA = function(r) {
    const e = [];
    let t = 0
      , s = 0;
    for (; t < r.length; ) {
        const o = r[t++];
        if (o < 128)
            e[s++] = String.fromCharCode(o);
        else if (o > 191 && o < 224) {
            const l = r[t++];
            e[s++] = String.fromCharCode((o & 31) << 6 | l & 63)
        } else if (o > 239 && o < 365) {
            const l = r[t++]
              , f = r[t++]
              , d = r[t++]
              , v = ((o & 7) << 18 | (l & 63) << 12 | (f & 63) << 6 | d & 63) - 65536;
            e[s++] = String.fromCharCode(55296 + (v >> 10)),
            e[s++] = String.fromCharCode(56320 + (v & 1023))
        } else {
            const l = r[t++]
              , f = r[t++];
            e[s++] = String.fromCharCode((o & 15) << 12 | (l & 63) << 6 | f & 63)
        }
    }
    return e.join("")
}
  , wT = {
    byteToCharMap_: null,
    charToByteMap_: null,
    byteToCharMapWebSafe_: null,
    charToByteMapWebSafe_: null,
    ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
    get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + "+/="
    },
    get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + "-_."
    },
    HAS_NATIVE_SUPPORT: typeof atob == "function",
    encodeByteArray(r, e) {
        if (!Array.isArray(r))
            throw Error("encodeByteArray takes an array as a parameter");
        this.init_();
        const t = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_
          , s = [];
        for (let o = 0; o < r.length; o += 3) {
            const l = r[o]
              , f = o + 1 < r.length
              , d = f ? r[o + 1] : 0
              , v = o + 2 < r.length
              , y = v ? r[o + 2] : 0
              , T = l >> 2
              , A = (l & 3) << 4 | d >> 4;
            let I = (d & 15) << 2 | y >> 6
              , V = y & 63;
            v || (V = 64,
            f || (I = 64)),
            s.push(t[T], t[A], t[I], t[V])
        }
        return s.join("")
    },
    encodeString(r, e) {
        return this.HAS_NATIVE_SUPPORT && !e ? btoa(r) : this.encodeByteArray(IT(r), e)
    },
    decodeString(r, e) {
        return this.HAS_NATIVE_SUPPORT && !e ? atob(r) : AA(this.decodeStringToByteArray(r, e))
    },
    decodeStringToByteArray(r, e) {
        this.init_();
        const t = e ? this.charToByteMapWebSafe_ : this.charToByteMap_
          , s = [];
        for (let o = 0; o < r.length; ) {
            const l = t[r.charAt(o++)]
              , d = o < r.length ? t[r.charAt(o)] : 0;
            ++o;
            const y = o < r.length ? t[r.charAt(o)] : 64;
            ++o;
            const A = o < r.length ? t[r.charAt(o)] : 64;
            if (++o,
            l == null || d == null || y == null || A == null)
                throw new CA;
            const I = l << 2 | d >> 4;
            if (s.push(I),
            y !== 64) {
                const V = d << 4 & 240 | y >> 2;
                if (s.push(V),
                A !== 64) {
                    const q = y << 6 & 192 | A;
                    s.push(q)
                }
            }
        }
        return s
    },
    init_() {
        if (!this.byteToCharMap_) {
            this.byteToCharMap_ = {},
            this.charToByteMap_ = {},
            this.byteToCharMapWebSafe_ = {},
            this.charToByteMapWebSafe_ = {};
            for (let r = 0; r < this.ENCODED_VALS.length; r++)
                this.byteToCharMap_[r] = this.ENCODED_VALS.charAt(r),
                this.charToByteMap_[this.byteToCharMap_[r]] = r,
                this.byteToCharMapWebSafe_[r] = this.ENCODED_VALS_WEBSAFE.charAt(r),
                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[r]] = r,
                r >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(r)] = r,
                this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(r)] = r)
        }
    }
};
class CA extends Error {
    constructor() {
        super(...arguments),
        this.name = "DecodeBase64StringError"
    }
}
const RA = function(r) {
    const e = IT(r);
    return wT.encodeByteArray(e, !0)
}
  , Cc = function(r) {
    return RA(r).replace(/\./g, "")
}
  , bT = function(r) {
    try {
        return wT.decodeString(r, !0)
    } catch (e) {
        console.error("base64Decode failed: ", e)
    }
    return null
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function IA() {
    if (typeof self < "u")
        return self;
    if (typeof window < "u")
        return window;
    if (typeof global < "u")
        return global;
    throw new Error("Unable to locate global object.")
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const wA = () => IA().__FIREBASE_DEFAULTS__
  , bA = () => {
    if (typeof process > "u" || typeof rv > "u")
        return;
    const r = rv.__FIREBASE_DEFAULTS__;
    if (r)
        return JSON.parse(r)
}
  , DA = () => {
    if (typeof document > "u")
        return;
    let r;
    try {
        r = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)
    } catch {
        return
    }
    const e = r && bT(r[1]);
    return e && JSON.parse(e)
}
  , Qc = () => {
    try {
        return SA() || wA() || bA() || DA()
    } catch (r) {
        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${r}`);
        return
    }
}
  , DT = r => {
    var e, t;
    return (t = (e = Qc()) === null || e === void 0 ? void 0 : e.emulatorHosts) === null || t === void 0 ? void 0 : t[r]
}
  , MA = r => {
    const e = DT(r);
    if (!e)
        return;
    const t = e.lastIndexOf(":");
    if (t <= 0 || t + 1 === e.length)
        throw new Error(`Invalid host ${e} with no separate hostname and port!`);
    const s = parseInt(e.substring(t + 1), 10);
    return e[0] === "[" ? [e.substring(1, t - 1), s] : [e.substring(0, t), s]
}
  , MT = () => {
    var r;
    return (r = Qc()) === null || r === void 0 ? void 0 : r.config
}
  , NT = r => {
    var e;
    return (e = Qc()) === null || e === void 0 ? void 0 : e[`_${r}`]
}
;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NA {
    constructor() {
        this.reject = () => {}
        ,
        this.resolve = () => {}
        ,
        this.promise = new Promise( (e, t) => {
            this.resolve = e,
            this.reject = t
        }
        )
    }
    wrapCallback(e) {
        return (t, s) => {
            t ? this.reject(t) : this.resolve(s),
            typeof e == "function" && (this.promise.catch( () => {}
            ),
            e.length === 1 ? e(t) : e(t, s))
        }
    }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function xA(r, e) {
    if (r.uid)
        throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
    const t = {
        alg: "none",
        type: "JWT"
    }
      , s = e || "demo-project"
      , o = r.iat || 0
      , l = r.sub || r.user_id;
    if (!l)
        throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
    const f = Object.assign({
        iss: `https://securetoken.google.com/${s}`,
        aud: s,
        iat: o,
        exp: o + 3600,
        auth_time: o,
        sub: l,
        user_id: l,
        firebase: {
            sign_in_provider: "custom",
            identities: {}
        }
    }, r);
    return [Cc(JSON.stringify(t)), Cc(JSON.stringify(f)), ""].join(".")
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Jt() {
    return typeof navigator < "u" && typeof navigator.userAgent == "string" ? navigator.userAgent : ""
}
function PA() {
    return typeof window < "u" && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(Jt())
}
function OA() {
    var r;
    const e = (r = Qc()) === null || r === void 0 ? void 0 : r.forceEnvironment;
    if (e === "node")
        return !0;
    if (e === "browser")
        return !1;
    try {
        return Object.prototype.toString.call(global.process) === "[object process]"
    } catch {
        return !1
    }
}
function VA() {
    return typeof navigator < "u" && navigator.userAgent === "Cloudflare-Workers"
}
function UA() {
    const r = typeof chrome == "object" ? chrome.runtime : typeof browser == "object" ? browser.runtime : void 0;
    return typeof r == "object" && r.id !== void 0
}
function kA() {
    return typeof navigator == "object" && navigator.product === "ReactNative"
}
function LA() {
    const r = Jt();
    return r.indexOf("MSIE ") >= 0 || r.indexOf("Trident/") >= 0
}
function BA() {
    return !OA() && !!navigator.userAgent && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome")
}
function qA() {
    try {
        return typeof indexedDB == "object"
    } catch {
        return !1
    }
}
function zA() {
    return new Promise( (r, e) => {
        try {
            let t = !0;
            const s = "validate-browser-context-for-indexeddb-analytics-module"
              , o = self.indexedDB.open(s);
            o.onsuccess = () => {
                o.result.close(),
                t || self.indexedDB.deleteDatabase(s),
                r(!0)
            }
            ,
            o.onupgradeneeded = () => {
                t = !1
            }
            ,
            o.onerror = () => {
                var l;
                e(((l = o.error) === null || l === void 0 ? void 0 : l.message) || "")
            }
        } catch (t) {
            e(t)
        }
    }
    )
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const FA = "FirebaseError";
class Ki extends Error {
    constructor(e, t, s) {
        super(t),
        this.code = e,
        this.customData = s,
        this.name = FA,
        Object.setPrototypeOf(this, Ki.prototype),
        Error.captureStackTrace && Error.captureStackTrace(this, Al.prototype.create)
    }
}
class Al {
    constructor(e, t, s) {
        this.service = e,
        this.serviceName = t,
        this.errors = s
    }
    create(e, ...t) {
        const s = t[0] || {}
          , o = `${this.service}/${e}`
          , l = this.errors[e]
          , f = l ? HA(l, s) : "Error"
          , d = `${this.serviceName}: ${f} (${o}).`;
        return new Ki(o,d,s)
    }
}
function HA(r, e) {
    return r.replace(GA, (t, s) => {
        const o = e[s];
        return o != null ? String(o) : `<${s}?>`
    }
    )
}
const GA = /\{\$([^}]+)}/g;
function YA(r) {
    for (const e in r)
        if (Object.prototype.hasOwnProperty.call(r, e))
            return !1;
    return !0
}
function ws(r, e) {
    if (r === e)
        return !0;
    const t = Object.keys(r)
      , s = Object.keys(e);
    for (const o of t) {
        if (!s.includes(o))
            return !1;
        const l = r[o]
          , f = e[o];
        if (sv(l) && sv(f)) {
            if (!ws(l, f))
                return !1
        } else if (l !== f)
            return !1
    }
    for (const o of s)
        if (!t.includes(o))
            return !1;
    return !0
}
function sv(r) {
    return r !== null && typeof r == "object"
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Cl(r) {
    const e = [];
    for (const [t,s] of Object.entries(r))
        Array.isArray(s) ? s.forEach(o => {
            e.push(encodeURIComponent(t) + "=" + encodeURIComponent(o))
        }
        ) : e.push(encodeURIComponent(t) + "=" + encodeURIComponent(s));
    return e.length ? "&" + e.join("&") : ""
}
function sl(r) {
    const e = {};
    return r.replace(/^\?/, "").split("&").forEach(s => {
        if (s) {
            const [o,l] = s.split("=");
            e[decodeURIComponent(o)] = decodeURIComponent(l)
        }
    }
    ),
    e
}
function ol(r) {
    const e = r.indexOf("?");
    if (!e)
        return "";
    const t = r.indexOf("#", e);
    return r.substring(e, t > 0 ? t : void 0)
}
function KA(r, e) {
    const t = new QA(r,e);
    return t.subscribe.bind(t)
}
class QA {
    constructor(e, t) {
        this.observers = [],
        this.unsubscribes = [],
        this.observerCount = 0,
        this.task = Promise.resolve(),
        this.finalized = !1,
        this.onNoObservers = t,
        this.task.then( () => {
            e(this)
        }
        ).catch(s => {
            this.error(s)
        }
        )
    }
    next(e) {
        this.forEachObserver(t => {
            t.next(e)
        }
        )
    }
    error(e) {
        this.forEachObserver(t => {
            t.error(e)
        }
        ),
        this.close(e)
    }
    complete() {
        this.forEachObserver(e => {
            e.complete()
        }
        ),
        this.close()
    }
    subscribe(e, t, s) {
        let o;
        if (e === void 0 && t === void 0 && s === void 0)
            throw new Error("Missing Observer.");
        XA(e, ["next", "error", "complete"]) ? o = e : o = {
            next: e,
            error: t,
            complete: s
        },
        o.next === void 0 && (o.next = md),
        o.error === void 0 && (o.error = md),
        o.complete === void 0 && (o.complete = md);
        const l = this.unsubscribeOne.bind(this, this.observers.length);
        return this.finalized && this.task.then( () => {
            try {
                this.finalError ? o.error(this.finalError) : o.complete()
            } catch {}
        }
        ),
        this.observers.push(o),
        l
    }
    unsubscribeOne(e) {
        this.observers === void 0 || this.observers[e] === void 0 || (delete this.observers[e],
        this.observerCount -= 1,
        this.observerCount === 0 && this.onNoObservers !== void 0 && this.onNoObservers(this))
    }
    forEachObserver(e) {
        if (!this.finalized)
            for (let t = 0; t < this.observers.length; t++)
                this.sendOne(t, e)
    }
    sendOne(e, t) {
        this.task.then( () => {
            if (this.observers !== void 0 && this.observers[e] !== void 0)
                try {
                    t(this.observers[e])
                } catch (s) {
                    typeof console < "u" && console.error && console.error(s)
                }
        }
        )
    }
    close(e) {
        this.finalized || (this.finalized = !0,
        e !== void 0 && (this.finalError = e),
        this.task.then( () => {
            this.observers = void 0,
            this.onNoObservers = void 0
        }
        ))
    }
}
function XA(r, e) {
    if (typeof r != "object" || r === null)
        return !1;
    for (const t of e)
        if (t in r && typeof r[t] == "function")
            return !0;
    return !1
}
function md() {}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function vn(r) {
    return r && r._delegate ? r._delegate : r
}
class bs {
    constructor(e, t, s) {
        this.name = e,
        this.instanceFactory = t,
        this.type = s,
        this.multipleInstances = !1,
        this.serviceProps = {},
        this.instantiationMode = "LAZY",
        this.onInstanceCreated = null
    }
    setInstantiationMode(e) {
        return this.instantiationMode = e,
        this
    }
    setMultipleInstances(e) {
        return this.multipleInstances = e,
        this
    }
    setServiceProps(e) {
        return this.serviceProps = e,
        this
    }
    setInstanceCreatedCallback(e) {
        return this.onInstanceCreated = e,
        this
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ss = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $A {
    constructor(e, t) {
        this.name = e,
        this.container = t,
        this.component = null,
        this.instances = new Map,
        this.instancesDeferred = new Map,
        this.instancesOptions = new Map,
        this.onInitCallbacks = new Map
    }
    get(e) {
        const t = this.normalizeInstanceIdentifier(e);
        if (!this.instancesDeferred.has(t)) {
            const s = new NA;
            if (this.instancesDeferred.set(t, s),
            this.isInitialized(t) || this.shouldAutoInitialize())
                try {
                    const o = this.getOrInitializeService({
                        instanceIdentifier: t
                    });
                    o && s.resolve(o)
                } catch {}
        }
        return this.instancesDeferred.get(t).promise
    }
    getImmediate(e) {
        var t;
        const s = this.normalizeInstanceIdentifier(e == null ? void 0 : e.identifier)
          , o = (t = e == null ? void 0 : e.optional) !== null && t !== void 0 ? t : !1;
        if (this.isInitialized(s) || this.shouldAutoInitialize())
            try {
                return this.getOrInitializeService({
                    instanceIdentifier: s
                })
            } catch (l) {
                if (o)
                    return null;
                throw l
            }
        else {
            if (o)
                return null;
            throw Error(`Service ${this.name} is not available`)
        }
    }
    getComponent() {
        return this.component
    }
    setComponent(e) {
        if (e.name !== this.name)
            throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
        if (this.component)
            throw Error(`Component for ${this.name} has already been provided`);
        if (this.component = e,
        !!this.shouldAutoInitialize()) {
            if (jA(e))
                try {
                    this.getOrInitializeService({
                        instanceIdentifier: Ss
                    })
                } catch {}
            for (const [t,s] of this.instancesDeferred.entries()) {
                const o = this.normalizeInstanceIdentifier(t);
                try {
                    const l = this.getOrInitializeService({
                        instanceIdentifier: o
                    });
                    s.resolve(l)
                } catch {}
            }
        }
    }
    clearInstance(e=Ss) {
        this.instancesDeferred.delete(e),
        this.instancesOptions.delete(e),
        this.instances.delete(e)
    }
    async delete() {
        const e = Array.from(this.instances.values());
        await Promise.all([...e.filter(t => "INTERNAL"in t).map(t => t.INTERNAL.delete()), ...e.filter(t => "_delete"in t).map(t => t._delete())])
    }
    isComponentSet() {
        return this.component != null
    }
    isInitialized(e=Ss) {
        return this.instances.has(e)
    }
    getOptions(e=Ss) {
        return this.instancesOptions.get(e) || {}
    }
    initialize(e={}) {
        const {options: t={}} = e
          , s = this.normalizeInstanceIdentifier(e.instanceIdentifier);
        if (this.isInitialized(s))
            throw Error(`${this.name}(${s}) has already been initialized`);
        if (!this.isComponentSet())
            throw Error(`Component ${this.name} has not been registered yet`);
        const o = this.getOrInitializeService({
            instanceIdentifier: s,
            options: t
        });
        for (const [l,f] of this.instancesDeferred.entries()) {
            const d = this.normalizeInstanceIdentifier(l);
            s === d && f.resolve(o)
        }
        return o
    }
    onInit(e, t) {
        var s;
        const o = this.normalizeInstanceIdentifier(t)
          , l = (s = this.onInitCallbacks.get(o)) !== null && s !== void 0 ? s : new Set;
        l.add(e),
        this.onInitCallbacks.set(o, l);
        const f = this.instances.get(o);
        return f && e(f, o),
        () => {
            l.delete(e)
        }
    }
    invokeOnInitCallbacks(e, t) {
        const s = this.onInitCallbacks.get(t);
        if (s)
            for (const o of s)
                try {
                    o(e, t)
                } catch {}
    }
    getOrInitializeService({instanceIdentifier: e, options: t={}}) {
        let s = this.instances.get(e);
        if (!s && this.component && (s = this.component.instanceFactory(this.container, {
            instanceIdentifier: JA(e),
            options: t
        }),
        this.instances.set(e, s),
        this.instancesOptions.set(e, t),
        this.invokeOnInitCallbacks(s, e),
        this.component.onInstanceCreated))
            try {
                this.component.onInstanceCreated(this.container, e, s)
            } catch {}
        return s || null
    }
    normalizeInstanceIdentifier(e=Ss) {
        return this.component ? this.component.multipleInstances ? e : Ss : e
    }
    shouldAutoInitialize() {
        return !!this.component && this.component.instantiationMode !== "EXPLICIT"
    }
}
function JA(r) {
    return r === Ss ? void 0 : r
}
function jA(r) {
    return r.instantiationMode === "EAGER"
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WA {
    constructor(e) {
        this.name = e,
        this.providers = new Map
    }
    addComponent(e) {
        const t = this.getProvider(e.name);
        if (t.isComponentSet())
            throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
        t.setComponent(e)
    }
    addOrOverwriteComponent(e) {
        this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name),
        this.addComponent(e)
    }
    getProvider(e) {
        if (this.providers.has(e))
            return this.providers.get(e);
        const t = new $A(e,this);
        return this.providers.set(e, t),
        t
    }
    getProviders() {
        return Array.from(this.providers.values())
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var xe;
(function(r) {
    r[r.DEBUG = 0] = "DEBUG",
    r[r.VERBOSE = 1] = "VERBOSE",
    r[r.INFO = 2] = "INFO",
    r[r.WARN = 3] = "WARN",
    r[r.ERROR = 4] = "ERROR",
    r[r.SILENT = 5] = "SILENT"
}
)(xe || (xe = {}));
const ZA = {
    debug: xe.DEBUG,
    verbose: xe.VERBOSE,
    info: xe.INFO,
    warn: xe.WARN,
    error: xe.ERROR,
    silent: xe.SILENT
}
  , eC = xe.INFO
  , tC = {
    [xe.DEBUG]: "log",
    [xe.VERBOSE]: "log",
    [xe.INFO]: "info",
    [xe.WARN]: "warn",
    [xe.ERROR]: "error"
}
  , nC = (r, e, ...t) => {
    if (e < r.logLevel)
        return;
    const s = new Date().toISOString()
      , o = tC[e];
    if (o)
        console[o](`[${s}]  ${r.name}:`, ...t);
    else
        throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`)
}
;
class tp {
    constructor(e) {
        this.name = e,
        this._logLevel = eC,
        this._logHandler = nC,
        this._userLogHandler = null
    }
    get logLevel() {
        return this._logLevel
    }
    set logLevel(e) {
        if (!(e in xe))
            throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
        this._logLevel = e
    }
    setLogLevel(e) {
        this._logLevel = typeof e == "string" ? ZA[e] : e
    }
    get logHandler() {
        return this._logHandler
    }
    set logHandler(e) {
        if (typeof e != "function")
            throw new TypeError("Value assigned to `logHandler` must be a function");
        this._logHandler = e
    }
    get userLogHandler() {
        return this._userLogHandler
    }
    set userLogHandler(e) {
        this._userLogHandler = e
    }
    debug(...e) {
        this._userLogHandler && this._userLogHandler(this, xe.DEBUG, ...e),
        this._logHandler(this, xe.DEBUG, ...e)
    }
    log(...e) {
        this._userLogHandler && this._userLogHandler(this, xe.VERBOSE, ...e),
        this._logHandler(this, xe.VERBOSE, ...e)
    }
    info(...e) {
        this._userLogHandler && this._userLogHandler(this, xe.INFO, ...e),
        this._logHandler(this, xe.INFO, ...e)
    }
    warn(...e) {
        this._userLogHandler && this._userLogHandler(this, xe.WARN, ...e),
        this._logHandler(this, xe.WARN, ...e)
    }
    error(...e) {
        this._userLogHandler && this._userLogHandler(this, xe.ERROR, ...e),
        this._logHandler(this, xe.ERROR, ...e)
    }
}
const iC = (r, e) => e.some(t => r instanceof t);
let ov, av;
function rC() {
    return ov || (ov = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])
}
function sC() {
    return av || (av = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])
}
const xT = new WeakMap
  , Rd = new WeakMap
  , PT = new WeakMap
  , gd = new WeakMap
  , np = new WeakMap;
function oC(r) {
    const e = new Promise( (t, s) => {
        const o = () => {
            r.removeEventListener("success", l),
            r.removeEventListener("error", f)
        }
          , l = () => {
            t(Ir(r.result)),
            o()
        }
          , f = () => {
            s(r.error),
            o()
        }
        ;
        r.addEventListener("success", l),
        r.addEventListener("error", f)
    }
    );
    return e.then(t => {
        t instanceof IDBCursor && xT.set(t, r)
    }
    ).catch( () => {}
    ),
    np.set(e, r),
    e
}
function aC(r) {
    if (Rd.has(r))
        return;
    const e = new Promise( (t, s) => {
        const o = () => {
            r.removeEventListener("complete", l),
            r.removeEventListener("error", f),
            r.removeEventListener("abort", f)
        }
          , l = () => {
            t(),
            o()
        }
          , f = () => {
            s(r.error || new DOMException("AbortError","AbortError")),
            o()
        }
        ;
        r.addEventListener("complete", l),
        r.addEventListener("error", f),
        r.addEventListener("abort", f)
    }
    );
    Rd.set(r, e)
}
let Id = {
    get(r, e, t) {
        if (r instanceof IDBTransaction) {
            if (e === "done")
                return Rd.get(r);
            if (e === "objectStoreNames")
                return r.objectStoreNames || PT.get(r);
            if (e === "store")
                return t.objectStoreNames[1] ? void 0 : t.objectStore(t.objectStoreNames[0])
        }
        return Ir(r[e])
    },
    set(r, e, t) {
        return r[e] = t,
        !0
    },
    has(r, e) {
        return r instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in r
    }
};
function lC(r) {
    Id = r(Id)
}
function uC(r) {
    return r === IDBDatabase.prototype.transaction && !("objectStoreNames"in IDBTransaction.prototype) ? function(e, ...t) {
        const s = r.call(yd(this), e, ...t);
        return PT.set(s, e.sort ? e.sort() : [e]),
        Ir(s)
    }
    : sC().includes(r) ? function(...e) {
        return r.apply(yd(this), e),
        Ir(xT.get(this))
    }
    : function(...e) {
        return Ir(r.apply(yd(this), e))
    }
}
function cC(r) {
    return typeof r == "function" ? uC(r) : (r instanceof IDBTransaction && aC(r),
    iC(r, rC()) ? new Proxy(r,Id) : r)
}
function Ir(r) {
    if (r instanceof IDBRequest)
        return oC(r);
    if (gd.has(r))
        return gd.get(r);
    const e = cC(r);
    return e !== r && (gd.set(r, e),
    np.set(e, r)),
    e
}
const yd = r => np.get(r);
function fC(r, e, {blocked: t, upgrade: s, blocking: o, terminated: l}={}) {
    const f = indexedDB.open(r, e)
      , d = Ir(f);
    return s && f.addEventListener("upgradeneeded", v => {
        s(Ir(f.result), v.oldVersion, v.newVersion, Ir(f.transaction), v)
    }
    ),
    t && f.addEventListener("blocked", v => t(v.oldVersion, v.newVersion, v)),
    d.then(v => {
        l && v.addEventListener("close", () => l()),
        o && v.addEventListener("versionchange", y => o(y.oldVersion, y.newVersion, y))
    }
    ).catch( () => {}
    ),
    d
}
const hC = ["get", "getKey", "getAll", "getAllKeys", "count"]
  , dC = ["put", "add", "delete", "clear"]
  , vd = new Map;
function lv(r, e) {
    if (!(r instanceof IDBDatabase && !(e in r) && typeof e == "string"))
        return;
    if (vd.get(e))
        return vd.get(e);
    const t = e.replace(/FromIndex$/, "")
      , s = e !== t
      , o = dC.includes(t);
    if (!(t in (s ? IDBIndex : IDBObjectStore).prototype) || !(o || hC.includes(t)))
        return;
    const l = async function(f, ...d) {
        const v = this.transaction(f, o ? "readwrite" : "readonly");
        let y = v.store;
        return s && (y = y.index(d.shift())),
        (await Promise.all([y[t](...d), o && v.done]))[0]
    };
    return vd.set(e, l),
    l
}
lC(r => ({
    ...r,
    get: (e, t, s) => lv(e, t) || r.get(e, t, s),
    has: (e, t) => !!lv(e, t) || r.has(e, t)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class pC {
    constructor(e) {
        this.container = e
    }
    getPlatformInfoString() {
        return this.container.getProviders().map(t => {
            if (mC(t)) {
                const s = t.getImmediate();
                return `${s.library}/${s.version}`
            } else
                return null
        }
        ).filter(t => t).join(" ")
    }
}
function mC(r) {
    const e = r.getComponent();
    return (e == null ? void 0 : e.type) === "VERSION"
}
const wd = "@firebase/app"
  , uv = "0.11.5";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Hi = new tp("@firebase/app")
  , gC = "@firebase/app-compat"
  , yC = "@firebase/analytics-compat"
  , vC = "@firebase/analytics"
  , _C = "@firebase/app-check-compat"
  , TC = "@firebase/app-check"
  , EC = "@firebase/auth"
  , SC = "@firebase/auth-compat"
  , AC = "@firebase/database"
  , CC = "@firebase/data-connect"
  , RC = "@firebase/database-compat"
  , IC = "@firebase/functions"
  , wC = "@firebase/functions-compat"
  , bC = "@firebase/installations"
  , DC = "@firebase/installations-compat"
  , MC = "@firebase/messaging"
  , NC = "@firebase/messaging-compat"
  , xC = "@firebase/performance"
  , PC = "@firebase/performance-compat"
  , OC = "@firebase/remote-config"
  , VC = "@firebase/remote-config-compat"
  , UC = "@firebase/storage"
  , kC = "@firebase/storage-compat"
  , LC = "@firebase/firestore"
  , BC = "@firebase/vertexai"
  , qC = "@firebase/firestore-compat"
  , zC = "firebase"
  , FC = "11.6.1";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const bd = "[DEFAULT]"
  , HC = {
    [wd]: "fire-core",
    [gC]: "fire-core-compat",
    [vC]: "fire-analytics",
    [yC]: "fire-analytics-compat",
    [TC]: "fire-app-check",
    [_C]: "fire-app-check-compat",
    [EC]: "fire-auth",
    [SC]: "fire-auth-compat",
    [AC]: "fire-rtdb",
    [CC]: "fire-data-connect",
    [RC]: "fire-rtdb-compat",
    [IC]: "fire-fn",
    [wC]: "fire-fn-compat",
    [bC]: "fire-iid",
    [DC]: "fire-iid-compat",
    [MC]: "fire-fcm",
    [NC]: "fire-fcm-compat",
    [xC]: "fire-perf",
    [PC]: "fire-perf-compat",
    [OC]: "fire-rc",
    [VC]: "fire-rc-compat",
    [UC]: "fire-gcs",
    [kC]: "fire-gcs-compat",
    [LC]: "fire-fst",
    [qC]: "fire-fst-compat",
    [BC]: "fire-vertex",
    "fire-js": "fire-js",
    [zC]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Rc = new Map
  , GC = new Map
  , Dd = new Map;
function cv(r, e) {
    try {
        r.container.addComponent(e)
    } catch (t) {
        Hi.debug(`Component ${e.name} failed to register with FirebaseApp ${r.name}`, t)
    }
}
function ko(r) {
    const e = r.name;
    if (Dd.has(e))
        return Hi.debug(`There were multiple attempts to register component ${e}.`),
        !1;
    Dd.set(e, r);
    for (const t of Rc.values())
        cv(t, r);
    for (const t of GC.values())
        cv(t, r);
    return !0
}
function ip(r, e) {
    const t = r.container.getProvider("heartbeat").getImmediate({
        optional: !0
    });
    return t && t.triggerHeartbeat(),
    r.container.getProvider(e)
}
function yn(r) {
    return r == null ? !1 : r.settings !== void 0
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const YC = {
    "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
    "bad-app-name": "Illegal App name: '{$appName}'",
    "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
    "app-deleted": "Firebase App named '{$appName}' already deleted",
    "server-app-deleted": "Firebase Server App has been deleted",
    "no-options": "Need to provide options, when not being deployed to hosting via source.",
    "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
    "invalid-log-argument": "First argument to `onLog` must be null or a function.",
    "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
    "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
    "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
    "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
    "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
    "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments."
}
  , wr = new Al("app","Firebase",YC);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class KC {
    constructor(e, t, s) {
        this._isDeleted = !1,
        this._options = Object.assign({}, e),
        this._config = Object.assign({}, t),
        this._name = t.name,
        this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled,
        this._container = s,
        this.container.addComponent(new bs("app", () => this,"PUBLIC"))
    }
    get automaticDataCollectionEnabled() {
        return this.checkDestroyed(),
        this._automaticDataCollectionEnabled
    }
    set automaticDataCollectionEnabled(e) {
        this.checkDestroyed(),
        this._automaticDataCollectionEnabled = e
    }
    get name() {
        return this.checkDestroyed(),
        this._name
    }
    get options() {
        return this.checkDestroyed(),
        this._options
    }
    get config() {
        return this.checkDestroyed(),
        this._config
    }
    get container() {
        return this._container
    }
    get isDeleted() {
        return this._isDeleted
    }
    set isDeleted(e) {
        this._isDeleted = e
    }
    checkDestroyed() {
        if (this.isDeleted)
            throw wr.create("app-deleted", {
                appName: this._name
            })
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ho = FC;
function OT(r, e={}) {
    let t = r;
    typeof e != "object" && (e = {
        name: e
    });
    const s = Object.assign({
        name: bd,
        automaticDataCollectionEnabled: !1
    }, e)
      , o = s.name;
    if (typeof o != "string" || !o)
        throw wr.create("bad-app-name", {
            appName: String(o)
        });
    if (t || (t = MT()),
    !t)
        throw wr.create("no-options");
    const l = Rc.get(o);
    if (l) {
        if (ws(t, l.options) && ws(s, l.config))
            return l;
        throw wr.create("duplicate-app", {
            appName: o
        })
    }
    const f = new WA(o);
    for (const v of Dd.values())
        f.addComponent(v);
    const d = new KC(t,s,f);
    return Rc.set(o, d),
    d
}
function VT(r=bd) {
    const e = Rc.get(r);
    if (!e && r === bd && MT())
        return OT();
    if (!e)
        throw wr.create("no-app", {
            appName: r
        });
    return e
}
function br(r, e, t) {
    var s;
    let o = (s = HC[r]) !== null && s !== void 0 ? s : r;
    t && (o += `-${t}`);
    const l = o.match(/\s|\//)
      , f = e.match(/\s|\//);
    if (l || f) {
        const d = [`Unable to register library "${o}" with version "${e}":`];
        l && d.push(`library name "${o}" contains illegal characters (whitespace or "/")`),
        l && f && d.push("and"),
        f && d.push(`version name "${e}" contains illegal characters (whitespace or "/")`),
        Hi.warn(d.join(" "));
        return
    }
    ko(new bs(`${o}-version`, () => ({
        library: o,
        version: e
    }),"VERSION"))
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const QC = "firebase-heartbeat-database"
  , XC = 1
  , dl = "firebase-heartbeat-store";
let _d = null;
function UT() {
    return _d || (_d = fC(QC, XC, {
        upgrade: (r, e) => {
            switch (e) {
            case 0:
                try {
                    r.createObjectStore(dl)
                } catch (t) {
                    console.warn(t)
                }
            }
        }
    }).catch(r => {
        throw wr.create("idb-open", {
            originalErrorMessage: r.message
        })
    }
    )),
    _d
}
async function $C(r) {
    try {
        const t = (await UT()).transaction(dl)
          , s = await t.objectStore(dl).get(kT(r));
        return await t.done,
        s
    } catch (e) {
        if (e instanceof Ki)
            Hi.warn(e.message);
        else {
            const t = wr.create("idb-get", {
                originalErrorMessage: e == null ? void 0 : e.message
            });
            Hi.warn(t.message)
        }
    }
}
async function fv(r, e) {
    try {
        const s = (await UT()).transaction(dl, "readwrite");
        await s.objectStore(dl).put(e, kT(r)),
        await s.done
    } catch (t) {
        if (t instanceof Ki)
            Hi.warn(t.message);
        else {
            const s = wr.create("idb-set", {
                originalErrorMessage: t == null ? void 0 : t.message
            });
            Hi.warn(s.message)
        }
    }
}
function kT(r) {
    return `${r.name}!${r.options.appId}`
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const JC = 1024
  , jC = 30;
class WC {
    constructor(e) {
        this.container = e,
        this._heartbeatsCache = null;
        const t = this.container.getProvider("app").getImmediate();
        this._storage = new eR(t),
        this._heartbeatsCachePromise = this._storage.read().then(s => (this._heartbeatsCache = s,
        s))
    }
    async triggerHeartbeat() {
        var e, t;
        try {
            const o = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString()
              , l = hv();
            if (((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null && (this._heartbeatsCache = await this._heartbeatsCachePromise,
            ((t = this._heartbeatsCache) === null || t === void 0 ? void 0 : t.heartbeats) == null) || this._heartbeatsCache.lastSentHeartbeatDate === l || this._heartbeatsCache.heartbeats.some(f => f.date === l))
                return;
            if (this._heartbeatsCache.heartbeats.push({
                date: l,
                agent: o
            }),
            this._heartbeatsCache.heartbeats.length > jC) {
                const f = tR(this._heartbeatsCache.heartbeats);
                this._heartbeatsCache.heartbeats.splice(f, 1)
            }
            return this._storage.overwrite(this._heartbeatsCache)
        } catch (s) {
            Hi.warn(s)
        }
    }
    async getHeartbeatsHeader() {
        var e;
        try {
            if (this._heartbeatsCache === null && await this._heartbeatsCachePromise,
            ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0)
                return "";
            const t = hv()
              , {heartbeatsToSend: s, unsentEntries: o} = ZC(this._heartbeatsCache.heartbeats)
              , l = Cc(JSON.stringify({
                version: 2,
                heartbeats: s
            }));
            return this._heartbeatsCache.lastSentHeartbeatDate = t,
            o.length > 0 ? (this._heartbeatsCache.heartbeats = o,
            await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [],
            this._storage.overwrite(this._heartbeatsCache)),
            l
        } catch (t) {
            return Hi.warn(t),
            ""
        }
    }
}
function hv() {
    return new Date().toISOString().substring(0, 10)
}
function ZC(r, e=JC) {
    const t = [];
    let s = r.slice();
    for (const o of r) {
        const l = t.find(f => f.agent === o.agent);
        if (l) {
            if (l.dates.push(o.date),
            dv(t) > e) {
                l.dates.pop();
                break
            }
        } else if (t.push({
            agent: o.agent,
            dates: [o.date]
        }),
        dv(t) > e) {
            t.pop();
            break
        }
        s = s.slice(1)
    }
    return {
        heartbeatsToSend: t,
        unsentEntries: s
    }
}
class eR {
    constructor(e) {
        this.app = e,
        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck()
    }
    async runIndexedDBEnvironmentCheck() {
        return qA() ? zA().then( () => !0).catch( () => !1) : !1
    }
    async read() {
        if (await this._canUseIndexedDBPromise) {
            const t = await $C(this.app);
            return t != null && t.heartbeats ? t : {
                heartbeats: []
            }
        } else
            return {
                heartbeats: []
            }
    }
    async overwrite(e) {
        var t;
        if (await this._canUseIndexedDBPromise) {
            const o = await this.read();
            return fv(this.app, {
                lastSentHeartbeatDate: (t = e.lastSentHeartbeatDate) !== null && t !== void 0 ? t : o.lastSentHeartbeatDate,
                heartbeats: e.heartbeats
            })
        } else
            return
    }
    async add(e) {
        var t;
        if (await this._canUseIndexedDBPromise) {
            const o = await this.read();
            return fv(this.app, {
                lastSentHeartbeatDate: (t = e.lastSentHeartbeatDate) !== null && t !== void 0 ? t : o.lastSentHeartbeatDate,
                heartbeats: [...o.heartbeats, ...e.heartbeats]
            })
        } else
            return
    }
}
function dv(r) {
    return Cc(JSON.stringify({
        version: 2,
        heartbeats: r
    })).length
}
function tR(r) {
    if (r.length === 0)
        return -1;
    let e = 0
      , t = r[0].date;
    for (let s = 1; s < r.length; s++)
        r[s].date < t && (t = r[s].date,
        e = s);
    return e
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function nR(r) {
    ko(new bs("platform-logger",e => new pC(e),"PRIVATE")),
    ko(new bs("heartbeat",e => new WC(e),"PRIVATE")),
    br(wd, uv, r),
    br(wd, uv, "esm2017"),
    br("fire-js", "")
}
nR("");
var iR = "firebase"
  , rR = "11.6.1";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
br(iR, rR, "app");
function rp(r, e) {
    var t = {};
    for (var s in r)
        Object.prototype.hasOwnProperty.call(r, s) && e.indexOf(s) < 0 && (t[s] = r[s]);
    if (r != null && typeof Object.getOwnPropertySymbols == "function")
        for (var o = 0, s = Object.getOwnPropertySymbols(r); o < s.length; o++)
            e.indexOf(s[o]) < 0 && Object.prototype.propertyIsEnumerable.call(r, s[o]) && (t[s[o]] = r[s[o]]);
    return t
}
function LT() {
    return {
        "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
    }
}
const sR = LT
  , BT = new Al("auth","Firebase",LT());
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ic = new tp("@firebase/auth");
function oR(r, ...e) {
    Ic.logLevel <= xe.WARN && Ic.warn(`Auth (${Ho}): ${r}`, ...e)
}
function pc(r, ...e) {
    Ic.logLevel <= xe.ERROR && Ic.error(`Auth (${Ho}): ${r}`, ...e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function xn(r, ...e) {
    throw op(r, ...e)
}
function Hn(r, ...e) {
    return op(r, ...e)
}
function sp(r, e, t) {
    const s = Object.assign(Object.assign({}, sR()), {
        [e]: t
    });
    return new Al("auth","Firebase",s).create(e, {
        appName: r.name
    })
}
function qi(r) {
    return sp(r, "operation-not-supported-in-this-environment", "Operations that alter the current user are not supported in conjunction with FirebaseServerApp")
}
function aR(r, e, t) {
    const s = t;
    if (!(e instanceof s))
        throw s.name !== e.constructor.name && xn(r, "argument-error"),
        sp(r, "argument-error", `Type of ${e.constructor.name} does not match expected instance.Did you pass a reference from a different Auth SDK?`)
}
function op(r, ...e) {
    if (typeof r != "string") {
        const t = e[0]
          , s = [...e.slice(1)];
        return s[0] && (s[0].appName = r.name),
        r._errorFactory.create(t, ...s)
    }
    return BT.create(r, ...e)
}
function ve(r, e, ...t) {
    if (!r)
        throw op(e, ...t)
}
function Li(r) {
    const e = "INTERNAL ASSERTION FAILED: " + r;
    throw pc(e),
    new Error(e)
}
function Gi(r, e) {
    r || Li(e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Md() {
    var r;
    return typeof self < "u" && ((r = self.location) === null || r === void 0 ? void 0 : r.href) || ""
}
function lR() {
    return pv() === "http:" || pv() === "https:"
}
function pv() {
    var r;
    return typeof self < "u" && ((r = self.location) === null || r === void 0 ? void 0 : r.protocol) || null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function uR() {
    return typeof navigator < "u" && navigator && "onLine"in navigator && typeof navigator.onLine == "boolean" && (lR() || UA() || "connection"in navigator) ? navigator.onLine : !0
}
function cR() {
    if (typeof navigator > "u")
        return null;
    const r = navigator;
    return r.languages && r.languages[0] || r.language || null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Rl {
    constructor(e, t) {
        this.shortDelay = e,
        this.longDelay = t,
        Gi(t > e, "Short delay should be less than long delay!"),
        this.isMobile = PA() || kA()
    }
    get() {
        return uR() ? this.isMobile ? this.longDelay : this.shortDelay : Math.min(5e3, this.shortDelay)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ap(r, e) {
    Gi(r.emulator, "Emulator should always be set here");
    const {url: t} = r.emulator;
    return e ? `${t}${e.startsWith("/") ? e.slice(1) : e}` : t
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class qT {
    static initialize(e, t, s) {
        this.fetchImpl = e,
        t && (this.headersImpl = t),
        s && (this.responseImpl = s)
    }
    static fetch() {
        if (this.fetchImpl)
            return this.fetchImpl;
        if (typeof self < "u" && "fetch"in self)
            return self.fetch;
        if (typeof globalThis < "u" && globalThis.fetch)
            return globalThis.fetch;
        if (typeof fetch < "u")
            return fetch;
        Li("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }
    static headers() {
        if (this.headersImpl)
            return this.headersImpl;
        if (typeof self < "u" && "Headers"in self)
            return self.Headers;
        if (typeof globalThis < "u" && globalThis.Headers)
            return globalThis.Headers;
        if (typeof Headers < "u")
            return Headers;
        Li("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }
    static response() {
        if (this.responseImpl)
            return this.responseImpl;
        if (typeof self < "u" && "Response"in self)
            return self.Response;
        if (typeof globalThis < "u" && globalThis.Response)
            return globalThis.Response;
        if (typeof Response < "u")
            return Response;
        Li("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fR = {
    CREDENTIAL_MISMATCH: "custom-token-mismatch",
    MISSING_CUSTOM_TOKEN: "internal-error",
    INVALID_IDENTIFIER: "invalid-email",
    MISSING_CONTINUE_URI: "internal-error",
    INVALID_PASSWORD: "wrong-password",
    MISSING_PASSWORD: "missing-password",
    INVALID_LOGIN_CREDENTIALS: "invalid-credential",
    EMAIL_EXISTS: "email-already-in-use",
    PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
    INVALID_IDP_RESPONSE: "invalid-credential",
    INVALID_PENDING_TOKEN: "invalid-credential",
    FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
    MISSING_REQ_TYPE: "internal-error",
    EMAIL_NOT_FOUND: "user-not-found",
    RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
    EXPIRED_OOB_CODE: "expired-action-code",
    INVALID_OOB_CODE: "invalid-action-code",
    MISSING_OOB_CODE: "internal-error",
    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
    INVALID_ID_TOKEN: "invalid-user-token",
    TOKEN_EXPIRED: "user-token-expired",
    USER_NOT_FOUND: "user-token-expired",
    TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
    PASSWORD_DOES_NOT_MEET_REQUIREMENTS: "password-does-not-meet-requirements",
    INVALID_CODE: "invalid-verification-code",
    INVALID_SESSION_INFO: "invalid-verification-id",
    INVALID_TEMPORARY_PROOF: "invalid-credential",
    MISSING_SESSION_INFO: "missing-verification-id",
    SESSION_EXPIRED: "code-expired",
    MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
    UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
    INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
    ADMIN_ONLY_OPERATION: "admin-restricted-operation",
    INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
    MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
    MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
    MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
    SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
    SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
    BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error",
    RECAPTCHA_NOT_ENABLED: "recaptcha-not-enabled",
    MISSING_RECAPTCHA_TOKEN: "missing-recaptcha-token",
    INVALID_RECAPTCHA_TOKEN: "invalid-recaptcha-token",
    INVALID_RECAPTCHA_ACTION: "invalid-recaptcha-action",
    MISSING_CLIENT_TYPE: "missing-client-type",
    MISSING_RECAPTCHA_VERSION: "missing-recaptcha-version",
    INVALID_RECAPTCHA_VERSION: "invalid-recaptcha-version",
    INVALID_REQ_TYPE: "invalid-req-type"
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const hR = ["/v1/accounts:signInWithCustomToken", "/v1/accounts:signInWithEmailLink", "/v1/accounts:signInWithIdp", "/v1/accounts:signInWithPassword", "/v1/accounts:signInWithPhoneNumber", "/v1/token"]
  , dR = new Rl(3e4,6e4);
function Pr(r, e) {
    return r.tenantId && !e.tenantId ? Object.assign(Object.assign({}, e), {
        tenantId: r.tenantId
    }) : e
}
async function Or(r, e, t, s, o={}) {
    return zT(r, o, async () => {
        let l = {}
          , f = {};
        s && (e === "GET" ? f = s : l = {
            body: JSON.stringify(s)
        });
        const d = Cl(Object.assign({
            key: r.config.apiKey
        }, f)).slice(1)
          , v = await r._getAdditionalHeaders();
        v["Content-Type"] = "application/json",
        r.languageCode && (v["X-Firebase-Locale"] = r.languageCode);
        const y = Object.assign({
            method: e,
            headers: v
        }, l);
        return VA() || (y.referrerPolicy = "no-referrer"),
        qT.fetch()(await FT(r, r.config.apiHost, t, d), y)
    }
    )
}
async function zT(r, e, t) {
    r._canInitEmulator = !1;
    const s = Object.assign(Object.assign({}, fR), e);
    try {
        const o = new mR(r)
          , l = await Promise.race([t(), o.promise]);
        o.clearNetworkTimeout();
        const f = await l.json();
        if ("needConfirmation"in f)
            throw sc(r, "account-exists-with-different-credential", f);
        if (l.ok && !("errorMessage"in f))
            return f;
        {
            const d = l.ok ? f.errorMessage : f.error.message
              , [v,y] = d.split(" : ");
            if (v === "FEDERATED_USER_ID_ALREADY_LINKED")
                throw sc(r, "credential-already-in-use", f);
            if (v === "EMAIL_EXISTS")
                throw sc(r, "email-already-in-use", f);
            if (v === "USER_DISABLED")
                throw sc(r, "user-disabled", f);
            const T = s[v] || v.toLowerCase().replace(/[_\s]+/g, "-");
            if (y)
                throw sp(r, T, y);
            xn(r, T)
        }
    } catch (o) {
        if (o instanceof Ki)
            throw o;
        xn(r, "network-request-failed", {
            message: String(o)
        })
    }
}
async function Il(r, e, t, s, o={}) {
    const l = await Or(r, e, t, s, o);
    return "mfaPendingCredential"in l && xn(r, "multi-factor-auth-required", {
        _serverResponse: l
    }),
    l
}
async function FT(r, e, t, s) {
    const o = `${e}${t}?${s}`
      , l = r
      , f = l.config.emulator ? ap(r.config, o) : `${r.config.apiScheme}://${o}`;
    return hR.includes(t) && (await l._persistenceManagerAvailable,
    l._getPersistenceType() === "COOKIE") ? l._getPersistence()._getFinalTarget(f).toString() : f
}
function pR(r) {
    switch (r) {
    case "ENFORCE":
        return "ENFORCE";
    case "AUDIT":
        return "AUDIT";
    case "OFF":
        return "OFF";
    default:
        return "ENFORCEMENT_STATE_UNSPECIFIED"
    }
}
class mR {
    clearNetworkTimeout() {
        clearTimeout(this.timer)
    }
    constructor(e) {
        this.auth = e,
        this.timer = null,
        this.promise = new Promise( (t, s) => {
            this.timer = setTimeout( () => s(Hn(this.auth, "network-request-failed")), dR.get())
        }
        )
    }
}
function sc(r, e, t) {
    const s = {
        appName: r.name
    };
    t.email && (s.email = t.email),
    t.phoneNumber && (s.phoneNumber = t.phoneNumber);
    const o = Hn(r, e, s);
    return o.customData._tokenResponse = t,
    o
}
function mv(r) {
    return r !== void 0 && r.enterprise !== void 0
}
class gR {
    constructor(e) {
        if (this.siteKey = "",
        this.recaptchaEnforcementState = [],
        e.recaptchaKey === void 0)
            throw new Error("recaptchaKey undefined");
        this.siteKey = e.recaptchaKey.split("/")[3],
        this.recaptchaEnforcementState = e.recaptchaEnforcementState
    }
    getProviderEnforcementState(e) {
        if (!this.recaptchaEnforcementState || this.recaptchaEnforcementState.length === 0)
            return null;
        for (const t of this.recaptchaEnforcementState)
            if (t.provider && t.provider === e)
                return pR(t.enforcementState);
        return null
    }
    isProviderEnabled(e) {
        return this.getProviderEnforcementState(e) === "ENFORCE" || this.getProviderEnforcementState(e) === "AUDIT"
    }
    isAnyProviderEnabled() {
        return this.isProviderEnabled("EMAIL_PASSWORD_PROVIDER") || this.isProviderEnabled("PHONE_PROVIDER")
    }
}
async function yR(r, e) {
    return Or(r, "GET", "/v2/recaptchaConfig", Pr(r, e))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function vR(r, e) {
    return Or(r, "POST", "/v1/accounts:delete", e)
}
async function wc(r, e) {
    return Or(r, "POST", "/v1/accounts:lookup", e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ll(r) {
    if (r)
        try {
            const e = new Date(Number(r));
            if (!isNaN(e.getTime()))
                return e.toUTCString()
        } catch {}
}
async function _R(r, e=!1) {
    const t = vn(r)
      , s = await t.getIdToken(e)
      , o = lp(s);
    ve(o && o.exp && o.auth_time && o.iat, t.auth, "internal-error");
    const l = typeof o.firebase == "object" ? o.firebase : void 0
      , f = l == null ? void 0 : l.sign_in_provider;
    return {
        claims: o,
        token: s,
        authTime: ll(Td(o.auth_time)),
        issuedAtTime: ll(Td(o.iat)),
        expirationTime: ll(Td(o.exp)),
        signInProvider: f || null,
        signInSecondFactor: (l == null ? void 0 : l.sign_in_second_factor) || null
    }
}
function Td(r) {
    return Number(r) * 1e3
}
function lp(r) {
    const [e,t,s] = r.split(".");
    if (e === void 0 || t === void 0 || s === void 0)
        return pc("JWT malformed, contained fewer than 3 sections"),
        null;
    try {
        const o = bT(t);
        return o ? JSON.parse(o) : (pc("Failed to decode base64 JWT payload"),
        null)
    } catch (o) {
        return pc("Caught error parsing JWT payload as JSON", o == null ? void 0 : o.toString()),
        null
    }
}
function gv(r) {
    const e = lp(r);
    return ve(e, "internal-error"),
    ve(typeof e.exp < "u", "internal-error"),
    ve(typeof e.iat < "u", "internal-error"),
    Number(e.exp) - Number(e.iat)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function pl(r, e, t=!1) {
    if (t)
        return e;
    try {
        return await e
    } catch (s) {
        throw s instanceof Ki && TR(s) && r.auth.currentUser === r && await r.auth.signOut(),
        s
    }
}
function TR({code: r}) {
    return r === "auth/user-disabled" || r === "auth/user-token-expired"
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ER {
    constructor(e) {
        this.user = e,
        this.isRunning = !1,
        this.timerId = null,
        this.errorBackoff = 3e4
    }
    _start() {
        this.isRunning || (this.isRunning = !0,
        this.schedule())
    }
    _stop() {
        this.isRunning && (this.isRunning = !1,
        this.timerId !== null && clearTimeout(this.timerId))
    }
    getInterval(e) {
        var t;
        if (e) {
            const s = this.errorBackoff;
            return this.errorBackoff = Math.min(this.errorBackoff * 2, 96e4),
            s
        } else {
            this.errorBackoff = 3e4;
            const o = ((t = this.user.stsTokenManager.expirationTime) !== null && t !== void 0 ? t : 0) - Date.now() - 3e5;
            return Math.max(0, o)
        }
    }
    schedule(e=!1) {
        if (!this.isRunning)
            return;
        const t = this.getInterval(e);
        this.timerId = setTimeout(async () => {
            await this.iteration()
        }
        , t)
    }
    async iteration() {
        try {
            await this.user.getIdToken(!0)
        } catch (e) {
            (e == null ? void 0 : e.code) === "auth/network-request-failed" && this.schedule(!0);
            return
        }
        this.schedule()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Nd {
    constructor(e, t) {
        this.createdAt = e,
        this.lastLoginAt = t,
        this._initializeTime()
    }
    _initializeTime() {
        this.lastSignInTime = ll(this.lastLoginAt),
        this.creationTime = ll(this.createdAt)
    }
    _copy(e) {
        this.createdAt = e.createdAt,
        this.lastLoginAt = e.lastLoginAt,
        this._initializeTime()
    }
    toJSON() {
        return {
            createdAt: this.createdAt,
            lastLoginAt: this.lastLoginAt
        }
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function bc(r) {
    var e;
    const t = r.auth
      , s = await r.getIdToken()
      , o = await pl(r, wc(t, {
        idToken: s
    }));
    ve(o == null ? void 0 : o.users.length, t, "internal-error");
    const l = o.users[0];
    r._notifyReloadListener(l);
    const f = !((e = l.providerUserInfo) === null || e === void 0) && e.length ? HT(l.providerUserInfo) : []
      , d = AR(r.providerData, f)
      , v = r.isAnonymous
      , y = !(r.email && l.passwordHash) && !(d != null && d.length)
      , T = v ? y : !1
      , A = {
        uid: l.localId,
        displayName: l.displayName || null,
        photoURL: l.photoUrl || null,
        email: l.email || null,
        emailVerified: l.emailVerified || !1,
        phoneNumber: l.phoneNumber || null,
        tenantId: l.tenantId || null,
        providerData: d,
        metadata: new Nd(l.createdAt,l.lastLoginAt),
        isAnonymous: T
    };
    Object.assign(r, A)
}
async function SR(r) {
    const e = vn(r);
    await bc(e),
    await e.auth._persistUserIfCurrent(e),
    e.auth._notifyListenersIfCurrent(e)
}
function AR(r, e) {
    return [...r.filter(s => !e.some(o => o.providerId === s.providerId)), ...e]
}
function HT(r) {
    return r.map(e => {
        var {providerId: t} = e
          , s = rp(e, ["providerId"]);
        return {
            providerId: t,
            uid: s.rawId || "",
            displayName: s.displayName || null,
            email: s.email || null,
            phoneNumber: s.phoneNumber || null,
            photoURL: s.photoUrl || null
        }
    }
    )
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function CR(r, e) {
    const t = await zT(r, {}, async () => {
        const s = Cl({
            grant_type: "refresh_token",
            refresh_token: e
        }).slice(1)
          , {tokenApiHost: o, apiKey: l} = r.config
          , f = await FT(r, o, "/v1/token", `key=${l}`)
          , d = await r._getAdditionalHeaders();
        return d["Content-Type"] = "application/x-www-form-urlencoded",
        qT.fetch()(f, {
            method: "POST",
            headers: d,
            body: s
        })
    }
    );
    return {
        accessToken: t.access_token,
        expiresIn: t.expires_in,
        refreshToken: t.refresh_token
    }
}
async function RR(r, e) {
    return Or(r, "POST", "/v2/accounts:revokeToken", Pr(r, e))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Po {
    constructor() {
        this.refreshToken = null,
        this.accessToken = null,
        this.expirationTime = null
    }
    get isExpired() {
        return !this.expirationTime || Date.now() > this.expirationTime - 3e4
    }
    updateFromServerResponse(e) {
        ve(e.idToken, "internal-error"),
        ve(typeof e.idToken < "u", "internal-error"),
        ve(typeof e.refreshToken < "u", "internal-error");
        const t = "expiresIn"in e && typeof e.expiresIn < "u" ? Number(e.expiresIn) : gv(e.idToken);
        this.updateTokensAndExpiration(e.idToken, e.refreshToken, t)
    }
    updateFromIdToken(e) {
        ve(e.length !== 0, "internal-error");
        const t = gv(e);
        this.updateTokensAndExpiration(e, null, t)
    }
    async getToken(e, t=!1) {
        return !t && this.accessToken && !this.isExpired ? this.accessToken : (ve(this.refreshToken, e, "user-token-expired"),
        this.refreshToken ? (await this.refresh(e, this.refreshToken),
        this.accessToken) : null)
    }
    clearRefreshToken() {
        this.refreshToken = null
    }
    async refresh(e, t) {
        const {accessToken: s, refreshToken: o, expiresIn: l} = await CR(e, t);
        this.updateTokensAndExpiration(s, o, Number(l))
    }
    updateTokensAndExpiration(e, t, s) {
        this.refreshToken = t || null,
        this.accessToken = e || null,
        this.expirationTime = Date.now() + s * 1e3
    }
    static fromJSON(e, t) {
        const {refreshToken: s, accessToken: o, expirationTime: l} = t
          , f = new Po;
        return s && (ve(typeof s == "string", "internal-error", {
            appName: e
        }),
        f.refreshToken = s),
        o && (ve(typeof o == "string", "internal-error", {
            appName: e
        }),
        f.accessToken = o),
        l && (ve(typeof l == "number", "internal-error", {
            appName: e
        }),
        f.expirationTime = l),
        f
    }
    toJSON() {
        return {
            refreshToken: this.refreshToken,
            accessToken: this.accessToken,
            expirationTime: this.expirationTime
        }
    }
    _assign(e) {
        this.accessToken = e.accessToken,
        this.refreshToken = e.refreshToken,
        this.expirationTime = e.expirationTime
    }
    _clone() {
        return Object.assign(new Po, this.toJSON())
    }
    _performRefresh() {
        return Li("not implemented")
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Sr(r, e) {
    ve(typeof r == "string" || typeof r > "u", "internal-error", {
        appName: e
    })
}
class zn {
    constructor(e) {
        var {uid: t, auth: s, stsTokenManager: o} = e
          , l = rp(e, ["uid", "auth", "stsTokenManager"]);
        this.providerId = "firebase",
        this.proactiveRefresh = new ER(this),
        this.reloadUserInfo = null,
        this.reloadListener = null,
        this.uid = t,
        this.auth = s,
        this.stsTokenManager = o,
        this.accessToken = o.accessToken,
        this.displayName = l.displayName || null,
        this.email = l.email || null,
        this.emailVerified = l.emailVerified || !1,
        this.phoneNumber = l.phoneNumber || null,
        this.photoURL = l.photoURL || null,
        this.isAnonymous = l.isAnonymous || !1,
        this.tenantId = l.tenantId || null,
        this.providerData = l.providerData ? [...l.providerData] : [],
        this.metadata = new Nd(l.createdAt || void 0,l.lastLoginAt || void 0)
    }
    async getIdToken(e) {
        const t = await pl(this, this.stsTokenManager.getToken(this.auth, e));
        return ve(t, this.auth, "internal-error"),
        this.accessToken !== t && (this.accessToken = t,
        await this.auth._persistUserIfCurrent(this),
        this.auth._notifyListenersIfCurrent(this)),
        t
    }
    getIdTokenResult(e) {
        return _R(this, e)
    }
    reload() {
        return SR(this)
    }
    _assign(e) {
        this !== e && (ve(this.uid === e.uid, this.auth, "internal-error"),
        this.displayName = e.displayName,
        this.photoURL = e.photoURL,
        this.email = e.email,
        this.emailVerified = e.emailVerified,
        this.phoneNumber = e.phoneNumber,
        this.isAnonymous = e.isAnonymous,
        this.tenantId = e.tenantId,
        this.providerData = e.providerData.map(t => Object.assign({}, t)),
        this.metadata._copy(e.metadata),
        this.stsTokenManager._assign(e.stsTokenManager))
    }
    _clone(e) {
        const t = new zn(Object.assign(Object.assign({}, this), {
            auth: e,
            stsTokenManager: this.stsTokenManager._clone()
        }));
        return t.metadata._copy(this.metadata),
        t
    }
    _onReload(e) {
        ve(!this.reloadListener, this.auth, "internal-error"),
        this.reloadListener = e,
        this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo),
        this.reloadUserInfo = null)
    }
    _notifyReloadListener(e) {
        this.reloadListener ? this.reloadListener(e) : this.reloadUserInfo = e
    }
    _startProactiveRefresh() {
        this.proactiveRefresh._start()
    }
    _stopProactiveRefresh() {
        this.proactiveRefresh._stop()
    }
    async _updateTokensIfNecessary(e, t=!1) {
        let s = !1;
        e.idToken && e.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(e),
        s = !0),
        t && await bc(this),
        await this.auth._persistUserIfCurrent(this),
        s && this.auth._notifyListenersIfCurrent(this)
    }
    async delete() {
        if (yn(this.auth.app))
            return Promise.reject(qi(this.auth));
        const e = await this.getIdToken();
        return await pl(this, vR(this.auth, {
            idToken: e
        })),
        this.stsTokenManager.clearRefreshToken(),
        this.auth.signOut()
    }
    toJSON() {
        return Object.assign(Object.assign({
            uid: this.uid,
            email: this.email || void 0,
            emailVerified: this.emailVerified,
            displayName: this.displayName || void 0,
            isAnonymous: this.isAnonymous,
            photoURL: this.photoURL || void 0,
            phoneNumber: this.phoneNumber || void 0,
            tenantId: this.tenantId || void 0,
            providerData: this.providerData.map(e => Object.assign({}, e)),
            stsTokenManager: this.stsTokenManager.toJSON(),
            _redirectEventId: this._redirectEventId
        }, this.metadata.toJSON()), {
            apiKey: this.auth.config.apiKey,
            appName: this.auth.name
        })
    }
    get refreshToken() {
        return this.stsTokenManager.refreshToken || ""
    }
    static _fromJSON(e, t) {
        var s, o, l, f, d, v, y, T;
        const A = (s = t.displayName) !== null && s !== void 0 ? s : void 0
          , I = (o = t.email) !== null && o !== void 0 ? o : void 0
          , V = (l = t.phoneNumber) !== null && l !== void 0 ? l : void 0
          , q = (f = t.photoURL) !== null && f !== void 0 ? f : void 0
          , G = (d = t.tenantId) !== null && d !== void 0 ? d : void 0
          , J = (v = t._redirectEventId) !== null && v !== void 0 ? v : void 0
          , ne = (y = t.createdAt) !== null && y !== void 0 ? y : void 0
          , se = (T = t.lastLoginAt) !== null && T !== void 0 ? T : void 0
          , {uid: le, emailVerified: ue, isAnonymous: fe, providerData: Ie, stsTokenManager: U} = t;
        ve(le && U, e, "internal-error");
        const w = Po.fromJSON(this.name, U);
        ve(typeof le == "string", e, "internal-error"),
        Sr(A, e.name),
        Sr(I, e.name),
        ve(typeof ue == "boolean", e, "internal-error"),
        ve(typeof fe == "boolean", e, "internal-error"),
        Sr(V, e.name),
        Sr(q, e.name),
        Sr(G, e.name),
        Sr(J, e.name),
        Sr(ne, e.name),
        Sr(se, e.name);
        const M = new zn({
            uid: le,
            auth: e,
            email: I,
            emailVerified: ue,
            displayName: A,
            isAnonymous: fe,
            photoURL: q,
            phoneNumber: V,
            tenantId: G,
            stsTokenManager: w,
            createdAt: ne,
            lastLoginAt: se
        });
        return Ie && Array.isArray(Ie) && (M.providerData = Ie.map(P => Object.assign({}, P))),
        J && (M._redirectEventId = J),
        M
    }
    static async _fromIdTokenResponse(e, t, s=!1) {
        const o = new Po;
        o.updateFromServerResponse(t);
        const l = new zn({
            uid: t.localId,
            auth: e,
            stsTokenManager: o,
            isAnonymous: s
        });
        return await bc(l),
        l
    }
    static async _fromGetAccountInfoResponse(e, t, s) {
        const o = t.users[0];
        ve(o.localId !== void 0, "internal-error");
        const l = o.providerUserInfo !== void 0 ? HT(o.providerUserInfo) : []
          , f = !(o.email && o.passwordHash) && !(l != null && l.length)
          , d = new Po;
        d.updateFromIdToken(s);
        const v = new zn({
            uid: o.localId,
            auth: e,
            stsTokenManager: d,
            isAnonymous: f
        })
          , y = {
            uid: o.localId,
            displayName: o.displayName || null,
            photoURL: o.photoUrl || null,
            email: o.email || null,
            emailVerified: o.emailVerified || !1,
            phoneNumber: o.phoneNumber || null,
            tenantId: o.tenantId || null,
            providerData: l,
            metadata: new Nd(o.createdAt,o.lastLoginAt),
            isAnonymous: !(o.email && o.passwordHash) && !(l != null && l.length)
        };
        return Object.assign(v, y),
        v
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const yv = new Map;
function Bi(r) {
    Gi(r instanceof Function, "Expected a class definition");
    let e = yv.get(r);
    return e ? (Gi(e instanceof r, "Instance stored in cache mismatched with class"),
    e) : (e = new r,
    yv.set(r, e),
    e)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GT {
    constructor() {
        this.type = "NONE",
        this.storage = {}
    }
    async _isAvailable() {
        return !0
    }
    async _set(e, t) {
        this.storage[e] = t
    }
    async _get(e) {
        const t = this.storage[e];
        return t === void 0 ? null : t
    }
    async _remove(e) {
        delete this.storage[e]
    }
    _addListener(e, t) {}
    _removeListener(e, t) {}
}
GT.type = "NONE";
const vv = GT;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function mc(r, e, t) {
    return `firebase:${r}:${e}:${t}`
}
class Oo {
    constructor(e, t, s) {
        this.persistence = e,
        this.auth = t,
        this.userKey = s;
        const {config: o, name: l} = this.auth;
        this.fullUserKey = mc(this.userKey, o.apiKey, l),
        this.fullPersistenceKey = mc("persistence", o.apiKey, l),
        this.boundEventHandler = t._onStorageEvent.bind(t),
        this.persistence._addListener(this.fullUserKey, this.boundEventHandler)
    }
    setCurrentUser(e) {
        return this.persistence._set(this.fullUserKey, e.toJSON())
    }
    async getCurrentUser() {
        const e = await this.persistence._get(this.fullUserKey);
        if (!e)
            return null;
        if (typeof e == "string") {
            const t = await wc(this.auth, {
                idToken: e
            }).catch( () => {}
            );
            return t ? zn._fromGetAccountInfoResponse(this.auth, t, e) : null
        }
        return zn._fromJSON(this.auth, e)
    }
    removeCurrentUser() {
        return this.persistence._remove(this.fullUserKey)
    }
    savePersistenceForRedirect() {
        return this.persistence._set(this.fullPersistenceKey, this.persistence.type)
    }
    async setPersistence(e) {
        if (this.persistence === e)
            return;
        const t = await this.getCurrentUser();
        if (await this.removeCurrentUser(),
        this.persistence = e,
        t)
            return this.setCurrentUser(t)
    }
    delete() {
        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler)
    }
    static async create(e, t, s="authUser") {
        if (!t.length)
            return new Oo(Bi(vv),e,s);
        const o = (await Promise.all(t.map(async y => {
            if (await y._isAvailable())
                return y
        }
        ))).filter(y => y);
        let l = o[0] || Bi(vv);
        const f = mc(s, e.config.apiKey, e.name);
        let d = null;
        for (const y of t)
            try {
                const T = await y._get(f);
                if (T) {
                    let A;
                    if (typeof T == "string") {
                        const I = await wc(e, {
                            idToken: T
                        }).catch( () => {}
                        );
                        if (!I)
                            break;
                        A = await zn._fromGetAccountInfoResponse(e, I, T)
                    } else
                        A = zn._fromJSON(e, T);
                    y !== l && (d = A),
                    l = y;
                    break
                }
            } catch {}
        const v = o.filter(y => y._shouldAllowMigration);
        return !l._shouldAllowMigration || !v.length ? new Oo(l,e,s) : (l = v[0],
        d && await l._set(f, d.toJSON()),
        await Promise.all(t.map(async y => {
            if (y !== l)
                try {
                    await y._remove(f)
                } catch {}
        }
        )),
        new Oo(l,e,s))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _v(r) {
    const e = r.toLowerCase();
    if (e.includes("opera/") || e.includes("opr/") || e.includes("opios/"))
        return "Opera";
    if (XT(e))
        return "IEMobile";
    if (e.includes("msie") || e.includes("trident/"))
        return "IE";
    if (e.includes("edge/"))
        return "Edge";
    if (YT(e))
        return "Firefox";
    if (e.includes("silk/"))
        return "Silk";
    if (JT(e))
        return "Blackberry";
    if (jT(e))
        return "Webos";
    if (KT(e))
        return "Safari";
    if ((e.includes("chrome/") || QT(e)) && !e.includes("edge/"))
        return "Chrome";
    if ($T(e))
        return "Android";
    {
        const t = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/
          , s = r.match(t);
        if ((s == null ? void 0 : s.length) === 2)
            return s[1]
    }
    return "Other"
}
function YT(r=Jt()) {
    return /firefox\//i.test(r)
}
function KT(r=Jt()) {
    const e = r.toLowerCase();
    return e.includes("safari/") && !e.includes("chrome/") && !e.includes("crios/") && !e.includes("android")
}
function QT(r=Jt()) {
    return /crios\//i.test(r)
}
function XT(r=Jt()) {
    return /iemobile/i.test(r)
}
function $T(r=Jt()) {
    return /android/i.test(r)
}
function JT(r=Jt()) {
    return /blackberry/i.test(r)
}
function jT(r=Jt()) {
    return /webos/i.test(r)
}
function up(r=Jt()) {
    return /iphone|ipad|ipod/i.test(r) || /macintosh/i.test(r) && /mobile/i.test(r)
}
function IR(r=Jt()) {
    var e;
    return up(r) && !!(!((e = window.navigator) === null || e === void 0) && e.standalone)
}
function wR() {
    return LA() && document.documentMode === 10
}
function WT(r=Jt()) {
    return up(r) || $T(r) || jT(r) || JT(r) || /windows phone/i.test(r) || XT(r)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ZT(r, e=[]) {
    let t;
    switch (r) {
    case "Browser":
        t = _v(Jt());
        break;
    case "Worker":
        t = `${_v(Jt())}-${r}`;
        break;
    default:
        t = r
    }
    const s = e.length ? e.join(",") : "FirebaseCore-web";
    return `${t}/JsCore/${Ho}/${s}`
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class bR {
    constructor(e) {
        this.auth = e,
        this.queue = []
    }
    pushCallback(e, t) {
        const s = l => new Promise( (f, d) => {
            try {
                const v = e(l);
                f(v)
            } catch (v) {
                d(v)
            }
        }
        );
        s.onAbort = t,
        this.queue.push(s);
        const o = this.queue.length - 1;
        return () => {
            this.queue[o] = () => Promise.resolve()
        }
    }
    async runMiddleware(e) {
        if (this.auth.currentUser === e)
            return;
        const t = [];
        try {
            for (const s of this.queue)
                await s(e),
                s.onAbort && t.push(s.onAbort)
        } catch (s) {
            t.reverse();
            for (const o of t)
                try {
                    o()
                } catch {}
            throw this.auth._errorFactory.create("login-blocked", {
                originalMessage: s == null ? void 0 : s.message
            })
        }
    }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function DR(r, e={}) {
    return Or(r, "GET", "/v2/passwordPolicy", Pr(r, e))
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MR = 6;
class NR {
    constructor(e) {
        var t, s, o, l;
        const f = e.customStrengthOptions;
        this.customStrengthOptions = {},
        this.customStrengthOptions.minPasswordLength = (t = f.minPasswordLength) !== null && t !== void 0 ? t : MR,
        f.maxPasswordLength && (this.customStrengthOptions.maxPasswordLength = f.maxPasswordLength),
        f.containsLowercaseCharacter !== void 0 && (this.customStrengthOptions.containsLowercaseLetter = f.containsLowercaseCharacter),
        f.containsUppercaseCharacter !== void 0 && (this.customStrengthOptions.containsUppercaseLetter = f.containsUppercaseCharacter),
        f.containsNumericCharacter !== void 0 && (this.customStrengthOptions.containsNumericCharacter = f.containsNumericCharacter),
        f.containsNonAlphanumericCharacter !== void 0 && (this.customStrengthOptions.containsNonAlphanumericCharacter = f.containsNonAlphanumericCharacter),
        this.enforcementState = e.enforcementState,
        this.enforcementState === "ENFORCEMENT_STATE_UNSPECIFIED" && (this.enforcementState = "OFF"),
        this.allowedNonAlphanumericCharacters = (o = (s = e.allowedNonAlphanumericCharacters) === null || s === void 0 ? void 0 : s.join("")) !== null && o !== void 0 ? o : "",
        this.forceUpgradeOnSignin = (l = e.forceUpgradeOnSignin) !== null && l !== void 0 ? l : !1,
        this.schemaVersion = e.schemaVersion
    }
    validatePassword(e) {
        var t, s, o, l, f, d;
        const v = {
            isValid: !0,
            passwordPolicy: this
        };
        return this.validatePasswordLengthOptions(e, v),
        this.validatePasswordCharacterOptions(e, v),
        v.isValid && (v.isValid = (t = v.meetsMinPasswordLength) !== null && t !== void 0 ? t : !0),
        v.isValid && (v.isValid = (s = v.meetsMaxPasswordLength) !== null && s !== void 0 ? s : !0),
        v.isValid && (v.isValid = (o = v.containsLowercaseLetter) !== null && o !== void 0 ? o : !0),
        v.isValid && (v.isValid = (l = v.containsUppercaseLetter) !== null && l !== void 0 ? l : !0),
        v.isValid && (v.isValid = (f = v.containsNumericCharacter) !== null && f !== void 0 ? f : !0),
        v.isValid && (v.isValid = (d = v.containsNonAlphanumericCharacter) !== null && d !== void 0 ? d : !0),
        v
    }
    validatePasswordLengthOptions(e, t) {
        const s = this.customStrengthOptions.minPasswordLength
          , o = this.customStrengthOptions.maxPasswordLength;
        s && (t.meetsMinPasswordLength = e.length >= s),
        o && (t.meetsMaxPasswordLength = e.length <= o)
    }
    validatePasswordCharacterOptions(e, t) {
        this.updatePasswordCharacterOptionsStatuses(t, !1, !1, !1, !1);
        let s;
        for (let o = 0; o < e.length; o++)
            s = e.charAt(o),
            this.updatePasswordCharacterOptionsStatuses(t, s >= "a" && s <= "z", s >= "A" && s <= "Z", s >= "0" && s <= "9", this.allowedNonAlphanumericCharacters.includes(s))
    }
    updatePasswordCharacterOptionsStatuses(e, t, s, o, l) {
        this.customStrengthOptions.containsLowercaseLetter && (e.containsLowercaseLetter || (e.containsLowercaseLetter = t)),
        this.customStrengthOptions.containsUppercaseLetter && (e.containsUppercaseLetter || (e.containsUppercaseLetter = s)),
        this.customStrengthOptions.containsNumericCharacter && (e.containsNumericCharacter || (e.containsNumericCharacter = o)),
        this.customStrengthOptions.containsNonAlphanumericCharacter && (e.containsNonAlphanumericCharacter || (e.containsNonAlphanumericCharacter = l))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class xR {
    constructor(e, t, s, o) {
        this.app = e,
        this.heartbeatServiceProvider = t,
        this.appCheckServiceProvider = s,
        this.config = o,
        this.currentUser = null,
        this.emulatorConfig = null,
        this.operations = Promise.resolve(),
        this.authStateSubscription = new Tv(this),
        this.idTokenSubscription = new Tv(this),
        this.beforeStateQueue = new bR(this),
        this.redirectUser = null,
        this.isProactiveRefreshEnabled = !1,
        this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1,
        this._canInitEmulator = !0,
        this._isInitialized = !1,
        this._deleted = !1,
        this._initializationPromise = null,
        this._popupRedirectResolver = null,
        this._errorFactory = BT,
        this._agentRecaptchaConfig = null,
        this._tenantRecaptchaConfigs = {},
        this._projectPasswordPolicy = null,
        this._tenantPasswordPolicies = {},
        this._resolvePersistenceManagerAvailable = void 0,
        this.lastNotifiedUid = void 0,
        this.languageCode = null,
        this.tenantId = null,
        this.settings = {
            appVerificationDisabledForTesting: !1
        },
        this.frameworks = [],
        this.name = e.name,
        this.clientVersion = o.sdkClientVersion,
        this._persistenceManagerAvailable = new Promise(l => this._resolvePersistenceManagerAvailable = l)
    }
    _initializeWithPersistence(e, t) {
        return t && (this._popupRedirectResolver = Bi(t)),
        this._initializationPromise = this.queue(async () => {
            var s, o, l;
            if (!this._deleted && (this.persistenceManager = await Oo.create(this, e),
            (s = this._resolvePersistenceManagerAvailable) === null || s === void 0 || s.call(this),
            !this._deleted)) {
                if (!((o = this._popupRedirectResolver) === null || o === void 0) && o._shouldInitProactively)
                    try {
                        await this._popupRedirectResolver._initialize(this)
                    } catch {}
                await this.initializeCurrentUser(t),
                this.lastNotifiedUid = ((l = this.currentUser) === null || l === void 0 ? void 0 : l.uid) || null,
                !this._deleted && (this._isInitialized = !0)
            }
        }
        ),
        this._initializationPromise
    }
    async _onStorageEvent() {
        if (this._deleted)
            return;
        const e = await this.assertedPersistence.getCurrentUser();
        if (!(!this.currentUser && !e)) {
            if (this.currentUser && e && this.currentUser.uid === e.uid) {
                this._currentUser._assign(e),
                await this.currentUser.getIdToken();
                return
            }
            await this._updateCurrentUser(e, !0)
        }
    }
    async initializeCurrentUserFromIdToken(e) {
        try {
            const t = await wc(this, {
                idToken: e
            })
              , s = await zn._fromGetAccountInfoResponse(this, t, e);
            await this.directlySetCurrentUser(s)
        } catch (t) {
            console.warn("FirebaseServerApp could not login user with provided authIdToken: ", t),
            await this.directlySetCurrentUser(null)
        }
    }
    async initializeCurrentUser(e) {
        var t;
        if (yn(this.app)) {
            const f = this.app.settings.authIdToken;
            return f ? new Promise(d => {
                setTimeout( () => this.initializeCurrentUserFromIdToken(f).then(d, d))
            }
            ) : this.directlySetCurrentUser(null)
        }
        const s = await this.assertedPersistence.getCurrentUser();
        let o = s
          , l = !1;
        if (e && this.config.authDomain) {
            await this.getOrInitRedirectPersistenceManager();
            const f = (t = this.redirectUser) === null || t === void 0 ? void 0 : t._redirectEventId
              , d = o == null ? void 0 : o._redirectEventId
              , v = await this.tryRedirectSignIn(e);
            (!f || f === d) && (v != null && v.user) && (o = v.user,
            l = !0)
        }
        if (!o)
            return this.directlySetCurrentUser(null);
        if (!o._redirectEventId) {
            if (l)
                try {
                    await this.beforeStateQueue.runMiddleware(o)
                } catch (f) {
                    o = s,
                    this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(f))
                }
            return o ? this.reloadAndSetCurrentUserOrClear(o) : this.directlySetCurrentUser(null)
        }
        return ve(this._popupRedirectResolver, this, "argument-error"),
        await this.getOrInitRedirectPersistenceManager(),
        this.redirectUser && this.redirectUser._redirectEventId === o._redirectEventId ? this.directlySetCurrentUser(o) : this.reloadAndSetCurrentUserOrClear(o)
    }
    async tryRedirectSignIn(e) {
        let t = null;
        try {
            t = await this._popupRedirectResolver._completeRedirectFn(this, e, !0)
        } catch {
            await this._setRedirectUser(null)
        }
        return t
    }
    async reloadAndSetCurrentUserOrClear(e) {
        try {
            await bc(e)
        } catch (t) {
            if ((t == null ? void 0 : t.code) !== "auth/network-request-failed")
                return this.directlySetCurrentUser(null)
        }
        return this.directlySetCurrentUser(e)
    }
    useDeviceLanguage() {
        this.languageCode = cR()
    }
    async _delete() {
        this._deleted = !0
    }
    async updateCurrentUser(e) {
        if (yn(this.app))
            return Promise.reject(qi(this));
        const t = e ? vn(e) : null;
        return t && ve(t.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token"),
        this._updateCurrentUser(t && t._clone(this))
    }
    async _updateCurrentUser(e, t=!1) {
        if (!this._deleted)
            return e && ve(this.tenantId === e.tenantId, this, "tenant-id-mismatch"),
            t || await this.beforeStateQueue.runMiddleware(e),
            this.queue(async () => {
                await this.directlySetCurrentUser(e),
                this.notifyAuthListeners()
            }
            )
    }
    async signOut() {
        return yn(this.app) ? Promise.reject(qi(this)) : (await this.beforeStateQueue.runMiddleware(null),
        (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null),
        this._updateCurrentUser(null, !0))
    }
    setPersistence(e) {
        return yn(this.app) ? Promise.reject(qi(this)) : this.queue(async () => {
            await this.assertedPersistence.setPersistence(Bi(e))
        }
        )
    }
    _getRecaptchaConfig() {
        return this.tenantId == null ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId]
    }
    async validatePassword(e) {
        this._getPasswordPolicyInternal() || await this._updatePasswordPolicy();
        const t = this._getPasswordPolicyInternal();
        return t.schemaVersion !== this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION ? Promise.reject(this._errorFactory.create("unsupported-password-policy-schema-version", {})) : t.validatePassword(e)
    }
    _getPasswordPolicyInternal() {
        return this.tenantId === null ? this._projectPasswordPolicy : this._tenantPasswordPolicies[this.tenantId]
    }
    async _updatePasswordPolicy() {
        const e = await DR(this)
          , t = new NR(e);
        this.tenantId === null ? this._projectPasswordPolicy = t : this._tenantPasswordPolicies[this.tenantId] = t
    }
    _getPersistenceType() {
        return this.assertedPersistence.persistence.type
    }
    _getPersistence() {
        return this.assertedPersistence.persistence
    }
    _updateErrorMap(e) {
        this._errorFactory = new Al("auth","Firebase",e())
    }
    onAuthStateChanged(e, t, s) {
        return this.registerStateListener(this.authStateSubscription, e, t, s)
    }
    beforeAuthStateChanged(e, t) {
        return this.beforeStateQueue.pushCallback(e, t)
    }
    onIdTokenChanged(e, t, s) {
        return this.registerStateListener(this.idTokenSubscription, e, t, s)
    }
    authStateReady() {
        return new Promise( (e, t) => {
            if (this.currentUser)
                e();
            else {
                const s = this.onAuthStateChanged( () => {
                    s(),
                    e()
                }
                , t)
            }
        }
        )
    }
    async revokeAccessToken(e) {
        if (this.currentUser) {
            const t = await this.currentUser.getIdToken()
              , s = {
                providerId: "apple.com",
                tokenType: "ACCESS_TOKEN",
                token: e,
                idToken: t
            };
            this.tenantId != null && (s.tenantId = this.tenantId),
            await RR(this, s)
        }
    }
    toJSON() {
        var e;
        return {
            apiKey: this.config.apiKey,
            authDomain: this.config.authDomain,
            appName: this.name,
            currentUser: (e = this._currentUser) === null || e === void 0 ? void 0 : e.toJSON()
        }
    }
    async _setRedirectUser(e, t) {
        const s = await this.getOrInitRedirectPersistenceManager(t);
        return e === null ? s.removeCurrentUser() : s.setCurrentUser(e)
    }
    async getOrInitRedirectPersistenceManager(e) {
        if (!this.redirectPersistenceManager) {
            const t = e && Bi(e) || this._popupRedirectResolver;
            ve(t, this, "argument-error"),
            this.redirectPersistenceManager = await Oo.create(this, [Bi(t._redirectPersistence)], "redirectUser"),
            this.redirectUser = await this.redirectPersistenceManager.getCurrentUser()
        }
        return this.redirectPersistenceManager
    }
    async _redirectUserForId(e) {
        var t, s;
        return this._isInitialized && await this.queue(async () => {}
        ),
        ((t = this._currentUser) === null || t === void 0 ? void 0 : t._redirectEventId) === e ? this._currentUser : ((s = this.redirectUser) === null || s === void 0 ? void 0 : s._redirectEventId) === e ? this.redirectUser : null
    }
    async _persistUserIfCurrent(e) {
        if (e === this.currentUser)
            return this.queue(async () => this.directlySetCurrentUser(e))
    }
    _notifyListenersIfCurrent(e) {
        e === this.currentUser && this.notifyAuthListeners()
    }
    _key() {
        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`
    }
    _startProactiveRefresh() {
        this.isProactiveRefreshEnabled = !0,
        this.currentUser && this._currentUser._startProactiveRefresh()
    }
    _stopProactiveRefresh() {
        this.isProactiveRefreshEnabled = !1,
        this.currentUser && this._currentUser._stopProactiveRefresh()
    }
    get _currentUser() {
        return this.currentUser
    }
    notifyAuthListeners() {
        var e, t;
        if (!this._isInitialized)
            return;
        this.idTokenSubscription.next(this.currentUser);
        const s = (t = (e = this.currentUser) === null || e === void 0 ? void 0 : e.uid) !== null && t !== void 0 ? t : null;
        this.lastNotifiedUid !== s && (this.lastNotifiedUid = s,
        this.authStateSubscription.next(this.currentUser))
    }
    registerStateListener(e, t, s, o) {
        if (this._deleted)
            return () => {}
            ;
        const l = typeof t == "function" ? t : t.next.bind(t);
        let f = !1;
        const d = this._isInitialized ? Promise.resolve() : this._initializationPromise;
        if (ve(d, this, "internal-error"),
        d.then( () => {
            f || l(this.currentUser)
        }
        ),
        typeof t == "function") {
            const v = e.addObserver(t, s, o);
            return () => {
                f = !0,
                v()
            }
        } else {
            const v = e.addObserver(t);
            return () => {
                f = !0,
                v()
            }
        }
    }
    async directlySetCurrentUser(e) {
        this.currentUser && this.currentUser !== e && this._currentUser._stopProactiveRefresh(),
        e && this.isProactiveRefreshEnabled && e._startProactiveRefresh(),
        this.currentUser = e,
        e ? await this.assertedPersistence.setCurrentUser(e) : await this.assertedPersistence.removeCurrentUser()
    }
    queue(e) {
        return this.operations = this.operations.then(e, e),
        this.operations
    }
    get assertedPersistence() {
        return ve(this.persistenceManager, this, "internal-error"),
        this.persistenceManager
    }
    _logFramework(e) {
        !e || this.frameworks.includes(e) || (this.frameworks.push(e),
        this.frameworks.sort(),
        this.clientVersion = ZT(this.config.clientPlatform, this._getFrameworks()))
    }
    _getFrameworks() {
        return this.frameworks
    }
    async _getAdditionalHeaders() {
        var e;
        const t = {
            "X-Client-Version": this.clientVersion
        };
        this.app.options.appId && (t["X-Firebase-gmpid"] = this.app.options.appId);
        const s = await ((e = this.heartbeatServiceProvider.getImmediate({
            optional: !0
        })) === null || e === void 0 ? void 0 : e.getHeartbeatsHeader());
        s && (t["X-Firebase-Client"] = s);
        const o = await this._getAppCheckToken();
        return o && (t["X-Firebase-AppCheck"] = o),
        t
    }
    async _getAppCheckToken() {
        var e;
        if (yn(this.app) && this.app.settings.appCheckToken)
            return this.app.settings.appCheckToken;
        const t = await ((e = this.appCheckServiceProvider.getImmediate({
            optional: !0
        })) === null || e === void 0 ? void 0 : e.getToken());
        return t != null && t.error && oR(`Error while retrieving App Check token: ${t.error}`),
        t == null ? void 0 : t.token
    }
}
function Vr(r) {
    return vn(r)
}
class Tv {
    constructor(e) {
        this.auth = e,
        this.observer = null,
        this.addObserver = KA(t => this.observer = t)
    }
    get next() {
        return ve(this.observer, this.auth, "internal-error"),
        this.observer.next.bind(this.observer)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Xc = {
    async loadJS() {
        throw new Error("Unable to load external scripts")
    },
    recaptchaV2Script: "",
    recaptchaEnterpriseScript: "",
    gapiScript: ""
};
function PR(r) {
    Xc = r
}
function eE(r) {
    return Xc.loadJS(r)
}
function OR() {
    return Xc.recaptchaEnterpriseScript
}
function VR() {
    return Xc.gapiScript
}
function UR(r) {
    return `__${r}${Math.floor(Math.random() * 1e6)}`
}
class kR {
    constructor() {
        this.enterprise = new LR
    }
    ready(e) {
        e()
    }
    execute(e, t) {
        return Promise.resolve("token")
    }
    render(e, t) {
        return ""
    }
}
class LR {
    ready(e) {
        e()
    }
    execute(e, t) {
        return Promise.resolve("token")
    }
    render(e, t) {
        return ""
    }
}
const BR = "recaptcha-enterprise"
  , tE = "NO_RECAPTCHA";
class qR {
    constructor(e) {
        this.type = BR,
        this.auth = Vr(e)
    }
    async verify(e="verify", t=!1) {
        async function s(l) {
            if (!t) {
                if (l.tenantId == null && l._agentRecaptchaConfig != null)
                    return l._agentRecaptchaConfig.siteKey;
                if (l.tenantId != null && l._tenantRecaptchaConfigs[l.tenantId] !== void 0)
                    return l._tenantRecaptchaConfigs[l.tenantId].siteKey
            }
            return new Promise(async (f, d) => {
                yR(l, {
                    clientType: "CLIENT_TYPE_WEB",
                    version: "RECAPTCHA_ENTERPRISE"
                }).then(v => {
                    if (v.recaptchaKey === void 0)
                        d(new Error("recaptcha Enterprise site key undefined"));
                    else {
                        const y = new gR(v);
                        return l.tenantId == null ? l._agentRecaptchaConfig = y : l._tenantRecaptchaConfigs[l.tenantId] = y,
                        f(y.siteKey)
                    }
                }
                ).catch(v => {
                    d(v)
                }
                )
            }
            )
        }
        function o(l, f, d) {
            const v = window.grecaptcha;
            mv(v) ? v.enterprise.ready( () => {
                v.enterprise.execute(l, {
                    action: e
                }).then(y => {
                    f(y)
                }
                ).catch( () => {
                    f(tE)
                }
                )
            }
            ) : d(Error("No reCAPTCHA enterprise script loaded."))
        }
        return this.auth.settings.appVerificationDisabledForTesting ? new kR().execute("siteKey", {
            action: "verify"
        }) : new Promise( (l, f) => {
            s(this.auth).then(d => {
                if (!t && mv(window.grecaptcha))
                    o(d, l, f);
                else {
                    if (typeof window > "u") {
                        f(new Error("RecaptchaVerifier is only supported in browser"));
                        return
                    }
                    let v = OR();
                    v.length !== 0 && (v += d),
                    eE(v).then( () => {
                        o(d, l, f)
                    }
                    ).catch(y => {
                        f(y)
                    }
                    )
                }
            }
            ).catch(d => {
                f(d)
            }
            )
        }
        )
    }
}
async function Ev(r, e, t, s=!1, o=!1) {
    const l = new qR(r);
    let f;
    if (o)
        f = tE;
    else
        try {
            f = await l.verify(t)
        } catch {
            f = await l.verify(t, !0)
        }
    const d = Object.assign({}, e);
    if (t === "mfaSmsEnrollment" || t === "mfaSmsSignIn") {
        if ("phoneEnrollmentInfo"in d) {
            const v = d.phoneEnrollmentInfo.phoneNumber
              , y = d.phoneEnrollmentInfo.recaptchaToken;
            Object.assign(d, {
                phoneEnrollmentInfo: {
                    phoneNumber: v,
                    recaptchaToken: y,
                    captchaResponse: f,
                    clientType: "CLIENT_TYPE_WEB",
                    recaptchaVersion: "RECAPTCHA_ENTERPRISE"
                }
            })
        } else if ("phoneSignInInfo"in d) {
            const v = d.phoneSignInInfo.recaptchaToken;
            Object.assign(d, {
                phoneSignInInfo: {
                    recaptchaToken: v,
                    captchaResponse: f,
                    clientType: "CLIENT_TYPE_WEB",
                    recaptchaVersion: "RECAPTCHA_ENTERPRISE"
                }
            })
        }
        return d
    }
    return s ? Object.assign(d, {
        captchaResp: f
    }) : Object.assign(d, {
        captchaResponse: f
    }),
    Object.assign(d, {
        clientType: "CLIENT_TYPE_WEB"
    }),
    Object.assign(d, {
        recaptchaVersion: "RECAPTCHA_ENTERPRISE"
    }),
    d
}
async function xd(r, e, t, s, o) {
    var l;
    if (!((l = r._getRecaptchaConfig()) === null || l === void 0) && l.isProviderEnabled("EMAIL_PASSWORD_PROVIDER")) {
        const f = await Ev(r, e, t, t === "getOobCode");
        return s(r, f)
    } else
        return s(r, e).catch(async f => {
            if (f.code === "auth/missing-recaptcha-token") {
                console.log(`${t} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`);
                const d = await Ev(r, e, t, t === "getOobCode");
                return s(r, d)
            } else
                return Promise.reject(f)
        }
        )
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function zR(r, e) {
    const t = ip(r, "auth");
    if (t.isInitialized()) {
        const o = t.getImmediate()
          , l = t.getOptions();
        if (ws(l, e ?? {}))
            return o;
        xn(o, "already-initialized")
    }
    return t.initialize({
        options: e
    })
}
function FR(r, e) {
    const t = (e == null ? void 0 : e.persistence) || []
      , s = (Array.isArray(t) ? t : [t]).map(Bi);
    e != null && e.errorMap && r._updateErrorMap(e.errorMap),
    r._initializeWithPersistence(s, e == null ? void 0 : e.popupRedirectResolver)
}
function HR(r, e, t) {
    const s = Vr(r);
    ve(/^https?:\/\//.test(e), s, "invalid-emulator-scheme");
    const o = !1
      , l = nE(e)
      , {host: f, port: d} = GR(e)
      , v = d === null ? "" : `:${d}`
      , y = {
        url: `${l}//${f}${v}/`
    }
      , T = Object.freeze({
        host: f,
        port: d,
        protocol: l.replace(":", ""),
        options: Object.freeze({
            disableWarnings: o
        })
    });
    if (!s._canInitEmulator) {
        ve(s.config.emulator && s.emulatorConfig, s, "emulator-config-failed"),
        ve(ws(y, s.config.emulator) && ws(T, s.emulatorConfig), s, "emulator-config-failed");
        return
    }
    s.config.emulator = y,
    s.emulatorConfig = T,
    s.settings.appVerificationDisabledForTesting = !0,
    YR()
}
function nE(r) {
    const e = r.indexOf(":");
    return e < 0 ? "" : r.substr(0, e + 1)
}
function GR(r) {
    const e = nE(r)
      , t = /(\/\/)?([^?#/]+)/.exec(r.substr(e.length));
    if (!t)
        return {
            host: "",
            port: null
        };
    const s = t[2].split("@").pop() || ""
      , o = /^(\[[^\]]+\])(:|$)/.exec(s);
    if (o) {
        const l = o[1];
        return {
            host: l,
            port: Sv(s.substr(l.length + 1))
        }
    } else {
        const [l,f] = s.split(":");
        return {
            host: l,
            port: Sv(f)
        }
    }
}
function Sv(r) {
    if (!r)
        return null;
    const e = Number(r);
    return isNaN(e) ? null : e
}
function YR() {
    function r() {
        const e = document.createElement("p")
          , t = e.style;
        e.innerText = "Running in emulator mode. Do not use with production credentials.",
        t.position = "fixed",
        t.width = "100%",
        t.backgroundColor = "#ffffff",
        t.border = ".1em solid #000000",
        t.color = "#b50000",
        t.bottom = "0px",
        t.left = "0px",
        t.margin = "0px",
        t.zIndex = "10000",
        t.textAlign = "center",
        e.classList.add("firebase-emulator-warning"),
        document.body.appendChild(e)
    }
    typeof console < "u" && typeof console.info == "function" && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."),
    typeof window < "u" && typeof document < "u" && (document.readyState === "loading" ? window.addEventListener("DOMContentLoaded", r) : r())
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cp {
    constructor(e, t) {
        this.providerId = e,
        this.signInMethod = t
    }
    toJSON() {
        return Li("not implemented")
    }
    _getIdTokenResponse(e) {
        return Li("not implemented")
    }
    _linkToIdToken(e, t) {
        return Li("not implemented")
    }
    _getReauthenticationResolver(e) {
        return Li("not implemented")
    }
}
async function KR(r, e) {
    return Or(r, "POST", "/v1/accounts:signUp", e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function QR(r, e) {
    return Il(r, "POST", "/v1/accounts:signInWithPassword", Pr(r, e))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function XR(r, e) {
    return Il(r, "POST", "/v1/accounts:signInWithEmailLink", Pr(r, e))
}
async function $R(r, e) {
    return Il(r, "POST", "/v1/accounts:signInWithEmailLink", Pr(r, e))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ml extends cp {
    constructor(e, t, s, o=null) {
        super("password", s),
        this._email = e,
        this._password = t,
        this._tenantId = o
    }
    static _fromEmailAndPassword(e, t) {
        return new ml(e,t,"password")
    }
    static _fromEmailAndCode(e, t, s=null) {
        return new ml(e,t,"emailLink",s)
    }
    toJSON() {
        return {
            email: this._email,
            password: this._password,
            signInMethod: this.signInMethod,
            tenantId: this._tenantId
        }
    }
    static fromJSON(e) {
        const t = typeof e == "string" ? JSON.parse(e) : e;
        if (t != null && t.email && (t != null && t.password)) {
            if (t.signInMethod === "password")
                return this._fromEmailAndPassword(t.email, t.password);
            if (t.signInMethod === "emailLink")
                return this._fromEmailAndCode(t.email, t.password, t.tenantId)
        }
        return null
    }
    async _getIdTokenResponse(e) {
        switch (this.signInMethod) {
        case "password":
            const t = {
                returnSecureToken: !0,
                email: this._email,
                password: this._password,
                clientType: "CLIENT_TYPE_WEB"
            };
            return xd(e, t, "signInWithPassword", QR);
        case "emailLink":
            return XR(e, {
                email: this._email,
                oobCode: this._password
            });
        default:
            xn(e, "internal-error")
        }
    }
    async _linkToIdToken(e, t) {
        switch (this.signInMethod) {
        case "password":
            const s = {
                idToken: t,
                returnSecureToken: !0,
                email: this._email,
                password: this._password,
                clientType: "CLIENT_TYPE_WEB"
            };
            return xd(e, s, "signUpPassword", KR);
        case "emailLink":
            return $R(e, {
                idToken: t,
                email: this._email,
                oobCode: this._password
            });
        default:
            xn(e, "internal-error")
        }
    }
    _getReauthenticationResolver(e) {
        return this._getIdTokenResponse(e)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Vo(r, e) {
    return Il(r, "POST", "/v1/accounts:signInWithIdp", Pr(r, e))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const JR = "http://localhost";
class Ds extends cp {
    constructor() {
        super(...arguments),
        this.pendingToken = null
    }
    static _fromParams(e) {
        const t = new Ds(e.providerId,e.signInMethod);
        return e.idToken || e.accessToken ? (e.idToken && (t.idToken = e.idToken),
        e.accessToken && (t.accessToken = e.accessToken),
        e.nonce && !e.pendingToken && (t.nonce = e.nonce),
        e.pendingToken && (t.pendingToken = e.pendingToken)) : e.oauthToken && e.oauthTokenSecret ? (t.accessToken = e.oauthToken,
        t.secret = e.oauthTokenSecret) : xn("argument-error"),
        t
    }
    toJSON() {
        return {
            idToken: this.idToken,
            accessToken: this.accessToken,
            secret: this.secret,
            nonce: this.nonce,
            pendingToken: this.pendingToken,
            providerId: this.providerId,
            signInMethod: this.signInMethod
        }
    }
    static fromJSON(e) {
        const t = typeof e == "string" ? JSON.parse(e) : e
          , {providerId: s, signInMethod: o} = t
          , l = rp(t, ["providerId", "signInMethod"]);
        if (!s || !o)
            return null;
        const f = new Ds(s,o);
        return f.idToken = l.idToken || void 0,
        f.accessToken = l.accessToken || void 0,
        f.secret = l.secret,
        f.nonce = l.nonce,
        f.pendingToken = l.pendingToken || null,
        f
    }
    _getIdTokenResponse(e) {
        const t = this.buildRequest();
        return Vo(e, t)
    }
    _linkToIdToken(e, t) {
        const s = this.buildRequest();
        return s.idToken = t,
        Vo(e, s)
    }
    _getReauthenticationResolver(e) {
        const t = this.buildRequest();
        return t.autoCreate = !1,
        Vo(e, t)
    }
    buildRequest() {
        const e = {
            requestUri: JR,
            returnSecureToken: !0
        };
        if (this.pendingToken)
            e.pendingToken = this.pendingToken;
        else {
            const t = {};
            this.idToken && (t.id_token = this.idToken),
            this.accessToken && (t.access_token = this.accessToken),
            this.secret && (t.oauth_token_secret = this.secret),
            t.providerId = this.providerId,
            this.nonce && !this.pendingToken && (t.nonce = this.nonce),
            e.postBody = Cl(t)
        }
        return e
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function jR(r) {
    switch (r) {
    case "recoverEmail":
        return "RECOVER_EMAIL";
    case "resetPassword":
        return "PASSWORD_RESET";
    case "signIn":
        return "EMAIL_SIGNIN";
    case "verifyEmail":
        return "VERIFY_EMAIL";
    case "verifyAndChangeEmail":
        return "VERIFY_AND_CHANGE_EMAIL";
    case "revertSecondFactorAddition":
        return "REVERT_SECOND_FACTOR_ADDITION";
    default:
        return null
    }
}
function WR(r) {
    const e = sl(ol(r)).link
      , t = e ? sl(ol(e)).deep_link_id : null
      , s = sl(ol(r)).deep_link_id;
    return (s ? sl(ol(s)).link : null) || s || t || e || r
}
class fp {
    constructor(e) {
        var t, s, o, l, f, d;
        const v = sl(ol(e))
          , y = (t = v.apiKey) !== null && t !== void 0 ? t : null
          , T = (s = v.oobCode) !== null && s !== void 0 ? s : null
          , A = jR((o = v.mode) !== null && o !== void 0 ? o : null);
        ve(y && T && A, "argument-error"),
        this.apiKey = y,
        this.operation = A,
        this.code = T,
        this.continueUrl = (l = v.continueUrl) !== null && l !== void 0 ? l : null,
        this.languageCode = (f = v.lang) !== null && f !== void 0 ? f : null,
        this.tenantId = (d = v.tenantId) !== null && d !== void 0 ? d : null
    }
    static parseLink(e) {
        const t = WR(e);
        try {
            return new fp(t)
        } catch {
            return null
        }
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Go {
    constructor() {
        this.providerId = Go.PROVIDER_ID
    }
    static credential(e, t) {
        return ml._fromEmailAndPassword(e, t)
    }
    static credentialWithLink(e, t) {
        const s = fp.parseLink(t);
        return ve(s, "argument-error"),
        ml._fromEmailAndCode(e, s.code, s.tenantId)
    }
}
Go.PROVIDER_ID = "password";
Go.EMAIL_PASSWORD_SIGN_IN_METHOD = "password";
Go.EMAIL_LINK_SIGN_IN_METHOD = "emailLink";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hp {
    constructor(e) {
        this.providerId = e,
        this.defaultLanguageCode = null,
        this.customParameters = {}
    }
    setDefaultLanguage(e) {
        this.defaultLanguageCode = e
    }
    setCustomParameters(e) {
        return this.customParameters = e,
        this
    }
    getCustomParameters() {
        return this.customParameters
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class wl extends hp {
    constructor() {
        super(...arguments),
        this.scopes = []
    }
    addScope(e) {
        return this.scopes.includes(e) || this.scopes.push(e),
        this
    }
    getScopes() {
        return [...this.scopes]
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ar extends wl {
    constructor() {
        super("facebook.com")
    }
    static credential(e) {
        return Ds._fromParams({
            providerId: Ar.PROVIDER_ID,
            signInMethod: Ar.FACEBOOK_SIGN_IN_METHOD,
            accessToken: e
        })
    }
    static credentialFromResult(e) {
        return Ar.credentialFromTaggedObject(e)
    }
    static credentialFromError(e) {
        return Ar.credentialFromTaggedObject(e.customData || {})
    }
    static credentialFromTaggedObject({_tokenResponse: e}) {
        if (!e || !("oauthAccessToken"in e) || !e.oauthAccessToken)
            return null;
        try {
            return Ar.credential(e.oauthAccessToken)
        } catch {
            return null
        }
    }
}
Ar.FACEBOOK_SIGN_IN_METHOD = "facebook.com";
Ar.PROVIDER_ID = "facebook.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ki extends wl {
    constructor() {
        super("google.com"),
        this.addScope("profile")
    }
    static credential(e, t) {
        return Ds._fromParams({
            providerId: ki.PROVIDER_ID,
            signInMethod: ki.GOOGLE_SIGN_IN_METHOD,
            idToken: e,
            accessToken: t
        })
    }
    static credentialFromResult(e) {
        return ki.credentialFromTaggedObject(e)
    }
    static credentialFromError(e) {
        return ki.credentialFromTaggedObject(e.customData || {})
    }
    static credentialFromTaggedObject({_tokenResponse: e}) {
        if (!e)
            return null;
        const {oauthIdToken: t, oauthAccessToken: s} = e;
        if (!t && !s)
            return null;
        try {
            return ki.credential(t, s)
        } catch {
            return null
        }
    }
}
ki.GOOGLE_SIGN_IN_METHOD = "google.com";
ki.PROVIDER_ID = "google.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Cr extends wl {
    constructor() {
        super("github.com")
    }
    static credential(e) {
        return Ds._fromParams({
            providerId: Cr.PROVIDER_ID,
            signInMethod: Cr.GITHUB_SIGN_IN_METHOD,
            accessToken: e
        })
    }
    static credentialFromResult(e) {
        return Cr.credentialFromTaggedObject(e)
    }
    static credentialFromError(e) {
        return Cr.credentialFromTaggedObject(e.customData || {})
    }
    static credentialFromTaggedObject({_tokenResponse: e}) {
        if (!e || !("oauthAccessToken"in e) || !e.oauthAccessToken)
            return null;
        try {
            return Cr.credential(e.oauthAccessToken)
        } catch {
            return null
        }
    }
}
Cr.GITHUB_SIGN_IN_METHOD = "github.com";
Cr.PROVIDER_ID = "github.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Rr extends wl {
    constructor() {
        super("twitter.com")
    }
    static credential(e, t) {
        return Ds._fromParams({
            providerId: Rr.PROVIDER_ID,
            signInMethod: Rr.TWITTER_SIGN_IN_METHOD,
            oauthToken: e,
            oauthTokenSecret: t
        })
    }
    static credentialFromResult(e) {
        return Rr.credentialFromTaggedObject(e)
    }
    static credentialFromError(e) {
        return Rr.credentialFromTaggedObject(e.customData || {})
    }
    static credentialFromTaggedObject({_tokenResponse: e}) {
        if (!e)
            return null;
        const {oauthAccessToken: t, oauthTokenSecret: s} = e;
        if (!t || !s)
            return null;
        try {
            return Rr.credential(t, s)
        } catch {
            return null
        }
    }
}
Rr.TWITTER_SIGN_IN_METHOD = "twitter.com";
Rr.PROVIDER_ID = "twitter.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function ZR(r, e) {
    return Il(r, "POST", "/v1/accounts:signUp", Pr(r, e))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ms {
    constructor(e) {
        this.user = e.user,
        this.providerId = e.providerId,
        this._tokenResponse = e._tokenResponse,
        this.operationType = e.operationType
    }
    static async _fromIdTokenResponse(e, t, s, o=!1) {
        const l = await zn._fromIdTokenResponse(e, s, o)
          , f = Av(s);
        return new Ms({
            user: l,
            providerId: f,
            _tokenResponse: s,
            operationType: t
        })
    }
    static async _forOperation(e, t, s) {
        await e._updateTokensIfNecessary(s, !0);
        const o = Av(s);
        return new Ms({
            user: e,
            providerId: o,
            _tokenResponse: s,
            operationType: t
        })
    }
}
function Av(r) {
    return r.providerId ? r.providerId : "phoneNumber"in r ? "phone" : null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Dc extends Ki {
    constructor(e, t, s, o) {
        var l;
        super(t.code, t.message),
        this.operationType = s,
        this.user = o,
        Object.setPrototypeOf(this, Dc.prototype),
        this.customData = {
            appName: e.name,
            tenantId: (l = e.tenantId) !== null && l !== void 0 ? l : void 0,
            _serverResponse: t.customData._serverResponse,
            operationType: s
        }
    }
    static _fromErrorAndOperation(e, t, s, o) {
        return new Dc(e,t,s,o)
    }
}
function iE(r, e, t, s) {
    return (e === "reauthenticate" ? t._getReauthenticationResolver(r) : t._getIdTokenResponse(r)).catch(l => {
        throw l.code === "auth/multi-factor-auth-required" ? Dc._fromErrorAndOperation(r, l, e, s) : l
    }
    )
}
async function eI(r, e, t=!1) {
    const s = await pl(r, e._linkToIdToken(r.auth, await r.getIdToken()), t);
    return Ms._forOperation(r, "link", s)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function tI(r, e, t=!1) {
    const {auth: s} = r;
    if (yn(s.app))
        return Promise.reject(qi(s));
    const o = "reauthenticate";
    try {
        const l = await pl(r, iE(s, o, e, r), t);
        ve(l.idToken, s, "internal-error");
        const f = lp(l.idToken);
        ve(f, s, "internal-error");
        const {sub: d} = f;
        return ve(r.uid === d, s, "user-mismatch"),
        Ms._forOperation(r, o, l)
    } catch (l) {
        throw (l == null ? void 0 : l.code) === "auth/user-not-found" && xn(s, "user-mismatch"),
        l
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function rE(r, e, t=!1) {
    if (yn(r.app))
        return Promise.reject(qi(r));
    const s = "signIn"
      , o = await iE(r, s, e)
      , l = await Ms._fromIdTokenResponse(r, s, o);
    return t || await r._updateCurrentUser(l.user),
    l
}
async function nI(r, e) {
    return rE(Vr(r), e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function sE(r) {
    const e = Vr(r);
    e._getPasswordPolicyInternal() && await e._updatePasswordPolicy()
}
async function iI(r, e, t) {
    if (yn(r.app))
        return Promise.reject(qi(r));
    const s = Vr(r)
      , f = await xd(s, {
        returnSecureToken: !0,
        email: e,
        password: t,
        clientType: "CLIENT_TYPE_WEB"
    }, "signUpPassword", ZR).catch(v => {
        throw v.code === "auth/password-does-not-meet-requirements" && sE(r),
        v
    }
    )
      , d = await Ms._fromIdTokenResponse(s, "signIn", f);
    return await s._updateCurrentUser(d.user),
    d
}
function rI(r, e, t) {
    return yn(r.app) ? Promise.reject(qi(r)) : nI(vn(r), Go.credential(e, t)).catch(async s => {
        throw s.code === "auth/password-does-not-meet-requirements" && sE(r),
        s
    }
    )
}
function sI(r, e, t, s) {
    return vn(r).onIdTokenChanged(e, t, s)
}
function oI(r, e, t) {
    return vn(r).beforeAuthStateChanged(e, t)
}
function aI(r, e, t, s) {
    return vn(r).onAuthStateChanged(e, t, s)
}
function lI(r) {
    return vn(r).signOut()
}
const Mc = "__sak";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class oE {
    constructor(e, t) {
        this.storageRetriever = e,
        this.type = t
    }
    _isAvailable() {
        try {
            return this.storage ? (this.storage.setItem(Mc, "1"),
            this.storage.removeItem(Mc),
            Promise.resolve(!0)) : Promise.resolve(!1)
        } catch {
            return Promise.resolve(!1)
        }
    }
    _set(e, t) {
        return this.storage.setItem(e, JSON.stringify(t)),
        Promise.resolve()
    }
    _get(e) {
        const t = this.storage.getItem(e);
        return Promise.resolve(t ? JSON.parse(t) : null)
    }
    _remove(e) {
        return this.storage.removeItem(e),
        Promise.resolve()
    }
    get storage() {
        return this.storageRetriever()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const uI = 1e3
  , cI = 10;
class aE extends oE {
    constructor() {
        super( () => window.localStorage, "LOCAL"),
        this.boundEventHandler = (e, t) => this.onStorageEvent(e, t),
        this.listeners = {},
        this.localCache = {},
        this.pollTimer = null,
        this.fallbackToPolling = WT(),
        this._shouldAllowMigration = !0
    }
    forAllChangedKeys(e) {
        for (const t of Object.keys(this.listeners)) {
            const s = this.storage.getItem(t)
              , o = this.localCache[t];
            s !== o && e(t, o, s)
        }
    }
    onStorageEvent(e, t=!1) {
        if (!e.key) {
            this.forAllChangedKeys( (f, d, v) => {
                this.notifyListeners(f, v)
            }
            );
            return
        }
        const s = e.key;
        t ? this.detachListener() : this.stopPolling();
        const o = () => {
            const f = this.storage.getItem(s);
            !t && this.localCache[s] === f || this.notifyListeners(s, f)
        }
          , l = this.storage.getItem(s);
        wR() && l !== e.newValue && e.newValue !== e.oldValue ? setTimeout(o, cI) : o()
    }
    notifyListeners(e, t) {
        this.localCache[e] = t;
        const s = this.listeners[e];
        if (s)
            for (const o of Array.from(s))
                o(t && JSON.parse(t))
    }
    startPolling() {
        this.stopPolling(),
        this.pollTimer = setInterval( () => {
            this.forAllChangedKeys( (e, t, s) => {
                this.onStorageEvent(new StorageEvent("storage",{
                    key: e,
                    oldValue: t,
                    newValue: s
                }), !0)
            }
            )
        }
        , uI)
    }
    stopPolling() {
        this.pollTimer && (clearInterval(this.pollTimer),
        this.pollTimer = null)
    }
    attachListener() {
        window.addEventListener("storage", this.boundEventHandler)
    }
    detachListener() {
        window.removeEventListener("storage", this.boundEventHandler)
    }
    _addListener(e, t) {
        Object.keys(this.listeners).length === 0 && (this.fallbackToPolling ? this.startPolling() : this.attachListener()),
        this.listeners[e] || (this.listeners[e] = new Set,
        this.localCache[e] = this.storage.getItem(e)),
        this.listeners[e].add(t)
    }
    _removeListener(e, t) {
        this.listeners[e] && (this.listeners[e].delete(t),
        this.listeners[e].size === 0 && delete this.listeners[e]),
        Object.keys(this.listeners).length === 0 && (this.detachListener(),
        this.stopPolling())
    }
    async _set(e, t) {
        await super._set(e, t),
        this.localCache[e] = JSON.stringify(t)
    }
    async _get(e) {
        const t = await super._get(e);
        return this.localCache[e] = JSON.stringify(t),
        t
    }
    async _remove(e) {
        await super._remove(e),
        delete this.localCache[e]
    }
}
aE.type = "LOCAL";
const fI = aE;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class lE extends oE {
    constructor() {
        super( () => window.sessionStorage, "SESSION")
    }
    _addListener(e, t) {}
    _removeListener(e, t) {}
}
lE.type = "SESSION";
const uE = lE;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function hI(r) {
    return Promise.all(r.map(async e => {
        try {
            return {
                fulfilled: !0,
                value: await e
            }
        } catch (t) {
            return {
                fulfilled: !1,
                reason: t
            }
        }
    }
    ))
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $c {
    constructor(e) {
        this.eventTarget = e,
        this.handlersMap = {},
        this.boundEventHandler = this.handleEvent.bind(this)
    }
    static _getInstance(e) {
        const t = this.receivers.find(o => o.isListeningto(e));
        if (t)
            return t;
        const s = new $c(e);
        return this.receivers.push(s),
        s
    }
    isListeningto(e) {
        return this.eventTarget === e
    }
    async handleEvent(e) {
        const t = e
          , {eventId: s, eventType: o, data: l} = t.data
          , f = this.handlersMap[o];
        if (!(f != null && f.size))
            return;
        t.ports[0].postMessage({
            status: "ack",
            eventId: s,
            eventType: o
        });
        const d = Array.from(f).map(async y => y(t.origin, l))
          , v = await hI(d);
        t.ports[0].postMessage({
            status: "done",
            eventId: s,
            eventType: o,
            response: v
        })
    }
    _subscribe(e, t) {
        Object.keys(this.handlersMap).length === 0 && this.eventTarget.addEventListener("message", this.boundEventHandler),
        this.handlersMap[e] || (this.handlersMap[e] = new Set),
        this.handlersMap[e].add(t)
    }
    _unsubscribe(e, t) {
        this.handlersMap[e] && t && this.handlersMap[e].delete(t),
        (!t || this.handlersMap[e].size === 0) && delete this.handlersMap[e],
        Object.keys(this.handlersMap).length === 0 && this.eventTarget.removeEventListener("message", this.boundEventHandler)
    }
}
$c.receivers = [];
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function dp(r="", e=10) {
    let t = "";
    for (let s = 0; s < e; s++)
        t += Math.floor(Math.random() * 10);
    return r + t
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dI {
    constructor(e) {
        this.target = e,
        this.handlers = new Set
    }
    removeMessageHandler(e) {
        e.messageChannel && (e.messageChannel.port1.removeEventListener("message", e.onMessage),
        e.messageChannel.port1.close()),
        this.handlers.delete(e)
    }
    async _send(e, t, s=50) {
        const o = typeof MessageChannel < "u" ? new MessageChannel : null;
        if (!o)
            throw new Error("connection_unavailable");
        let l, f;
        return new Promise( (d, v) => {
            const y = dp("", 20);
            o.port1.start();
            const T = setTimeout( () => {
                v(new Error("unsupported_event"))
            }
            , s);
            f = {
                messageChannel: o,
                onMessage(A) {
                    const I = A;
                    if (I.data.eventId === y)
                        switch (I.data.status) {
                        case "ack":
                            clearTimeout(T),
                            l = setTimeout( () => {
                                v(new Error("timeout"))
                            }
                            , 3e3);
                            break;
                        case "done":
                            clearTimeout(l),
                            d(I.data.response);
                            break;
                        default:
                            clearTimeout(T),
                            clearTimeout(l),
                            v(new Error("invalid_response"));
                            break
                        }
                }
            },
            this.handlers.add(f),
            o.port1.addEventListener("message", f.onMessage),
            this.target.postMessage({
                eventType: e,
                eventId: y,
                data: t
            }, [o.port2])
        }
        ).finally( () => {
            f && this.removeMessageHandler(f)
        }
        )
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function li() {
    return window
}
function pI(r) {
    li().location.href = r
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function cE() {
    return typeof li().WorkerGlobalScope < "u" && typeof li().importScripts == "function"
}
async function mI() {
    if (!(navigator != null && navigator.serviceWorker))
        return null;
    try {
        return (await navigator.serviceWorker.ready).active
    } catch {
        return null
    }
}
function gI() {
    var r;
    return ((r = navigator == null ? void 0 : navigator.serviceWorker) === null || r === void 0 ? void 0 : r.controller) || null
}
function yI() {
    return cE() ? self : null
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fE = "firebaseLocalStorageDb"
  , vI = 1
  , Nc = "firebaseLocalStorage"
  , hE = "fbase_key";
class bl {
    constructor(e) {
        this.request = e
    }
    toPromise() {
        return new Promise( (e, t) => {
            this.request.addEventListener("success", () => {
                e(this.request.result)
            }
            ),
            this.request.addEventListener("error", () => {
                t(this.request.error)
            }
            )
        }
        )
    }
}
function Jc(r, e) {
    return r.transaction([Nc], e ? "readwrite" : "readonly").objectStore(Nc)
}
function _I() {
    const r = indexedDB.deleteDatabase(fE);
    return new bl(r).toPromise()
}
function Pd() {
    const r = indexedDB.open(fE, vI);
    return new Promise( (e, t) => {
        r.addEventListener("error", () => {
            t(r.error)
        }
        ),
        r.addEventListener("upgradeneeded", () => {
            const s = r.result;
            try {
                s.createObjectStore(Nc, {
                    keyPath: hE
                })
            } catch (o) {
                t(o)
            }
        }
        ),
        r.addEventListener("success", async () => {
            const s = r.result;
            s.objectStoreNames.contains(Nc) ? e(s) : (s.close(),
            await _I(),
            e(await Pd()))
        }
        )
    }
    )
}
async function Cv(r, e, t) {
    const s = Jc(r, !0).put({
        [hE]: e,
        value: t
    });
    return new bl(s).toPromise()
}
async function TI(r, e) {
    const t = Jc(r, !1).get(e)
      , s = await new bl(t).toPromise();
    return s === void 0 ? null : s.value
}
function Rv(r, e) {
    const t = Jc(r, !0).delete(e);
    return new bl(t).toPromise()
}
const EI = 800
  , SI = 3;
class dE {
    constructor() {
        this.type = "LOCAL",
        this._shouldAllowMigration = !0,
        this.listeners = {},
        this.localCache = {},
        this.pollTimer = null,
        this.pendingWrites = 0,
        this.receiver = null,
        this.sender = null,
        this.serviceWorkerReceiverAvailable = !1,
        this.activeServiceWorker = null,
        this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then( () => {}
        , () => {}
        )
    }
    async _openDb() {
        return this.db ? this.db : (this.db = await Pd(),
        this.db)
    }
    async _withRetries(e) {
        let t = 0;
        for (; ; )
            try {
                const s = await this._openDb();
                return await e(s)
            } catch (s) {
                if (t++ > SI)
                    throw s;
                this.db && (this.db.close(),
                this.db = void 0)
            }
    }
    async initializeServiceWorkerMessaging() {
        return cE() ? this.initializeReceiver() : this.initializeSender()
    }
    async initializeReceiver() {
        this.receiver = $c._getInstance(yI()),
        this.receiver._subscribe("keyChanged", async (e, t) => ({
            keyProcessed: (await this._poll()).includes(t.key)
        })),
        this.receiver._subscribe("ping", async (e, t) => ["keyChanged"])
    }
    async initializeSender() {
        var e, t;
        if (this.activeServiceWorker = await mI(),
        !this.activeServiceWorker)
            return;
        this.sender = new dI(this.activeServiceWorker);
        const s = await this.sender._send("ping", {}, 800);
        s && !((e = s[0]) === null || e === void 0) && e.fulfilled && !((t = s[0]) === null || t === void 0) && t.value.includes("keyChanged") && (this.serviceWorkerReceiverAvailable = !0)
    }
    async notifyServiceWorker(e) {
        if (!(!this.sender || !this.activeServiceWorker || gI() !== this.activeServiceWorker))
            try {
                await this.sender._send("keyChanged", {
                    key: e
                }, this.serviceWorkerReceiverAvailable ? 800 : 50)
            } catch {}
    }
    async _isAvailable() {
        try {
            if (!indexedDB)
                return !1;
            const e = await Pd();
            return await Cv(e, Mc, "1"),
            await Rv(e, Mc),
            !0
        } catch {}
        return !1
    }
    async _withPendingWrite(e) {
        this.pendingWrites++;
        try {
            await e()
        } finally {
            this.pendingWrites--
        }
    }
    async _set(e, t) {
        return this._withPendingWrite(async () => (await this._withRetries(s => Cv(s, e, t)),
        this.localCache[e] = t,
        this.notifyServiceWorker(e)))
    }
    async _get(e) {
        const t = await this._withRetries(s => TI(s, e));
        return this.localCache[e] = t,
        t
    }
    async _remove(e) {
        return this._withPendingWrite(async () => (await this._withRetries(t => Rv(t, e)),
        delete this.localCache[e],
        this.notifyServiceWorker(e)))
    }
    async _poll() {
        const e = await this._withRetries(o => {
            const l = Jc(o, !1).getAll();
            return new bl(l).toPromise()
        }
        );
        if (!e)
            return [];
        if (this.pendingWrites !== 0)
            return [];
        const t = []
          , s = new Set;
        if (e.length !== 0)
            for (const {fbase_key: o, value: l} of e)
                s.add(o),
                JSON.stringify(this.localCache[o]) !== JSON.stringify(l) && (this.notifyListeners(o, l),
                t.push(o));
        for (const o of Object.keys(this.localCache))
            this.localCache[o] && !s.has(o) && (this.notifyListeners(o, null),
            t.push(o));
        return t
    }
    notifyListeners(e, t) {
        this.localCache[e] = t;
        const s = this.listeners[e];
        if (s)
            for (const o of Array.from(s))
                o(t)
    }
    startPolling() {
        this.stopPolling(),
        this.pollTimer = setInterval(async () => this._poll(), EI)
    }
    stopPolling() {
        this.pollTimer && (clearInterval(this.pollTimer),
        this.pollTimer = null)
    }
    _addListener(e, t) {
        Object.keys(this.listeners).length === 0 && this.startPolling(),
        this.listeners[e] || (this.listeners[e] = new Set,
        this._get(e)),
        this.listeners[e].add(t)
    }
    _removeListener(e, t) {
        this.listeners[e] && (this.listeners[e].delete(t),
        this.listeners[e].size === 0 && delete this.listeners[e]),
        Object.keys(this.listeners).length === 0 && this.stopPolling()
    }
}
dE.type = "LOCAL";
const AI = dE;
new Rl(3e4,6e4);
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function pE(r, e) {
    return e ? Bi(e) : (ve(r._popupRedirectResolver, r, "argument-error"),
    r._popupRedirectResolver)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class pp extends cp {
    constructor(e) {
        super("custom", "custom"),
        this.params = e
    }
    _getIdTokenResponse(e) {
        return Vo(e, this._buildIdpRequest())
    }
    _linkToIdToken(e, t) {
        return Vo(e, this._buildIdpRequest(t))
    }
    _getReauthenticationResolver(e) {
        return Vo(e, this._buildIdpRequest())
    }
    _buildIdpRequest(e) {
        const t = {
            requestUri: this.params.requestUri,
            sessionId: this.params.sessionId,
            postBody: this.params.postBody,
            tenantId: this.params.tenantId,
            pendingToken: this.params.pendingToken,
            returnSecureToken: !0,
            returnIdpCredential: !0
        };
        return e && (t.idToken = e),
        t
    }
}
function CI(r) {
    return rE(r.auth, new pp(r), r.bypassAuthState)
}
function RI(r) {
    const {auth: e, user: t} = r;
    return ve(t, e, "internal-error"),
    tI(t, new pp(r), r.bypassAuthState)
}
async function II(r) {
    const {auth: e, user: t} = r;
    return ve(t, e, "internal-error"),
    eI(t, new pp(r), r.bypassAuthState)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class mE {
    constructor(e, t, s, o, l=!1) {
        this.auth = e,
        this.resolver = s,
        this.user = o,
        this.bypassAuthState = l,
        this.pendingPromise = null,
        this.eventManager = null,
        this.filter = Array.isArray(t) ? t : [t]
    }
    execute() {
        return new Promise(async (e, t) => {
            this.pendingPromise = {
                resolve: e,
                reject: t
            };
            try {
                this.eventManager = await this.resolver._initialize(this.auth),
                await this.onExecution(),
                this.eventManager.registerConsumer(this)
            } catch (s) {
                this.reject(s)
            }
        }
        )
    }
    async onAuthEvent(e) {
        const {urlResponse: t, sessionId: s, postBody: o, tenantId: l, error: f, type: d} = e;
        if (f) {
            this.reject(f);
            return
        }
        const v = {
            auth: this.auth,
            requestUri: t,
            sessionId: s,
            tenantId: l || void 0,
            postBody: o || void 0,
            user: this.user,
            bypassAuthState: this.bypassAuthState
        };
        try {
            this.resolve(await this.getIdpTask(d)(v))
        } catch (y) {
            this.reject(y)
        }
    }
    onError(e) {
        this.reject(e)
    }
    getIdpTask(e) {
        switch (e) {
        case "signInViaPopup":
        case "signInViaRedirect":
            return CI;
        case "linkViaPopup":
        case "linkViaRedirect":
            return II;
        case "reauthViaPopup":
        case "reauthViaRedirect":
            return RI;
        default:
            xn(this.auth, "internal-error")
        }
    }
    resolve(e) {
        Gi(this.pendingPromise, "Pending promise was never set"),
        this.pendingPromise.resolve(e),
        this.unregisterAndCleanUp()
    }
    reject(e) {
        Gi(this.pendingPromise, "Pending promise was never set"),
        this.pendingPromise.reject(e),
        this.unregisterAndCleanUp()
    }
    unregisterAndCleanUp() {
        this.eventManager && this.eventManager.unregisterConsumer(this),
        this.pendingPromise = null,
        this.cleanUp()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const wI = new Rl(2e3,1e4);
async function bI(r, e, t) {
    if (yn(r.app))
        return Promise.reject(Hn(r, "operation-not-supported-in-this-environment"));
    const s = Vr(r);
    aR(r, e, hp);
    const o = pE(s, t);
    return new As(s,"signInViaPopup",e,o).executeNotNull()
}
class As extends mE {
    constructor(e, t, s, o, l) {
        super(e, t, o, l),
        this.provider = s,
        this.authWindow = null,
        this.pollId = null,
        As.currentPopupAction && As.currentPopupAction.cancel(),
        As.currentPopupAction = this
    }
    async executeNotNull() {
        const e = await this.execute();
        return ve(e, this.auth, "internal-error"),
        e
    }
    async onExecution() {
        Gi(this.filter.length === 1, "Popup operations only handle one event");
        const e = dp();
        this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], e),
        this.authWindow.associatedEvent = e,
        this.resolver._originValidation(this.auth).catch(t => {
            this.reject(t)
        }
        ),
        this.resolver._isIframeWebStorageSupported(this.auth, t => {
            t || this.reject(Hn(this.auth, "web-storage-unsupported"))
        }
        ),
        this.pollUserCancellation()
    }
    get eventId() {
        var e;
        return ((e = this.authWindow) === null || e === void 0 ? void 0 : e.associatedEvent) || null
    }
    cancel() {
        this.reject(Hn(this.auth, "cancelled-popup-request"))
    }
    cleanUp() {
        this.authWindow && this.authWindow.close(),
        this.pollId && window.clearTimeout(this.pollId),
        this.authWindow = null,
        this.pollId = null,
        As.currentPopupAction = null
    }
    pollUserCancellation() {
        const e = () => {
            var t, s;
            if (!((s = (t = this.authWindow) === null || t === void 0 ? void 0 : t.window) === null || s === void 0) && s.closed) {
                this.pollId = window.setTimeout( () => {
                    this.pollId = null,
                    this.reject(Hn(this.auth, "popup-closed-by-user"))
                }
                , 8e3);
                return
            }
            this.pollId = window.setTimeout(e, wI.get())
        }
        ;
        e()
    }
}
As.currentPopupAction = null;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DI = "pendingRedirect"
  , gc = new Map;
class MI extends mE {
    constructor(e, t, s=!1) {
        super(e, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], t, void 0, s),
        this.eventId = null
    }
    async execute() {
        let e = gc.get(this.auth._key());
        if (!e) {
            try {
                const s = await NI(this.resolver, this.auth) ? await super.execute() : null;
                e = () => Promise.resolve(s)
            } catch (t) {
                e = () => Promise.reject(t)
            }
            gc.set(this.auth._key(), e)
        }
        return this.bypassAuthState || gc.set(this.auth._key(), () => Promise.resolve(null)),
        e()
    }
    async onAuthEvent(e) {
        if (e.type === "signInViaRedirect")
            return super.onAuthEvent(e);
        if (e.type === "unknown") {
            this.resolve(null);
            return
        }
        if (e.eventId) {
            const t = await this.auth._redirectUserForId(e.eventId);
            if (t)
                return this.user = t,
                super.onAuthEvent(e);
            this.resolve(null)
        }
    }
    async onExecution() {}
    cleanUp() {}
}
async function NI(r, e) {
    const t = OI(e)
      , s = PI(r);
    if (!await s._isAvailable())
        return !1;
    const o = await s._get(t) === "true";
    return await s._remove(t),
    o
}
function xI(r, e) {
    gc.set(r._key(), e)
}
function PI(r) {
    return Bi(r._redirectPersistence)
}
function OI(r) {
    return mc(DI, r.config.apiKey, r.name)
}
async function VI(r, e, t=!1) {
    if (yn(r.app))
        return Promise.reject(qi(r));
    const s = Vr(r)
      , o = pE(s, e)
      , f = await new MI(s,o,t).execute();
    return f && !t && (delete f.user._redirectEventId,
    await s._persistUserIfCurrent(f.user),
    await s._setRedirectUser(null, e)),
    f
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const UI = 10 * 60 * 1e3;
class kI {
    constructor(e) {
        this.auth = e,
        this.cachedEventUids = new Set,
        this.consumers = new Set,
        this.queuedRedirectEvent = null,
        this.hasHandledPotentialRedirect = !1,
        this.lastProcessedEventTime = Date.now()
    }
    registerConsumer(e) {
        this.consumers.add(e),
        this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, e) && (this.sendToConsumer(this.queuedRedirectEvent, e),
        this.saveEventToCache(this.queuedRedirectEvent),
        this.queuedRedirectEvent = null)
    }
    unregisterConsumer(e) {
        this.consumers.delete(e)
    }
    onEvent(e) {
        if (this.hasEventBeenHandled(e))
            return !1;
        let t = !1;
        return this.consumers.forEach(s => {
            this.isEventForConsumer(e, s) && (t = !0,
            this.sendToConsumer(e, s),
            this.saveEventToCache(e))
        }
        ),
        this.hasHandledPotentialRedirect || !LI(e) || (this.hasHandledPotentialRedirect = !0,
        t || (this.queuedRedirectEvent = e,
        t = !0)),
        t
    }
    sendToConsumer(e, t) {
        var s;
        if (e.error && !gE(e)) {
            const o = ((s = e.error.code) === null || s === void 0 ? void 0 : s.split("auth/")[1]) || "internal-error";
            t.onError(Hn(this.auth, o))
        } else
            t.onAuthEvent(e)
    }
    isEventForConsumer(e, t) {
        const s = t.eventId === null || !!e.eventId && e.eventId === t.eventId;
        return t.filter.includes(e.type) && s
    }
    hasEventBeenHandled(e) {
        return Date.now() - this.lastProcessedEventTime >= UI && this.cachedEventUids.clear(),
        this.cachedEventUids.has(Iv(e))
    }
    saveEventToCache(e) {
        this.cachedEventUids.add(Iv(e)),
        this.lastProcessedEventTime = Date.now()
    }
}
function Iv(r) {
    return [r.type, r.eventId, r.sessionId, r.tenantId].filter(e => e).join("-")
}
function gE({type: r, error: e}) {
    return r === "unknown" && (e == null ? void 0 : e.code) === "auth/no-auth-event"
}
function LI(r) {
    switch (r.type) {
    case "signInViaRedirect":
    case "linkViaRedirect":
    case "reauthViaRedirect":
        return !0;
    case "unknown":
        return gE(r);
    default:
        return !1
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function BI(r, e={}) {
    return Or(r, "GET", "/v1/projects", e)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const qI = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/
  , zI = /^https?/;
async function FI(r) {
    if (r.config.emulator)
        return;
    const {authorizedDomains: e} = await BI(r);
    for (const t of e)
        try {
            if (HI(t))
                return
        } catch {}
    xn(r, "unauthorized-domain")
}
function HI(r) {
    const e = Md()
      , {protocol: t, hostname: s} = new URL(e);
    if (r.startsWith("chrome-extension://")) {
        const f = new URL(r);
        return f.hostname === "" && s === "" ? t === "chrome-extension:" && r.replace("chrome-extension://", "") === e.replace("chrome-extension://", "") : t === "chrome-extension:" && f.hostname === s
    }
    if (!zI.test(t))
        return !1;
    if (qI.test(r))
        return s === r;
    const o = r.replace(/\./g, "\\.");
    return new RegExp("^(.+\\." + o + "|" + o + ")$","i").test(s)
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const GI = new Rl(3e4,6e4);
function wv() {
    const r = li().___jsl;
    if (r != null && r.H) {
        for (const e of Object.keys(r.H))
            if (r.H[e].r = r.H[e].r || [],
            r.H[e].L = r.H[e].L || [],
            r.H[e].r = [...r.H[e].L],
            r.CP)
                for (let t = 0; t < r.CP.length; t++)
                    r.CP[t] = null
    }
}
function YI(r) {
    return new Promise( (e, t) => {
        var s, o, l;
        function f() {
            wv(),
            gapi.load("gapi.iframes", {
                callback: () => {
                    e(gapi.iframes.getContext())
                }
                ,
                ontimeout: () => {
                    wv(),
                    t(Hn(r, "network-request-failed"))
                }
                ,
                timeout: GI.get()
            })
        }
        if (!((o = (s = li().gapi) === null || s === void 0 ? void 0 : s.iframes) === null || o === void 0) && o.Iframe)
            e(gapi.iframes.getContext());
        else if (!((l = li().gapi) === null || l === void 0) && l.load)
            f();
        else {
            const d = UR("iframefcb");
            return li()[d] = () => {
                gapi.load ? f() : t(Hn(r, "network-request-failed"))
            }
            ,
            eE(`${VR()}?onload=${d}`).catch(v => t(v))
        }
    }
    ).catch(e => {
        throw yc = null,
        e
    }
    )
}
let yc = null;
function KI(r) {
    return yc = yc || YI(r),
    yc
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const QI = new Rl(5e3,15e3)
  , XI = "__/auth/iframe"
  , $I = "emulator/auth/iframe"
  , JI = {
    style: {
        position: "absolute",
        top: "-100px",
        width: "1px",
        height: "1px"
    },
    "aria-hidden": "true",
    tabindex: "-1"
}
  , jI = new Map([["identitytoolkit.googleapis.com", "p"], ["staging-identitytoolkit.sandbox.googleapis.com", "s"], ["test-identitytoolkit.sandbox.googleapis.com", "t"]]);
function WI(r) {
    const e = r.config;
    ve(e.authDomain, r, "auth-domain-config-required");
    const t = e.emulator ? ap(e, $I) : `https://${r.config.authDomain}/${XI}`
      , s = {
        apiKey: e.apiKey,
        appName: r.name,
        v: Ho
    }
      , o = jI.get(r.config.apiHost);
    o && (s.eid = o);
    const l = r._getFrameworks();
    return l.length && (s.fw = l.join(",")),
    `${t}?${Cl(s).slice(1)}`
}
async function ZI(r) {
    const e = await KI(r)
      , t = li().gapi;
    return ve(t, r, "internal-error"),
    e.open({
        where: document.body,
        url: WI(r),
        messageHandlersFilter: t.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
        attributes: JI,
        dontclear: !0
    }, s => new Promise(async (o, l) => {
        await s.restyle({
            setHideOnLeave: !1
        });
        const f = Hn(r, "network-request-failed")
          , d = li().setTimeout( () => {
            l(f)
        }
        , QI.get());
        function v() {
            li().clearTimeout(d),
            o(s)
        }
        s.ping(v).then(v, () => {
            l(f)
        }
        )
    }
    ))
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ew = {
    location: "yes",
    resizable: "yes",
    statusbar: "yes",
    toolbar: "no"
}
  , tw = 500
  , nw = 600
  , iw = "_blank"
  , rw = "http://localhost";
class bv {
    constructor(e) {
        this.window = e,
        this.associatedEvent = null
    }
    close() {
        if (this.window)
            try {
                this.window.close()
            } catch {}
    }
}
function sw(r, e, t, s=tw, o=nw) {
    const l = Math.max((window.screen.availHeight - o) / 2, 0).toString()
      , f = Math.max((window.screen.availWidth - s) / 2, 0).toString();
    let d = "";
    const v = Object.assign(Object.assign({}, ew), {
        width: s.toString(),
        height: o.toString(),
        top: l,
        left: f
    })
      , y = Jt().toLowerCase();
    t && (d = QT(y) ? iw : t),
    YT(y) && (e = e || rw,
    v.scrollbars = "yes");
    const T = Object.entries(v).reduce( (I, [V,q]) => `${I}${V}=${q},`, "");
    if (IR(y) && d !== "_self")
        return ow(e || "", d),
        new bv(null);
    const A = window.open(e || "", d, T);
    ve(A, r, "popup-blocked");
    try {
        A.focus()
    } catch {}
    return new bv(A)
}
function ow(r, e) {
    const t = document.createElement("a");
    t.href = r,
    t.target = e;
    const s = document.createEvent("MouseEvent");
    s.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null),
    t.dispatchEvent(s)
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const aw = "__/auth/handler"
  , lw = "emulator/auth/handler"
  , uw = encodeURIComponent("fac");
async function Dv(r, e, t, s, o, l) {
    ve(r.config.authDomain, r, "auth-domain-config-required"),
    ve(r.config.apiKey, r, "invalid-api-key");
    const f = {
        apiKey: r.config.apiKey,
        appName: r.name,
        authType: t,
        redirectUrl: s,
        v: Ho,
        eventId: o
    };
    if (e instanceof hp) {
        e.setDefaultLanguage(r.languageCode),
        f.providerId = e.providerId || "",
        YA(e.getCustomParameters()) || (f.customParameters = JSON.stringify(e.getCustomParameters()));
        for (const [T,A] of Object.entries({}))
            f[T] = A
    }
    if (e instanceof wl) {
        const T = e.getScopes().filter(A => A !== "");
        T.length > 0 && (f.scopes = T.join(","))
    }
    r.tenantId && (f.tid = r.tenantId);
    const d = f;
    for (const T of Object.keys(d))
        d[T] === void 0 && delete d[T];
    const v = await r._getAppCheckToken()
      , y = v ? `#${uw}=${encodeURIComponent(v)}` : "";
    return `${cw(r)}?${Cl(d).slice(1)}${y}`
}
function cw({config: r}) {
    return r.emulator ? ap(r, lw) : `https://${r.authDomain}/${aw}`
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ed = "webStorageSupport";
class fw {
    constructor() {
        this.eventManagers = {},
        this.iframes = {},
        this.originValidationPromises = {},
        this._redirectPersistence = uE,
        this._completeRedirectFn = VI,
        this._overrideRedirectResult = xI
    }
    async _openPopup(e, t, s, o) {
        var l;
        Gi((l = this.eventManagers[e._key()]) === null || l === void 0 ? void 0 : l.manager, "_initialize() not called before _openPopup()");
        const f = await Dv(e, t, s, Md(), o);
        return sw(e, f, dp())
    }
    async _openRedirect(e, t, s, o) {
        await this._originValidation(e);
        const l = await Dv(e, t, s, Md(), o);
        return pI(l),
        new Promise( () => {}
        )
    }
    _initialize(e) {
        const t = e._key();
        if (this.eventManagers[t]) {
            const {manager: o, promise: l} = this.eventManagers[t];
            return o ? Promise.resolve(o) : (Gi(l, "If manager is not set, promise should be"),
            l)
        }
        const s = this.initAndGetManager(e);
        return this.eventManagers[t] = {
            promise: s
        },
        s.catch( () => {
            delete this.eventManagers[t]
        }
        ),
        s
    }
    async initAndGetManager(e) {
        const t = await ZI(e)
          , s = new kI(e);
        return t.register("authEvent", o => (ve(o == null ? void 0 : o.authEvent, e, "invalid-auth-event"),
        {
            status: s.onEvent(o.authEvent) ? "ACK" : "ERROR"
        }), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER),
        this.eventManagers[e._key()] = {
            manager: s
        },
        this.iframes[e._key()] = t,
        s
    }
    _isIframeWebStorageSupported(e, t) {
        this.iframes[e._key()].send(Ed, {
            type: Ed
        }, o => {
            var l;
            const f = (l = o == null ? void 0 : o[0]) === null || l === void 0 ? void 0 : l[Ed];
            f !== void 0 && t(!!f),
            xn(e, "internal-error")
        }
        , gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER)
    }
    _originValidation(e) {
        const t = e._key();
        return this.originValidationPromises[t] || (this.originValidationPromises[t] = FI(e)),
        this.originValidationPromises[t]
    }
    get _shouldInitProactively() {
        return WT() || KT() || up()
    }
}
const hw = fw;
var Mv = "@firebase/auth"
  , Nv = "1.10.1";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dw {
    constructor(e) {
        this.auth = e,
        this.internalListeners = new Map
    }
    getUid() {
        var e;
        return this.assertAuthConfigured(),
        ((e = this.auth.currentUser) === null || e === void 0 ? void 0 : e.uid) || null
    }
    async getToken(e) {
        return this.assertAuthConfigured(),
        await this.auth._initializationPromise,
        this.auth.currentUser ? {
            accessToken: await this.auth.currentUser.getIdToken(e)
        } : null
    }
    addAuthTokenListener(e) {
        if (this.assertAuthConfigured(),
        this.internalListeners.has(e))
            return;
        const t = this.auth.onIdTokenChanged(s => {
            e((s == null ? void 0 : s.stsTokenManager.accessToken) || null)
        }
        );
        this.internalListeners.set(e, t),
        this.updateProactiveRefresh()
    }
    removeAuthTokenListener(e) {
        this.assertAuthConfigured();
        const t = this.internalListeners.get(e);
        t && (this.internalListeners.delete(e),
        t(),
        this.updateProactiveRefresh())
    }
    assertAuthConfigured() {
        ve(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth")
    }
    updateProactiveRefresh() {
        this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function pw(r) {
    switch (r) {
    case "Node":
        return "node";
    case "ReactNative":
        return "rn";
    case "Worker":
        return "webworker";
    case "Cordova":
        return "cordova";
    case "WebExtension":
        return "web-extension";
    default:
        return
    }
}
function mw(r) {
    ko(new bs("auth", (e, {options: t}) => {
        const s = e.getProvider("app").getImmediate()
          , o = e.getProvider("heartbeat")
          , l = e.getProvider("app-check-internal")
          , {apiKey: f, authDomain: d} = s.options;
        ve(f && !f.includes(":"), "invalid-api-key", {
            appName: s.name
        });
        const v = {
            apiKey: f,
            authDomain: d,
            clientPlatform: r,
            apiHost: "identitytoolkit.googleapis.com",
            tokenApiHost: "securetoken.googleapis.com",
            apiScheme: "https",
            sdkClientVersion: ZT(r)
        }
          , y = new xR(s,o,l,v);
        return FR(y, t),
        y
    }
    ,"PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback( (e, t, s) => {
        e.getProvider("auth-internal").initialize()
    }
    )),
    ko(new bs("auth-internal",e => {
        const t = Vr(e.getProvider("auth").getImmediate());
        return (s => new dw(s))(t)
    }
    ,"PRIVATE").setInstantiationMode("EXPLICIT")),
    br(Mv, Nv, pw(r)),
    br(Mv, Nv, "esm2017")
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const gw = 5 * 60
  , yw = NT("authIdTokenMaxAge") || gw;
let xv = null;
const vw = r => async e => {
    const t = e && await e.getIdTokenResult()
      , s = t && (new Date().getTime() - Date.parse(t.issuedAtTime)) / 1e3;
    if (s && s > yw)
        return;
    const o = t == null ? void 0 : t.token;
    xv !== o && (xv = o,
    await fetch(r, {
        method: o ? "POST" : "DELETE",
        headers: o ? {
            Authorization: `Bearer ${o}`
        } : {}
    }))
}
;
function _w(r=VT()) {
    const e = ip(r, "auth");
    if (e.isInitialized())
        return e.getImmediate();
    const t = zR(r, {
        popupRedirectResolver: hw,
        persistence: [AI, fI, uE]
    })
      , s = NT("authTokenSyncURL");
    if (s && typeof isSecureContext == "boolean" && isSecureContext) {
        const l = new URL(s,location.origin);
        if (location.origin === l.origin) {
            const f = vw(l.toString());
            oI(t, f, () => f(t.currentUser)),
            sI(t, d => f(d))
        }
    }
    const o = DT("auth");
    return o && HR(t, `http://${o}`),
    t
}
function Tw() {
    var r, e;
    return (e = (r = document.getElementsByTagName("head")) === null || r === void 0 ? void 0 : r[0]) !== null && e !== void 0 ? e : document
}
PR({
    loadJS(r) {
        return new Promise( (e, t) => {
            const s = document.createElement("script");
            s.setAttribute("src", r),
            s.onload = e,
            s.onerror = o => {
                const l = Hn("internal-error");
                l.customData = o,
                t(l)
            }
            ,
            s.type = "text/javascript",
            s.charset = "UTF-8",
            Tw().appendChild(s)
        }
        )
    },
    gapiScript: "https://apis.google.com/js/api.js",
    recaptchaV2Script: "https://www.google.com/recaptcha/api.js",
    recaptchaEnterpriseScript: "https://www.google.com/recaptcha/enterprise.js?render="
});
mw("Browser");
var Pv = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/
var mp;
(function() {
    var r;
    /** @license

 Copyright The Closure Library Authors.
 SPDX-License-Identifier: Apache-2.0
*/
    function e(U, w) {
        function M() {}
        M.prototype = w.prototype,
        U.D = w.prototype,
        U.prototype = new M,
        U.prototype.constructor = U,
        U.C = function(P, k, B) {
            for (var N = Array(arguments.length - 2), $e = 2; $e < arguments.length; $e++)
                N[$e - 2] = arguments[$e];
            return w.prototype[k].apply(P, N)
        }
    }
    function t() {
        this.blockSize = -1
    }
    function s() {
        this.blockSize = -1,
        this.blockSize = 64,
        this.g = Array(4),
        this.B = Array(this.blockSize),
        this.o = this.h = 0,
        this.s()
    }
    e(s, t),
    s.prototype.s = function() {
        this.g[0] = 1732584193,
        this.g[1] = 4023233417,
        this.g[2] = 2562383102,
        this.g[3] = 271733878,
        this.o = this.h = 0
    }
    ;
    function o(U, w, M) {
        M || (M = 0);
        var P = Array(16);
        if (typeof w == "string")
            for (var k = 0; 16 > k; ++k)
                P[k] = w.charCodeAt(M++) | w.charCodeAt(M++) << 8 | w.charCodeAt(M++) << 16 | w.charCodeAt(M++) << 24;
        else
            for (k = 0; 16 > k; ++k)
                P[k] = w[M++] | w[M++] << 8 | w[M++] << 16 | w[M++] << 24;
        w = U.g[0],
        M = U.g[1],
        k = U.g[2];
        var B = U.g[3]
          , N = w + (B ^ M & (k ^ B)) + P[0] + 3614090360 & 4294967295;
        w = M + (N << 7 & 4294967295 | N >>> 25),
        N = B + (k ^ w & (M ^ k)) + P[1] + 3905402710 & 4294967295,
        B = w + (N << 12 & 4294967295 | N >>> 20),
        N = k + (M ^ B & (w ^ M)) + P[2] + 606105819 & 4294967295,
        k = B + (N << 17 & 4294967295 | N >>> 15),
        N = M + (w ^ k & (B ^ w)) + P[3] + 3250441966 & 4294967295,
        M = k + (N << 22 & 4294967295 | N >>> 10),
        N = w + (B ^ M & (k ^ B)) + P[4] + 4118548399 & 4294967295,
        w = M + (N << 7 & 4294967295 | N >>> 25),
        N = B + (k ^ w & (M ^ k)) + P[5] + 1200080426 & 4294967295,
        B = w + (N << 12 & 4294967295 | N >>> 20),
        N = k + (M ^ B & (w ^ M)) + P[6] + 2821735955 & 4294967295,
        k = B + (N << 17 & 4294967295 | N >>> 15),
        N = M + (w ^ k & (B ^ w)) + P[7] + 4249261313 & 4294967295,
        M = k + (N << 22 & 4294967295 | N >>> 10),
        N = w + (B ^ M & (k ^ B)) + P[8] + 1770035416 & 4294967295,
        w = M + (N << 7 & 4294967295 | N >>> 25),
        N = B + (k ^ w & (M ^ k)) + P[9] + 2336552879 & 4294967295,
        B = w + (N << 12 & 4294967295 | N >>> 20),
        N = k + (M ^ B & (w ^ M)) + P[10] + 4294925233 & 4294967295,
        k = B + (N << 17 & 4294967295 | N >>> 15),
        N = M + (w ^ k & (B ^ w)) + P[11] + 2304563134 & 4294967295,
        M = k + (N << 22 & 4294967295 | N >>> 10),
        N = w + (B ^ M & (k ^ B)) + P[12] + 1804603682 & 4294967295,
        w = M + (N << 7 & 4294967295 | N >>> 25),
        N = B + (k ^ w & (M ^ k)) + P[13] + 4254626195 & 4294967295,
        B = w + (N << 12 & 4294967295 | N >>> 20),
        N = k + (M ^ B & (w ^ M)) + P[14] + 2792965006 & 4294967295,
        k = B + (N << 17 & 4294967295 | N >>> 15),
        N = M + (w ^ k & (B ^ w)) + P[15] + 1236535329 & 4294967295,
        M = k + (N << 22 & 4294967295 | N >>> 10),
        N = w + (k ^ B & (M ^ k)) + P[1] + 4129170786 & 4294967295,
        w = M + (N << 5 & 4294967295 | N >>> 27),
        N = B + (M ^ k & (w ^ M)) + P[6] + 3225465664 & 4294967295,
        B = w + (N << 9 & 4294967295 | N >>> 23),
        N = k + (w ^ M & (B ^ w)) + P[11] + 643717713 & 4294967295,
        k = B + (N << 14 & 4294967295 | N >>> 18),
        N = M + (B ^ w & (k ^ B)) + P[0] + 3921069994 & 4294967295,
        M = k + (N << 20 & 4294967295 | N >>> 12),
        N = w + (k ^ B & (M ^ k)) + P[5] + 3593408605 & 4294967295,
        w = M + (N << 5 & 4294967295 | N >>> 27),
        N = B + (M ^ k & (w ^ M)) + P[10] + 38016083 & 4294967295,
        B = w + (N << 9 & 4294967295 | N >>> 23),
        N = k + (w ^ M & (B ^ w)) + P[15] + 3634488961 & 4294967295,
        k = B + (N << 14 & 4294967295 | N >>> 18),
        N = M + (B ^ w & (k ^ B)) + P[4] + 3889429448 & 4294967295,
        M = k + (N << 20 & 4294967295 | N >>> 12),
        N = w + (k ^ B & (M ^ k)) + P[9] + 568446438 & 4294967295,
        w = M + (N << 5 & 4294967295 | N >>> 27),
        N = B + (M ^ k & (w ^ M)) + P[14] + 3275163606 & 4294967295,
        B = w + (N << 9 & 4294967295 | N >>> 23),
        N = k + (w ^ M & (B ^ w)) + P[3] + 4107603335 & 4294967295,
        k = B + (N << 14 & 4294967295 | N >>> 18),
        N = M + (B ^ w & (k ^ B)) + P[8] + 1163531501 & 4294967295,
        M = k + (N << 20 & 4294967295 | N >>> 12),
        N = w + (k ^ B & (M ^ k)) + P[13] + 2850285829 & 4294967295,
        w = M + (N << 5 & 4294967295 | N >>> 27),
        N = B + (M ^ k & (w ^ M)) + P[2] + 4243563512 & 4294967295,
        B = w + (N << 9 & 4294967295 | N >>> 23),
        N = k + (w ^ M & (B ^ w)) + P[7] + 1735328473 & 4294967295,
        k = B + (N << 14 & 4294967295 | N >>> 18),
        N = M + (B ^ w & (k ^ B)) + P[12] + 2368359562 & 4294967295,
        M = k + (N << 20 & 4294967295 | N >>> 12),
        N = w + (M ^ k ^ B) + P[5] + 4294588738 & 4294967295,
        w = M + (N << 4 & 4294967295 | N >>> 28),
        N = B + (w ^ M ^ k) + P[8] + 2272392833 & 4294967295,
        B = w + (N << 11 & 4294967295 | N >>> 21),
        N = k + (B ^ w ^ M) + P[11] + 1839030562 & 4294967295,
        k = B + (N << 16 & 4294967295 | N >>> 16),
        N = M + (k ^ B ^ w) + P[14] + 4259657740 & 4294967295,
        M = k + (N << 23 & 4294967295 | N >>> 9),
        N = w + (M ^ k ^ B) + P[1] + 2763975236 & 4294967295,
        w = M + (N << 4 & 4294967295 | N >>> 28),
        N = B + (w ^ M ^ k) + P[4] + 1272893353 & 4294967295,
        B = w + (N << 11 & 4294967295 | N >>> 21),
        N = k + (B ^ w ^ M) + P[7] + 4139469664 & 4294967295,
        k = B + (N << 16 & 4294967295 | N >>> 16),
        N = M + (k ^ B ^ w) + P[10] + 3200236656 & 4294967295,
        M = k + (N << 23 & 4294967295 | N >>> 9),
        N = w + (M ^ k ^ B) + P[13] + 681279174 & 4294967295,
        w = M + (N << 4 & 4294967295 | N >>> 28),
        N = B + (w ^ M ^ k) + P[0] + 3936430074 & 4294967295,
        B = w + (N << 11 & 4294967295 | N >>> 21),
        N = k + (B ^ w ^ M) + P[3] + 3572445317 & 4294967295,
        k = B + (N << 16 & 4294967295 | N >>> 16),
        N = M + (k ^ B ^ w) + P[6] + 76029189 & 4294967295,
        M = k + (N << 23 & 4294967295 | N >>> 9),
        N = w + (M ^ k ^ B) + P[9] + 3654602809 & 4294967295,
        w = M + (N << 4 & 4294967295 | N >>> 28),
        N = B + (w ^ M ^ k) + P[12] + 3873151461 & 4294967295,
        B = w + (N << 11 & 4294967295 | N >>> 21),
        N = k + (B ^ w ^ M) + P[15] + 530742520 & 4294967295,
        k = B + (N << 16 & 4294967295 | N >>> 16),
        N = M + (k ^ B ^ w) + P[2] + 3299628645 & 4294967295,
        M = k + (N << 23 & 4294967295 | N >>> 9),
        N = w + (k ^ (M | ~B)) + P[0] + 4096336452 & 4294967295,
        w = M + (N << 6 & 4294967295 | N >>> 26),
        N = B + (M ^ (w | ~k)) + P[7] + 1126891415 & 4294967295,
        B = w + (N << 10 & 4294967295 | N >>> 22),
        N = k + (w ^ (B | ~M)) + P[14] + 2878612391 & 4294967295,
        k = B + (N << 15 & 4294967295 | N >>> 17),
        N = M + (B ^ (k | ~w)) + P[5] + 4237533241 & 4294967295,
        M = k + (N << 21 & 4294967295 | N >>> 11),
        N = w + (k ^ (M | ~B)) + P[12] + 1700485571 & 4294967295,
        w = M + (N << 6 & 4294967295 | N >>> 26),
        N = B + (M ^ (w | ~k)) + P[3] + 2399980690 & 4294967295,
        B = w + (N << 10 & 4294967295 | N >>> 22),
        N = k + (w ^ (B | ~M)) + P[10] + 4293915773 & 4294967295,
        k = B + (N << 15 & 4294967295 | N >>> 17),
        N = M + (B ^ (k | ~w)) + P[1] + 2240044497 & 4294967295,
        M = k + (N << 21 & 4294967295 | N >>> 11),
        N = w + (k ^ (M | ~B)) + P[8] + 1873313359 & 4294967295,
        w = M + (N << 6 & 4294967295 | N >>> 26),
        N = B + (M ^ (w | ~k)) + P[15] + 4264355552 & 4294967295,
        B = w + (N << 10 & 4294967295 | N >>> 22),
        N = k + (w ^ (B | ~M)) + P[6] + 2734768916 & 4294967295,
        k = B + (N << 15 & 4294967295 | N >>> 17),
        N = M + (B ^ (k | ~w)) + P[13] + 1309151649 & 4294967295,
        M = k + (N << 21 & 4294967295 | N >>> 11),
        N = w + (k ^ (M | ~B)) + P[4] + 4149444226 & 4294967295,
        w = M + (N << 6 & 4294967295 | N >>> 26),
        N = B + (M ^ (w | ~k)) + P[11] + 3174756917 & 4294967295,
        B = w + (N << 10 & 4294967295 | N >>> 22),
        N = k + (w ^ (B | ~M)) + P[2] + 718787259 & 4294967295,
        k = B + (N << 15 & 4294967295 | N >>> 17),
        N = M + (B ^ (k | ~w)) + P[9] + 3951481745 & 4294967295,
        U.g[0] = U.g[0] + w & 4294967295,
        U.g[1] = U.g[1] + (k + (N << 21 & 4294967295 | N >>> 11)) & 4294967295,
        U.g[2] = U.g[2] + k & 4294967295,
        U.g[3] = U.g[3] + B & 4294967295
    }
    s.prototype.u = function(U, w) {
        w === void 0 && (w = U.length);
        for (var M = w - this.blockSize, P = this.B, k = this.h, B = 0; B < w; ) {
            if (k == 0)
                for (; B <= M; )
                    o(this, U, B),
                    B += this.blockSize;
            if (typeof U == "string") {
                for (; B < w; )
                    if (P[k++] = U.charCodeAt(B++),
                    k == this.blockSize) {
                        o(this, P),
                        k = 0;
                        break
                    }
            } else
                for (; B < w; )
                    if (P[k++] = U[B++],
                    k == this.blockSize) {
                        o(this, P),
                        k = 0;
                        break
                    }
        }
        this.h = k,
        this.o += w
    }
    ,
    s.prototype.v = function() {
        var U = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h);
        U[0] = 128;
        for (var w = 1; w < U.length - 8; ++w)
            U[w] = 0;
        var M = 8 * this.o;
        for (w = U.length - 8; w < U.length; ++w)
            U[w] = M & 255,
            M /= 256;
        for (this.u(U),
        U = Array(16),
        w = M = 0; 4 > w; ++w)
            for (var P = 0; 32 > P; P += 8)
                U[M++] = this.g[w] >>> P & 255;
        return U
    }
    ;
    function l(U, w) {
        var M = d;
        return Object.prototype.hasOwnProperty.call(M, U) ? M[U] : M[U] = w(U)
    }
    function f(U, w) {
        this.h = w;
        for (var M = [], P = !0, k = U.length - 1; 0 <= k; k--) {
            var B = U[k] | 0;
            P && B == w || (M[k] = B,
            P = !1)
        }
        this.g = M
    }
    var d = {};
    function v(U) {
        return -128 <= U && 128 > U ? l(U, function(w) {
            return new f([w | 0],0 > w ? -1 : 0)
        }) : new f([U | 0],0 > U ? -1 : 0)
    }
    function y(U) {
        if (isNaN(U) || !isFinite(U))
            return A;
        if (0 > U)
            return J(y(-U));
        for (var w = [], M = 1, P = 0; U >= M; P++)
            w[P] = U / M | 0,
            M *= 4294967296;
        return new f(w,0)
    }
    function T(U, w) {
        if (U.length == 0)
            throw Error("number format error: empty string");
        if (w = w || 10,
        2 > w || 36 < w)
            throw Error("radix out of range: " + w);
        if (U.charAt(0) == "-")
            return J(T(U.substring(1), w));
        if (0 <= U.indexOf("-"))
            throw Error('number format error: interior "-" character');
        for (var M = y(Math.pow(w, 8)), P = A, k = 0; k < U.length; k += 8) {
            var B = Math.min(8, U.length - k)
              , N = parseInt(U.substring(k, k + B), w);
            8 > B ? (B = y(Math.pow(w, B)),
            P = P.j(B).add(y(N))) : (P = P.j(M),
            P = P.add(y(N)))
        }
        return P
    }
    var A = v(0)
      , I = v(1)
      , V = v(16777216);
    r = f.prototype,
    r.m = function() {
        if (G(this))
            return -J(this).m();
        for (var U = 0, w = 1, M = 0; M < this.g.length; M++) {
            var P = this.i(M);
            U += (0 <= P ? P : 4294967296 + P) * w,
            w *= 4294967296
        }
        return U
    }
    ,
    r.toString = function(U) {
        if (U = U || 10,
        2 > U || 36 < U)
            throw Error("radix out of range: " + U);
        if (q(this))
            return "0";
        if (G(this))
            return "-" + J(this).toString(U);
        for (var w = y(Math.pow(U, 6)), M = this, P = ""; ; ) {
            var k = ue(M, w).g;
            M = ne(M, k.j(w));
            var B = ((0 < M.g.length ? M.g[0] : M.h) >>> 0).toString(U);
            if (M = k,
            q(M))
                return B + P;
            for (; 6 > B.length; )
                B = "0" + B;
            P = B + P
        }
    }
    ,
    r.i = function(U) {
        return 0 > U ? 0 : U < this.g.length ? this.g[U] : this.h
    }
    ;
    function q(U) {
        if (U.h != 0)
            return !1;
        for (var w = 0; w < U.g.length; w++)
            if (U.g[w] != 0)
                return !1;
        return !0
    }
    function G(U) {
        return U.h == -1
    }
    r.l = function(U) {
        return U = ne(this, U),
        G(U) ? -1 : q(U) ? 0 : 1
    }
    ;
    function J(U) {
        for (var w = U.g.length, M = [], P = 0; P < w; P++)
            M[P] = ~U.g[P];
        return new f(M,~U.h).add(I)
    }
    r.abs = function() {
        return G(this) ? J(this) : this
    }
    ,
    r.add = function(U) {
        for (var w = Math.max(this.g.length, U.g.length), M = [], P = 0, k = 0; k <= w; k++) {
            var B = P + (this.i(k) & 65535) + (U.i(k) & 65535)
              , N = (B >>> 16) + (this.i(k) >>> 16) + (U.i(k) >>> 16);
            P = N >>> 16,
            B &= 65535,
            N &= 65535,
            M[k] = N << 16 | B
        }
        return new f(M,M[M.length - 1] & -2147483648 ? -1 : 0)
    }
    ;
    function ne(U, w) {
        return U.add(J(w))
    }
    r.j = function(U) {
        if (q(this) || q(U))
            return A;
        if (G(this))
            return G(U) ? J(this).j(J(U)) : J(J(this).j(U));
        if (G(U))
            return J(this.j(J(U)));
        if (0 > this.l(V) && 0 > U.l(V))
            return y(this.m() * U.m());
        for (var w = this.g.length + U.g.length, M = [], P = 0; P < 2 * w; P++)
            M[P] = 0;
        for (P = 0; P < this.g.length; P++)
            for (var k = 0; k < U.g.length; k++) {
                var B = this.i(P) >>> 16
                  , N = this.i(P) & 65535
                  , $e = U.i(k) >>> 16
                  , je = U.i(k) & 65535;
                M[2 * P + 2 * k] += N * je,
                se(M, 2 * P + 2 * k),
                M[2 * P + 2 * k + 1] += B * je,
                se(M, 2 * P + 2 * k + 1),
                M[2 * P + 2 * k + 1] += N * $e,
                se(M, 2 * P + 2 * k + 1),
                M[2 * P + 2 * k + 2] += B * $e,
                se(M, 2 * P + 2 * k + 2)
            }
        for (P = 0; P < w; P++)
            M[P] = M[2 * P + 1] << 16 | M[2 * P];
        for (P = w; P < 2 * w; P++)
            M[P] = 0;
        return new f(M,0)
    }
    ;
    function se(U, w) {
        for (; (U[w] & 65535) != U[w]; )
            U[w + 1] += U[w] >>> 16,
            U[w] &= 65535,
            w++
    }
    function le(U, w) {
        this.g = U,
        this.h = w
    }
    function ue(U, w) {
        if (q(w))
            throw Error("division by zero");
        if (q(U))
            return new le(A,A);
        if (G(U))
            return w = ue(J(U), w),
            new le(J(w.g),J(w.h));
        if (G(w))
            return w = ue(U, J(w)),
            new le(J(w.g),w.h);
        if (30 < U.g.length) {
            if (G(U) || G(w))
                throw Error("slowDivide_ only works with positive integers.");
            for (var M = I, P = w; 0 >= P.l(U); )
                M = fe(M),
                P = fe(P);
            var k = Ie(M, 1)
              , B = Ie(P, 1);
            for (P = Ie(P, 2),
            M = Ie(M, 2); !q(P); ) {
                var N = B.add(P);
                0 >= N.l(U) && (k = k.add(M),
                B = N),
                P = Ie(P, 1),
                M = Ie(M, 1)
            }
            return w = ne(U, k.j(w)),
            new le(k,w)
        }
        for (k = A; 0 <= U.l(w); ) {
            for (M = Math.max(1, Math.floor(U.m() / w.m())),
            P = Math.ceil(Math.log(M) / Math.LN2),
            P = 48 >= P ? 1 : Math.pow(2, P - 48),
            B = y(M),
            N = B.j(w); G(N) || 0 < N.l(U); )
                M -= P,
                B = y(M),
                N = B.j(w);
            q(B) && (B = I),
            k = k.add(B),
            U = ne(U, N)
        }
        return new le(k,U)
    }
    r.A = function(U) {
        return ue(this, U).h
    }
    ,
    r.and = function(U) {
        for (var w = Math.max(this.g.length, U.g.length), M = [], P = 0; P < w; P++)
            M[P] = this.i(P) & U.i(P);
        return new f(M,this.h & U.h)
    }
    ,
    r.or = function(U) {
        for (var w = Math.max(this.g.length, U.g.length), M = [], P = 0; P < w; P++)
            M[P] = this.i(P) | U.i(P);
        return new f(M,this.h | U.h)
    }
    ,
    r.xor = function(U) {
        for (var w = Math.max(this.g.length, U.g.length), M = [], P = 0; P < w; P++)
            M[P] = this.i(P) ^ U.i(P);
        return new f(M,this.h ^ U.h)
    }
    ;
    function fe(U) {
        for (var w = U.g.length + 1, M = [], P = 0; P < w; P++)
            M[P] = U.i(P) << 1 | U.i(P - 1) >>> 31;
        return new f(M,U.h)
    }
    function Ie(U, w) {
        var M = w >> 5;
        w %= 32;
        for (var P = U.g.length - M, k = [], B = 0; B < P; B++)
            k[B] = 0 < w ? U.i(B + M) >>> w | U.i(B + M + 1) << 32 - w : U.i(B + M);
        return new f(k,U.h)
    }
    s.prototype.digest = s.prototype.v,
    s.prototype.reset = s.prototype.s,
    s.prototype.update = s.prototype.u,
    f.prototype.add = f.prototype.add,
    f.prototype.multiply = f.prototype.j,
    f.prototype.modulo = f.prototype.A,
    f.prototype.compare = f.prototype.l,
    f.prototype.toNumber = f.prototype.m,
    f.prototype.toString = f.prototype.toString,
    f.prototype.getBits = f.prototype.i,
    f.fromNumber = y,
    f.fromString = T,
    mp = f
}
).apply(typeof Pv < "u" ? Pv : typeof self < "u" ? self : typeof window < "u" ? window : {});
var oc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
/** @license
Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/
var yE, al, vE, vc, Od, _E, TE, EE;
(function() {
    var r, e = typeof Object.defineProperties == "function" ? Object.defineProperty : function(c, _, E) {
        return c == Array.prototype || c == Object.prototype || (c[_] = E.value),
        c
    }
    ;
    function t(c) {
        c = [typeof globalThis == "object" && globalThis, c, typeof window == "object" && window, typeof self == "object" && self, typeof oc == "object" && oc];
        for (var _ = 0; _ < c.length; ++_) {
            var E = c[_];
            if (E && E.Math == Math)
                return E
        }
        throw Error("Cannot find global object")
    }
    var s = t(this);
    function o(c, _) {
        if (_)
            e: {
                var E = s;
                c = c.split(".");
                for (var R = 0; R < c.length - 1; R++) {
                    var z = c[R];
                    if (!(z in E))
                        break e;
                    E = E[z]
                }
                c = c[c.length - 1],
                R = E[c],
                _ = _(R),
                _ != R && _ != null && e(E, c, {
                    configurable: !0,
                    writable: !0,
                    value: _
                })
            }
    }
    function l(c, _) {
        c instanceof String && (c += "");
        var E = 0
          , R = !1
          , z = {
            next: function() {
                if (!R && E < c.length) {
                    var Q = E++;
                    return {
                        value: _(Q, c[Q]),
                        done: !1
                    }
                }
                return R = !0,
                {
                    done: !0,
                    value: void 0
                }
            }
        };
        return z[Symbol.iterator] = function() {
            return z
        }
        ,
        z
    }
    o("Array.prototype.values", function(c) {
        return c || function() {
            return l(this, function(_, E) {
                return E
            })
        }
    });
    /** @license

 Copyright The Closure Library Authors.
 SPDX-License-Identifier: Apache-2.0
*/
    var f = f || {}
      , d = this || self;
    function v(c) {
        var _ = typeof c;
        return _ = _ != "object" ? _ : c ? Array.isArray(c) ? "array" : _ : "null",
        _ == "array" || _ == "object" && typeof c.length == "number"
    }
    function y(c) {
        var _ = typeof c;
        return _ == "object" && c != null || _ == "function"
    }
    function T(c, _, E) {
        return c.call.apply(c.bind, arguments)
    }
    function A(c, _, E) {
        if (!c)
            throw Error();
        if (2 < arguments.length) {
            var R = Array.prototype.slice.call(arguments, 2);
            return function() {
                var z = Array.prototype.slice.call(arguments);
                return Array.prototype.unshift.apply(z, R),
                c.apply(_, z)
            }
        }
        return function() {
            return c.apply(_, arguments)
        }
    }
    function I(c, _, E) {
        return I = Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? T : A,
        I.apply(null, arguments)
    }
    function V(c, _) {
        var E = Array.prototype.slice.call(arguments, 1);
        return function() {
            var R = E.slice();
            return R.push.apply(R, arguments),
            c.apply(this, R)
        }
    }
    function q(c, _) {
        function E() {}
        E.prototype = _.prototype,
        c.aa = _.prototype,
        c.prototype = new E,
        c.prototype.constructor = c,
        c.Qb = function(R, z, Q) {
            for (var re = Array(arguments.length - 2), Pe = 2; Pe < arguments.length; Pe++)
                re[Pe - 2] = arguments[Pe];
            return _.prototype[z].apply(R, re)
        }
    }
    function G(c) {
        const _ = c.length;
        if (0 < _) {
            const E = Array(_);
            for (let R = 0; R < _; R++)
                E[R] = c[R];
            return E
        }
        return []
    }
    function J(c, _) {
        for (let E = 1; E < arguments.length; E++) {
            const R = arguments[E];
            if (v(R)) {
                const z = c.length || 0
                  , Q = R.length || 0;
                c.length = z + Q;
                for (let re = 0; re < Q; re++)
                    c[z + re] = R[re]
            } else
                c.push(R)
        }
    }
    class ne {
        constructor(_, E) {
            this.i = _,
            this.j = E,
            this.h = 0,
            this.g = null
        }
        get() {
            let _;
            return 0 < this.h ? (this.h--,
            _ = this.g,
            this.g = _.next,
            _.next = null) : _ = this.i(),
            _
        }
    }
    function se(c) {
        return /^[\s\xa0]*$/.test(c)
    }
    function le() {
        var c = d.navigator;
        return c && (c = c.userAgent) ? c : ""
    }
    function ue(c) {
        return ue[" "](c),
        c
    }
    ue[" "] = function() {}
    ;
    var fe = le().indexOf("Gecko") != -1 && !(le().toLowerCase().indexOf("webkit") != -1 && le().indexOf("Edge") == -1) && !(le().indexOf("Trident") != -1 || le().indexOf("MSIE") != -1) && le().indexOf("Edge") == -1;
    function Ie(c, _, E) {
        for (const R in c)
            _.call(E, c[R], R, c)
    }
    function U(c, _) {
        for (const E in c)
            _.call(void 0, c[E], E, c)
    }
    function w(c) {
        const _ = {};
        for (const E in c)
            _[E] = c[E];
        return _
    }
    const M = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
    function P(c, _) {
        let E, R;
        for (let z = 1; z < arguments.length; z++) {
            R = arguments[z];
            for (E in R)
                c[E] = R[E];
            for (let Q = 0; Q < M.length; Q++)
                E = M[Q],
                Object.prototype.hasOwnProperty.call(R, E) && (c[E] = R[E])
        }
    }
    function k(c) {
        var _ = 1;
        c = c.split(":");
        const E = [];
        for (; 0 < _ && c.length; )
            E.push(c.shift()),
            _--;
        return c.length && E.push(c.join(":")),
        E
    }
    function B(c) {
        d.setTimeout( () => {
            throw c
        }
        , 0)
    }
    function N() {
        var c = Be;
        let _ = null;
        return c.g && (_ = c.g,
        c.g = c.g.next,
        c.g || (c.h = null),
        _.next = null),
        _
    }
    class $e {
        constructor() {
            this.h = this.g = null
        }
        add(_, E) {
            const R = je.get();
            R.set(_, E),
            this.h ? this.h.next = R : this.g = R,
            this.h = R
        }
    }
    var je = new ne( () => new X,c => c.reset());
    class X {
        constructor() {
            this.next = this.g = this.h = null
        }
        set(_, E) {
            this.h = _,
            this.g = E,
            this.next = null
        }
        reset() {
            this.next = this.g = this.h = null
        }
    }
    let oe, pe = !1, Be = new $e, x = () => {
        const c = d.Promise.resolve(void 0);
        oe = () => {
            c.then(ee)
        }
    }
    ;
    var ee = () => {
        for (var c; c = N(); ) {
            try {
                c.h.call(c.g)
            } catch (E) {
                B(E)
            }
            var _ = je;
            _.j(c),
            100 > _.h && (_.h++,
            c.next = _.g,
            _.g = c)
        }
        pe = !1
    }
    ;
    function ae() {
        this.s = this.s,
        this.C = this.C
    }
    ae.prototype.s = !1,
    ae.prototype.ma = function() {
        this.s || (this.s = !0,
        this.N())
    }
    ,
    ae.prototype.N = function() {
        if (this.C)
            for (; this.C.length; )
                this.C.shift()()
    }
    ;
    function ie(c, _) {
        this.type = c,
        this.g = this.target = _,
        this.defaultPrevented = !1
    }
    ie.prototype.h = function() {
        this.defaultPrevented = !0
    }
    ;
    var me = function() {
        if (!d.addEventListener || !Object.defineProperty)
            return !1;
        var c = !1
          , _ = Object.defineProperty({}, "passive", {
            get: function() {
                c = !0
            }
        });
        try {
            const E = () => {}
            ;
            d.addEventListener("test", E, _),
            d.removeEventListener("test", E, _)
        } catch {}
        return c
    }();
    function we(c, _) {
        if (ie.call(this, c ? c.type : ""),
        this.relatedTarget = this.g = this.target = null,
        this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0,
        this.key = "",
        this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1,
        this.state = null,
        this.pointerId = 0,
        this.pointerType = "",
        this.i = null,
        c) {
            var E = this.type = c.type
              , R = c.changedTouches && c.changedTouches.length ? c.changedTouches[0] : null;
            if (this.target = c.target || c.srcElement,
            this.g = _,
            _ = c.relatedTarget) {
                if (fe) {
                    e: {
                        try {
                            ue(_.nodeName);
                            var z = !0;
                            break e
                        } catch {}
                        z = !1
                    }
                    z || (_ = null)
                }
            } else
                E == "mouseover" ? _ = c.fromElement : E == "mouseout" && (_ = c.toElement);
            this.relatedTarget = _,
            R ? (this.clientX = R.clientX !== void 0 ? R.clientX : R.pageX,
            this.clientY = R.clientY !== void 0 ? R.clientY : R.pageY,
            this.screenX = R.screenX || 0,
            this.screenY = R.screenY || 0) : (this.clientX = c.clientX !== void 0 ? c.clientX : c.pageX,
            this.clientY = c.clientY !== void 0 ? c.clientY : c.pageY,
            this.screenX = c.screenX || 0,
            this.screenY = c.screenY || 0),
            this.button = c.button,
            this.key = c.key || "",
            this.ctrlKey = c.ctrlKey,
            this.altKey = c.altKey,
            this.shiftKey = c.shiftKey,
            this.metaKey = c.metaKey,
            this.pointerId = c.pointerId || 0,
            this.pointerType = typeof c.pointerType == "string" ? c.pointerType : Te[c.pointerType] || "",
            this.state = c.state,
            this.i = c,
            c.defaultPrevented && we.aa.h.call(this)
        }
    }
    q(we, ie);
    var Te = {
        2: "touch",
        3: "pen",
        4: "mouse"
    };
    we.prototype.h = function() {
        we.aa.h.call(this);
        var c = this.i;
        c.preventDefault ? c.preventDefault() : c.returnValue = !1
    }
    ;
    var Rt = "closure_listenable_" + (1e6 * Math.random() | 0)
      , We = 0;
    function Gn(c, _, E, R, z) {
        this.listener = c,
        this.proxy = null,
        this.src = _,
        this.type = E,
        this.capture = !!R,
        this.ha = z,
        this.key = ++We,
        this.da = this.fa = !1
    }
    function Qi(c) {
        c.da = !0,
        c.listener = null,
        c.proxy = null,
        c.src = null,
        c.ha = null
    }
    function fi(c) {
        this.src = c,
        this.g = {},
        this.h = 0
    }
    fi.prototype.add = function(c, _, E, R, z) {
        var Q = c.toString();
        c = this.g[Q],
        c || (c = this.g[Q] = [],
        this.h++);
        var re = qr(c, _, R, z);
        return -1 < re ? (_ = c[re],
        E || (_.fa = !1)) : (_ = new Gn(_,this.src,Q,!!R,z),
        _.fa = E,
        c.push(_)),
        _
    }
    ;
    function Br(c, _) {
        var E = _.type;
        if (E in c.g) {
            var R = c.g[E], z = Array.prototype.indexOf.call(R, _, void 0), Q;
            (Q = 0 <= z) && Array.prototype.splice.call(R, z, 1),
            Q && (Qi(_),
            c.g[E].length == 0 && (delete c.g[E],
            c.h--))
        }
    }
    function qr(c, _, E, R) {
        for (var z = 0; z < c.length; ++z) {
            var Q = c[z];
            if (!Q.da && Q.listener == _ && Q.capture == !!E && Q.ha == R)
                return z
        }
        return -1
    }
    var zr = "closure_lm_" + (1e6 * Math.random() | 0)
      , Xo = {};
    function Vl(c, _, E, R, z) {
        if (Array.isArray(_)) {
            for (var Q = 0; Q < _.length; Q++)
                Vl(c, _[Q], E, R, z);
            return null
        }
        return E = Ul(E),
        c && c[Rt] ? c.K(_, E, y(R) ? !!R.capture : !1, z) : _n(c, _, E, !1, R, z)
    }
    function _n(c, _, E, R, z, Q) {
        if (!_)
            throw Error("Invalid event type");
        var re = y(z) ? !!z.capture : !!z
          , Pe = Ls(c);
        if (Pe || (c[zr] = Pe = new fi(c)),
        E = Pe.add(_, E, R, re, Q),
        E.proxy)
            return E;
        if (R = uf(),
        E.proxy = R,
        R.src = c,
        R.listener = E,
        c.addEventListener)
            me || (z = re),
            z === void 0 && (z = !1),
            c.addEventListener(_.toString(), R, z);
        else if (c.attachEvent)
            c.attachEvent(Fr(_.toString()), R);
        else if (c.addListener && c.removeListener)
            c.addListener(R);
        else
            throw Error("addEventListener and attachEvent are unavailable.");
        return E
    }
    function uf() {
        function c(E) {
            return _.call(c.src, c.listener, E)
        }
        const _ = cf;
        return c
    }
    function $o(c, _, E, R, z) {
        if (Array.isArray(_))
            for (var Q = 0; Q < _.length; Q++)
                $o(c, _[Q], E, R, z);
        else
            R = y(R) ? !!R.capture : !!R,
            E = Ul(E),
            c && c[Rt] ? (c = c.i,
            _ = String(_).toString(),
            _ in c.g && (Q = c.g[_],
            E = qr(Q, E, R, z),
            -1 < E && (Qi(Q[E]),
            Array.prototype.splice.call(Q, E, 1),
            Q.length == 0 && (delete c.g[_],
            c.h--)))) : c && (c = Ls(c)) && (_ = c.g[_.toString()],
            c = -1,
            _ && (c = qr(_, E, R, z)),
            (E = -1 < c ? _[c] : null) && ks(E))
    }
    function ks(c) {
        if (typeof c != "number" && c && !c.da) {
            var _ = c.src;
            if (_ && _[Rt])
                Br(_.i, c);
            else {
                var E = c.type
                  , R = c.proxy;
                _.removeEventListener ? _.removeEventListener(E, R, c.capture) : _.detachEvent ? _.detachEvent(Fr(E), R) : _.addListener && _.removeListener && _.removeListener(R),
                (E = Ls(_)) ? (Br(E, c),
                E.h == 0 && (E.src = null,
                _[zr] = null)) : Qi(c)
            }
        }
    }
    function Fr(c) {
        return c in Xo ? Xo[c] : Xo[c] = "on" + c
    }
    function cf(c, _) {
        if (c.da)
            c = !0;
        else {
            _ = new we(_,this);
            var E = c.listener
              , R = c.ha || c.src;
            c.fa && ks(c),
            c = E.call(R, _)
        }
        return c
    }
    function Ls(c) {
        return c = c[zr],
        c instanceof fi ? c : null
    }
    var Jo = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
    function Ul(c) {
        return typeof c == "function" ? c : (c[Jo] || (c[Jo] = function(_) {
            return c.handleEvent(_)
        }
        ),
        c[Jo])
    }
    function st() {
        ae.call(this),
        this.i = new fi(this),
        this.M = this,
        this.F = null
    }
    q(st, ae),
    st.prototype[Rt] = !0,
    st.prototype.removeEventListener = function(c, _, E, R) {
        $o(this, c, _, E, R)
    }
    ;
    function Fe(c, _) {
        var E, R = c.F;
        if (R)
            for (E = []; R; R = R.F)
                E.push(R);
        if (c = c.M,
        R = _.type || _,
        typeof _ == "string")
            _ = new ie(_,c);
        else if (_ instanceof ie)
            _.target = _.target || c;
        else {
            var z = _;
            _ = new ie(R,c),
            P(_, z)
        }
        if (z = !0,
        E)
            for (var Q = E.length - 1; 0 <= Q; Q--) {
                var re = _.g = E[Q];
                z = ln(re, R, !0, _) && z
            }
        if (re = _.g = c,
        z = ln(re, R, !0, _) && z,
        z = ln(re, R, !1, _) && z,
        E)
            for (Q = 0; Q < E.length; Q++)
                re = _.g = E[Q],
                z = ln(re, R, !1, _) && z
    }
    st.prototype.N = function() {
        if (st.aa.N.call(this),
        this.i) {
            var c = this.i, _;
            for (_ in c.g) {
                for (var E = c.g[_], R = 0; R < E.length; R++)
                    Qi(E[R]);
                delete c.g[_],
                c.h--
            }
        }
        this.F = null
    }
    ,
    st.prototype.K = function(c, _, E, R) {
        return this.i.add(String(c), _, !1, E, R)
    }
    ,
    st.prototype.L = function(c, _, E, R) {
        return this.i.add(String(c), _, !0, E, R)
    }
    ;
    function ln(c, _, E, R) {
        if (_ = c.i.g[String(_)],
        !_)
            return !0;
        _ = _.concat();
        for (var z = !0, Q = 0; Q < _.length; ++Q) {
            var re = _[Q];
            if (re && !re.da && re.capture == E) {
                var Pe = re.listener
                  , Et = re.ha || re.src;
                re.fa && Br(c.i, re),
                z = Pe.call(Et, R) !== !1 && z
            }
        }
        return z && !R.defaultPrevented
    }
    function Ht(c, _, E) {
        if (typeof c == "function")
            E && (c = I(c, E));
        else if (c && typeof c.handleEvent == "function")
            c = I(c.handleEvent, c);
        else
            throw Error("Invalid listener argument");
        return 2147483647 < Number(_) ? -1 : d.setTimeout(c, _ || 0)
    }
    function kl(c) {
        c.g = Ht( () => {
            c.g = null,
            c.i && (c.i = !1,
            kl(c))
        }
        , c.l);
        const _ = c.h;
        c.h = null,
        c.m.apply(null, _)
    }
    class ff extends ae {
        constructor(_, E) {
            super(),
            this.m = _,
            this.l = E,
            this.h = null,
            this.i = !1,
            this.g = null
        }
        j(_) {
            this.h = arguments,
            this.g ? this.i = !0 : kl(this)
        }
        N() {
            super.N(),
            this.g && (d.clearTimeout(this.g),
            this.g = null,
            this.i = !1,
            this.h = null)
        }
    }
    function Hr(c) {
        ae.call(this),
        this.h = c,
        this.g = {}
    }
    q(Hr, ae);
    var Gr = [];
    function Yr(c) {
        Ie(c.g, function(_, E) {
            this.g.hasOwnProperty(E) && ks(_)
        }, c),
        c.g = {}
    }
    Hr.prototype.N = function() {
        Hr.aa.N.call(this),
        Yr(this)
    }
    ,
    Hr.prototype.handleEvent = function() {
        throw Error("EventHandler.handleEvent not implemented")
    }
    ;
    var Pn = d.JSON.stringify
      , Bs = d.JSON.parse
      , Kr = class {
        stringify(c) {
            return d.JSON.stringify(c, void 0)
        }
        parse(c) {
            return d.JSON.parse(c, void 0)
        }
    }
    ;
    function jo() {}
    jo.prototype.h = null;
    function Wo(c) {
        return c.h || (c.h = c.i())
    }
    function Zo() {}
    var hi = {
        OPEN: "a",
        kb: "b",
        Ja: "c",
        wb: "d"
    };
    function di() {
        ie.call(this, "d")
    }
    q(di, ie);
    function ea() {
        ie.call(this, "c")
    }
    q(ea, ie);
    var Yn = {}
      , ta = null;
    function Xi() {
        return ta = ta || new st
    }
    Yn.La = "serverreachability";
    function qs(c) {
        ie.call(this, Yn.La, c)
    }
    q(qs, ie);
    function $i(c) {
        const _ = Xi();
        Fe(_, new qs(_))
    }
    Yn.STAT_EVENT = "statevent";
    function Ll(c, _) {
        ie.call(this, Yn.STAT_EVENT, c),
        this.stat = _
    }
    q(Ll, ie);
    function tt(c) {
        const _ = Xi();
        Fe(_, new Ll(_,c))
    }
    Yn.Ma = "timingevent";
    function Tt(c, _) {
        ie.call(this, Yn.Ma, c),
        this.size = _
    }
    q(Tt, ie);
    function pt(c, _) {
        if (typeof c != "function")
            throw Error("Fn must not be null and must be a function");
        return d.setTimeout(function() {
            c()
        }, _)
    }
    function Tn() {
        this.g = !0
    }
    Tn.prototype.xa = function() {
        this.g = !1
    }
    ;
    function na(c, _, E, R, z, Q) {
        c.info(function() {
            if (c.g)
                if (Q)
                    for (var re = "", Pe = Q.split("&"), Et = 0; Et < Pe.length; Et++) {
                        var Oe = Pe[Et].split("=");
                        if (1 < Oe.length) {
                            var wt = Oe[0];
                            Oe = Oe[1];
                            var St = wt.split("_");
                            re = 2 <= St.length && St[1] == "type" ? re + (wt + "=" + Oe + "&") : re + (wt + "=redacted&")
                        }
                    }
                else
                    re = null;
            else
                re = Q;
            return "XMLHTTP REQ (" + R + ") [attempt " + z + "]: " + _ + `
` + E + `
` + re
        })
    }
    function hf(c, _, E, R, z, Q, re) {
        c.info(function() {
            return "XMLHTTP RESP (" + R + ") [ attempt " + z + "]: " + _ + `
` + E + `
` + Q + " " + re
        })
    }
    function Ji(c, _, E, R) {
        c.info(function() {
            return "XMLHTTP TEXT (" + _ + "): " + Qr(c, E) + (R ? " " + R : "")
        })
    }
    function Bl(c, _) {
        c.info(function() {
            return "TIMEOUT: " + _
        })
    }
    Tn.prototype.info = function() {}
    ;
    function Qr(c, _) {
        if (!c.g)
            return _;
        if (!_)
            return null;
        try {
            var E = JSON.parse(_);
            if (E) {
                for (c = 0; c < E.length; c++)
                    if (Array.isArray(E[c])) {
                        var R = E[c];
                        if (!(2 > R.length)) {
                            var z = R[1];
                            if (Array.isArray(z) && !(1 > z.length)) {
                                var Q = z[0];
                                if (Q != "noop" && Q != "stop" && Q != "close")
                                    for (var re = 1; re < z.length; re++)
                                        z[re] = ""
                            }
                        }
                    }
            }
            return Pn(E)
        } catch {
            return _
        }
    }
    var ji = {
        NO_ERROR: 0,
        gb: 1,
        tb: 2,
        sb: 3,
        nb: 4,
        rb: 5,
        ub: 6,
        Ia: 7,
        TIMEOUT: 8,
        xb: 9
    }, pi = {
        lb: "complete",
        Hb: "success",
        Ja: "error",
        Ia: "abort",
        zb: "ready",
        Ab: "readystatechange",
        TIMEOUT: "timeout",
        vb: "incrementaldata",
        yb: "progress",
        ob: "downloadprogress",
        Pb: "uploadprogress"
    }, Kn;
    function Qn() {}
    q(Qn, jo),
    Qn.prototype.g = function() {
        return new XMLHttpRequest
    }
    ,
    Qn.prototype.i = function() {
        return {}
    }
    ,
    Kn = new Qn;
    function jt(c, _, E, R) {
        this.j = c,
        this.i = _,
        this.l = E,
        this.R = R || 1,
        this.U = new Hr(this),
        this.I = 45e3,
        this.H = null,
        this.o = !1,
        this.m = this.A = this.v = this.L = this.F = this.S = this.B = null,
        this.D = [],
        this.g = null,
        this.C = 0,
        this.s = this.u = null,
        this.X = -1,
        this.J = !1,
        this.O = 0,
        this.M = null,
        this.W = this.K = this.T = this.P = !1,
        this.h = new ct
    }
    function ct() {
        this.i = null,
        this.g = "",
        this.h = !1
    }
    var ia = {}
      , zs = {};
    function On(c, _, E) {
        c.L = 1,
        c.v = Wr(un(_)),
        c.m = E,
        c.P = !0,
        mi(c, null)
    }
    function mi(c, _) {
        c.F = Date.now(),
        Xr(c),
        c.A = un(c.v);
        var E = c.A
          , R = c.R;
        Array.isArray(R) || (R = [String(R)]),
        ua(E.i, "t", R),
        c.C = 0,
        E = c.j.J,
        c.h = new ct,
        c.g = tu(c.j, E ? _ : null, !c.m),
        0 < c.O && (c.M = new ff(I(c.Y, c, c.g),c.O)),
        _ = c.U,
        E = c.g,
        R = c.ca;
        var z = "readystatechange";
        Array.isArray(z) || (z && (Gr[0] = z.toString()),
        z = Gr);
        for (var Q = 0; Q < z.length; Q++) {
            var re = Vl(E, z[Q], R || _.handleEvent, !1, _.h || _);
            if (!re)
                break;
            _.g[re.key] = re
        }
        _ = c.H ? w(c.H) : {},
        c.m ? (c.u || (c.u = "POST"),
        _["Content-Type"] = "application/x-www-form-urlencoded",
        c.g.ea(c.A, c.u, c.m, _)) : (c.u = "GET",
        c.g.ea(c.A, c.u, null, _)),
        $i(),
        na(c.i, c.u, c.A, c.l, c.R, c.m)
    }
    jt.prototype.ca = function(c) {
        c = c.target;
        const _ = this.M;
        _ && Cn(c) == 3 ? _.j() : this.Y(c)
    }
    ,
    jt.prototype.Y = function(c) {
        try {
            if (c == this.g)
                e: {
                    const St = Cn(this.g);
                    var _ = this.g.Ba();
                    const Ai = this.g.Z();
                    if (!(3 > St) && (St != 3 || this.g && (this.h.h || this.g.oa() || Ql(this.g)))) {
                        this.J || St != 4 || _ == 7 || (_ == 8 || 0 >= Ai ? $i(3) : $i(2)),
                        Wi(this);
                        var E = this.g.Z();
                        this.X = E;
                        t: if (ql(this)) {
                            var R = Ql(this.g);
                            c = "";
                            var z = R.length
                              , Q = Cn(this.g) == 4;
                            if (!this.h.i) {
                                if (typeof TextDecoder > "u") {
                                    Ot(this),
                                    Xn(this);
                                    var re = "";
                                    break t
                                }
                                this.h.i = new d.TextDecoder
                            }
                            for (_ = 0; _ < z; _++)
                                this.h.h = !0,
                                c += this.h.i.decode(R[_], {
                                    stream: !(Q && _ == z - 1)
                                });
                            R.length = 0,
                            this.h.g += c,
                            this.C = 0,
                            re = this.h.g
                        } else
                            re = this.g.oa();
                        if (this.o = E == 200,
                        hf(this.i, this.u, this.A, this.l, this.R, St, E),
                        this.o) {
                            if (this.T && !this.K) {
                                t: {
                                    if (this.g) {
                                        var Pe, Et = this.g;
                                        if ((Pe = Et.g ? Et.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !se(Pe)) {
                                            var Oe = Pe;
                                            break t
                                        }
                                    }
                                    Oe = null
                                }
                                if (E = Oe)
                                    Ji(this.i, this.l, E, "Initial handshake response via X-HTTP-Initial-Response"),
                                    this.K = !0,
                                    $r(this, E);
                                else {
                                    this.o = !1,
                                    this.s = 3,
                                    tt(12),
                                    Ot(this),
                                    Xn(this);
                                    break e
                                }
                            }
                            if (this.P) {
                                E = !0;
                                let Vt;
                                for (; !this.J && this.C < re.length; )
                                    if (Vt = zl(this, re),
                                    Vt == zs) {
                                        St == 4 && (this.s = 4,
                                        tt(14),
                                        E = !1),
                                        Ji(this.i, this.l, null, "[Incomplete Response]");
                                        break
                                    } else if (Vt == ia) {
                                        this.s = 4,
                                        tt(15),
                                        Ji(this.i, this.l, re, "[Invalid Chunk]"),
                                        E = !1;
                                        break
                                    } else
                                        Ji(this.i, this.l, Vt, null),
                                        $r(this, Vt);
                                if (ql(this) && this.C != 0 && (this.h.g = this.h.g.slice(this.C),
                                this.C = 0),
                                St != 4 || re.length != 0 || this.h.h || (this.s = 1,
                                tt(16),
                                E = !1),
                                this.o = this.o && E,
                                !E)
                                    Ji(this.i, this.l, re, "[Invalid Chunked Response]"),
                                    Ot(this),
                                    Xn(this);
                                else if (0 < re.length && !this.W) {
                                    this.W = !0;
                                    var wt = this.j;
                                    wt.g == this && wt.ba && !wt.M && (wt.j.info("Great, no buffering proxy detected. Bytes received: " + re.length),
                                    os(wt),
                                    wt.M = !0,
                                    tt(11))
                                }
                            } else
                                Ji(this.i, this.l, re, null),
                                $r(this, re);
                            St == 4 && Ot(this),
                            this.o && !this.J && (St == 4 ? Wl(this.j, this) : (this.o = !1,
                            Xr(this)))
                        } else
                            yf(this.g),
                            E == 400 && 0 < re.indexOf("Unknown SID") ? (this.s = 3,
                            tt(12)) : (this.s = 0,
                            tt(13)),
                            Ot(this),
                            Xn(this)
                    }
                }
        } catch {} finally {}
    }
    ;
    function ql(c) {
        return c.g ? c.u == "GET" && c.L != 2 && c.j.Ca : !1
    }
    function zl(c, _) {
        var E = c.C
          , R = _.indexOf(`
`, E);
        return R == -1 ? zs : (E = Number(_.substring(E, R)),
        isNaN(E) ? ia : (R += 1,
        R + E > _.length ? zs : (_ = _.slice(R, R + E),
        c.C = R + E,
        _)))
    }
    jt.prototype.cancel = function() {
        this.J = !0,
        Ot(this)
    }
    ;
    function Xr(c) {
        c.S = Date.now() + c.I,
        Fl(c, c.I)
    }
    function Fl(c, _) {
        if (c.B != null)
            throw Error("WatchDog timer not null");
        c.B = pt(I(c.ba, c), _)
    }
    function Wi(c) {
        c.B && (d.clearTimeout(c.B),
        c.B = null)
    }
    jt.prototype.ba = function() {
        this.B = null;
        const c = Date.now();
        0 <= c - this.S ? (Bl(this.i, this.A),
        this.L != 2 && ($i(),
        tt(17)),
        Ot(this),
        this.s = 2,
        Xn(this)) : Fl(this, this.S - c)
    }
    ;
    function Xn(c) {
        c.j.G == 0 || c.J || Wl(c.j, c)
    }
    function Ot(c) {
        Wi(c);
        var _ = c.M;
        _ && typeof _.ma == "function" && _.ma(),
        c.M = null,
        Yr(c.U),
        c.g && (_ = c.g,
        c.g = null,
        _.abort(),
        _.ma())
    }
    function $r(c, _) {
        try {
            var E = c.j;
            if (E.G != 0 && (E.g == c || ra(E.h, c))) {
                if (!c.K && ra(E.h, c) && E.G == 3) {
                    try {
                        var R = E.Da.g.parse(_)
                    } catch {
                        R = null
                    }
                    if (Array.isArray(R) && R.length == 3) {
                        var z = R;
                        if (z[0] == 0) {
                            e: if (!E.u) {
                                if (E.g)
                                    if (E.g.F + 3e3 < c.F)
                                        Zs(E),
                                        js(E);
                                    else
                                        break e;
                                pa(E),
                                tt(18)
                            }
                        } else
                            E.za = z[1],
                            0 < E.za - E.T && 37500 > z[2] && E.F && E.v == 0 && !E.C && (E.C = pt(I(E.Za, E), 6e3));
                        if (1 >= Hs(E.h) && E.ca) {
                            try {
                                E.ca()
                            } catch {}
                            E.ca = void 0
                        }
                    } else
                        Si(E, 11)
                } else if ((c.K || E.g == c) && Zs(E),
                !se(_))
                    for (z = E.Da.g.parse(_),
                    _ = 0; _ < z.length; _++) {
                        let Oe = z[_];
                        if (E.T = Oe[0],
                        Oe = Oe[1],
                        E.G == 2)
                            if (Oe[0] == "c") {
                                E.K = Oe[1],
                                E.ia = Oe[2];
                                const wt = Oe[3];
                                wt != null && (E.la = wt,
                                E.j.info("VER=" + E.la));
                                const St = Oe[4];
                                St != null && (E.Aa = St,
                                E.j.info("SVER=" + E.Aa));
                                const Ai = Oe[5];
                                Ai != null && typeof Ai == "number" && 0 < Ai && (R = 1.5 * Ai,
                                E.L = R,
                                E.j.info("backChannelRequestTimeoutMs_=" + R)),
                                R = E;
                                const Vt = c.g;
                                if (Vt) {
                                    const ti = Vt.g ? Vt.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                                    if (ti) {
                                        var Q = R.h;
                                        Q.g || ti.indexOf("spdy") == -1 && ti.indexOf("quic") == -1 && ti.indexOf("h2") == -1 || (Q.j = Q.l,
                                        Q.g = new Set,
                                        Q.h && (Gs(Q, Q.h),
                                        Q.h = null))
                                    }
                                    if (R.D) {
                                        const ga = Vt.g ? Vt.g.getResponseHeader("X-HTTP-Session-Id") : null;
                                        ga && (R.ya = ga,
                                        Ye(R.I, R.D, ga))
                                    }
                                }
                                E.G = 3,
                                E.l && E.l.ua(),
                                E.ba && (E.R = Date.now() - c.F,
                                E.j.info("Handshake RTT: " + E.R + "ms")),
                                R = E;
                                var re = c;
                                if (R.qa = eu(R, R.J ? R.ia : null, R.W),
                                re.K) {
                                    Wt(R.h, re);
                                    var Pe = re
                                      , Et = R.L;
                                    Et && (Pe.I = Et),
                                    Pe.B && (Wi(Pe),
                                    Xr(Pe)),
                                    R.g = re
                                } else
                                    Jl(R);
                                0 < E.i.length && Ws(E)
                            } else
                                Oe[0] != "stop" && Oe[0] != "close" || Si(E, 7);
                        else
                            E.G == 3 && (Oe[0] == "stop" || Oe[0] == "close" ? Oe[0] == "stop" ? Si(E, 7) : ha(E) : Oe[0] != "noop" && E.l && E.l.ta(Oe),
                            E.v = 0)
                    }
            }
            $i(4)
        } catch {}
    }
    var Hl = class {
        constructor(c, _) {
            this.g = c,
            this.map = _
        }
    }
    ;
    function gi(c) {
        this.l = c || 10,
        d.PerformanceNavigationTiming ? (c = d.performance.getEntriesByType("navigation"),
        c = 0 < c.length && (c[0].nextHopProtocol == "hq" || c[0].nextHopProtocol == "h2")) : c = !!(d.chrome && d.chrome.loadTimes && d.chrome.loadTimes() && d.chrome.loadTimes().wasFetchedViaSpdy),
        this.j = c ? this.l : 1,
        this.g = null,
        1 < this.j && (this.g = new Set),
        this.h = null,
        this.i = []
    }
    function Fs(c) {
        return c.h ? !0 : c.g ? c.g.size >= c.j : !1
    }
    function Hs(c) {
        return c.h ? 1 : c.g ? c.g.size : 0
    }
    function ra(c, _) {
        return c.h ? c.h == _ : c.g ? c.g.has(_) : !1
    }
    function Gs(c, _) {
        c.g ? c.g.add(_) : c.h = _
    }
    function Wt(c, _) {
        c.h && c.h == _ ? c.h = null : c.g && c.g.has(_) && c.g.delete(_)
    }
    gi.prototype.cancel = function() {
        if (this.i = sa(this),
        this.h)
            this.h.cancel(),
            this.h = null;
        else if (this.g && this.g.size !== 0) {
            for (const c of this.g.values())
                c.cancel();
            this.g.clear()
        }
    }
    ;
    function sa(c) {
        if (c.h != null)
            return c.i.concat(c.h.D);
        if (c.g != null && c.g.size !== 0) {
            let _ = c.i;
            for (const E of c.g.values())
                _ = _.concat(E.D);
            return _
        }
        return G(c.i)
    }
    function df(c) {
        if (c.V && typeof c.V == "function")
            return c.V();
        if (typeof Map < "u" && c instanceof Map || typeof Set < "u" && c instanceof Set)
            return Array.from(c.values());
        if (typeof c == "string")
            return c.split("");
        if (v(c)) {
            for (var _ = [], E = c.length, R = 0; R < E; R++)
                _.push(c[R]);
            return _
        }
        _ = [],
        E = 0;
        for (R in c)
            _[E++] = c[R];
        return _
    }
    function Ys(c) {
        if (c.na && typeof c.na == "function")
            return c.na();
        if (!c.V || typeof c.V != "function") {
            if (typeof Map < "u" && c instanceof Map)
                return Array.from(c.keys());
            if (!(typeof Set < "u" && c instanceof Set)) {
                if (v(c) || typeof c == "string") {
                    var _ = [];
                    c = c.length;
                    for (var E = 0; E < c; E++)
                        _.push(E);
                    return _
                }
                _ = [],
                E = 0;
                for (const R in c)
                    _[E++] = R;
                return _
            }
        }
    }
    function oa(c, _) {
        if (c.forEach && typeof c.forEach == "function")
            c.forEach(_, void 0);
        else if (v(c) || typeof c == "string")
            Array.prototype.forEach.call(c, _, void 0);
        else
            for (var E = Ys(c), R = df(c), z = R.length, Q = 0; Q < z; Q++)
                _.call(void 0, R[Q], E && E[Q], c)
    }
    var Jr = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");
    function pf(c, _) {
        if (c) {
            c = c.split("&");
            for (var E = 0; E < c.length; E++) {
                var R = c[E].indexOf("=")
                  , z = null;
                if (0 <= R) {
                    var Q = c[E].substring(0, R);
                    z = c[E].substring(R + 1)
                } else
                    Q = c[E];
                _(Q, z ? decodeURIComponent(z.replace(/\+/g, " ")) : "")
            }
        }
    }
    function mt(c) {
        if (this.g = this.o = this.j = "",
        this.s = null,
        this.m = this.l = "",
        this.h = !1,
        c instanceof mt) {
            this.h = c.h,
            jr(this, c.j),
            this.o = c.o,
            this.g = c.g,
            Zi(this, c.s),
            this.l = c.l;
            var _ = c.i
              , E = new vi;
            E.i = _.i,
            _.g && (E.g = new Map(_.g),
            E.h = _.h),
            yi(this, E),
            this.m = c.m
        } else
            c && (_ = String(c).match(Jr)) ? (this.h = !1,
            jr(this, _[1] || "", !0),
            this.o = En(_[2] || ""),
            this.g = En(_[3] || "", !0),
            Zi(this, _[4]),
            this.l = En(_[5] || "", !0),
            yi(this, _[6] || "", !0),
            this.m = En(_[7] || "")) : (this.h = !1,
            this.i = new vi(null,this.h))
    }
    mt.prototype.toString = function() {
        var c = []
          , _ = this.j;
        _ && c.push(Zr(_, aa, !0), ":");
        var E = this.g;
        return (E || _ == "file") && (c.push("//"),
        (_ = this.o) && c.push(Zr(_, aa, !0), "@"),
        c.push(encodeURIComponent(String(E)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")),
        E = this.s,
        E != null && c.push(":", String(E))),
        (E = this.l) && (this.g && E.charAt(0) != "/" && c.push("/"),
        c.push(Zr(E, E.charAt(0) == "/" ? mf : la, !0))),
        (E = this.i.toString()) && c.push("?", E),
        (E = this.m) && c.push("#", Zr(E, Ks)),
        c.join("")
    }
    ;
    function un(c) {
        return new mt(c)
    }
    function jr(c, _, E) {
        c.j = E ? En(_, !0) : _,
        c.j && (c.j = c.j.replace(/:$/, ""))
    }
    function Zi(c, _) {
        if (_) {
            if (_ = Number(_),
            isNaN(_) || 0 > _)
                throw Error("Bad port number " + _);
            c.s = _
        } else
            c.s = null
    }
    function yi(c, _, E) {
        _ instanceof vi ? (c.i = _,
        Yl(c.i, c.h)) : (E || (_ = Zr(_, gf)),
        c.i = new vi(_,c.h))
    }
    function Ye(c, _, E) {
        c.i.set(_, E)
    }
    function Wr(c) {
        return Ye(c, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)),
        c
    }
    function En(c, _) {
        return c ? _ ? decodeURI(c.replace(/%25/g, "%2525")) : decodeURIComponent(c) : ""
    }
    function Zr(c, _, E) {
        return typeof c == "string" ? (c = encodeURI(c).replace(_, Gl),
        E && (c = c.replace(/%25([0-9a-fA-F]{2})/g, "%$1")),
        c) : null
    }
    function Gl(c) {
        return c = c.charCodeAt(0),
        "%" + (c >> 4 & 15).toString(16) + (c & 15).toString(16)
    }
    var aa = /[#\/\?@]/g
      , la = /[#\?:]/g
      , mf = /[#\?]/g
      , gf = /[#\?@]/g
      , Ks = /#/g;
    function vi(c, _) {
        this.h = this.g = null,
        this.i = c || null,
        this.j = !!_
    }
    function Sn(c) {
        c.g || (c.g = new Map,
        c.h = 0,
        c.i && pf(c.i, function(_, E) {
            c.add(decodeURIComponent(_.replace(/\+/g, " ")), E)
        }))
    }
    r = vi.prototype,
    r.add = function(c, _) {
        Sn(this),
        this.i = null,
        c = $n(this, c);
        var E = this.g.get(c);
        return E || this.g.set(c, E = []),
        E.push(_),
        this.h += 1,
        this
    }
    ;
    function _i(c, _) {
        Sn(c),
        _ = $n(c, _),
        c.g.has(_) && (c.i = null,
        c.h -= c.g.get(_).length,
        c.g.delete(_))
    }
    function Ti(c, _) {
        return Sn(c),
        _ = $n(c, _),
        c.g.has(_)
    }
    r.forEach = function(c, _) {
        Sn(this),
        this.g.forEach(function(E, R) {
            E.forEach(function(z) {
                c.call(_, z, R, this)
            }, this)
        }, this)
    }
    ,
    r.na = function() {
        Sn(this);
        const c = Array.from(this.g.values())
          , _ = Array.from(this.g.keys())
          , E = [];
        for (let R = 0; R < _.length; R++) {
            const z = c[R];
            for (let Q = 0; Q < z.length; Q++)
                E.push(_[R])
        }
        return E
    }
    ,
    r.V = function(c) {
        Sn(this);
        let _ = [];
        if (typeof c == "string")
            Ti(this, c) && (_ = _.concat(this.g.get($n(this, c))));
        else {
            c = Array.from(this.g.values());
            for (let E = 0; E < c.length; E++)
                _ = _.concat(c[E])
        }
        return _
    }
    ,
    r.set = function(c, _) {
        return Sn(this),
        this.i = null,
        c = $n(this, c),
        Ti(this, c) && (this.h -= this.g.get(c).length),
        this.g.set(c, [_]),
        this.h += 1,
        this
    }
    ,
    r.get = function(c, _) {
        return c ? (c = this.V(c),
        0 < c.length ? String(c[0]) : _) : _
    }
    ;
    function ua(c, _, E) {
        _i(c, _),
        0 < E.length && (c.i = null,
        c.g.set($n(c, _), G(E)),
        c.h += E.length)
    }
    r.toString = function() {
        if (this.i)
            return this.i;
        if (!this.g)
            return "";
        const c = []
          , _ = Array.from(this.g.keys());
        for (var E = 0; E < _.length; E++) {
            var R = _[E];
            const Q = encodeURIComponent(String(R))
              , re = this.V(R);
            for (R = 0; R < re.length; R++) {
                var z = Q;
                re[R] !== "" && (z += "=" + encodeURIComponent(String(re[R]))),
                c.push(z)
            }
        }
        return this.i = c.join("&")
    }
    ;
    function $n(c, _) {
        return _ = String(_),
        c.j && (_ = _.toLowerCase()),
        _
    }
    function Yl(c, _) {
        _ && !c.j && (Sn(c),
        c.i = null,
        c.g.forEach(function(E, R) {
            var z = R.toLowerCase();
            R != z && (_i(this, R),
            ua(this, z, E))
        }, c)),
        c.j = _
    }
    function es(c, _) {
        const E = new Tn;
        if (d.Image) {
            const R = new Image;
            R.onload = V(An, E, "TestLoadImage: loaded", !0, _, R),
            R.onerror = V(An, E, "TestLoadImage: error", !1, _, R),
            R.onabort = V(An, E, "TestLoadImage: abort", !1, _, R),
            R.ontimeout = V(An, E, "TestLoadImage: timeout", !1, _, R),
            d.setTimeout(function() {
                R.ontimeout && R.ontimeout()
            }, 1e4),
            R.src = c
        } else
            _(!1)
    }
    function Vn(c, _) {
        const E = new Tn
          , R = new AbortController
          , z = setTimeout( () => {
            R.abort(),
            An(E, "TestPingServer: timeout", !1, _)
        }
        , 1e4);
        fetch(c, {
            signal: R.signal
        }).then(Q => {
            clearTimeout(z),
            Q.ok ? An(E, "TestPingServer: ok", !0, _) : An(E, "TestPingServer: server error", !1, _)
        }
        ).catch( () => {
            clearTimeout(z),
            An(E, "TestPingServer: error", !1, _)
        }
        )
    }
    function An(c, _, E, R, z) {
        try {
            z && (z.onload = null,
            z.onerror = null,
            z.onabort = null,
            z.ontimeout = null),
            R(E)
        } catch {}
    }
    function ts() {
        this.g = new Kr
    }
    function Jn(c, _, E) {
        const R = E || "";
        try {
            oa(c, function(z, Q) {
                let re = z;
                y(z) && (re = Pn(z)),
                _.push(R + Q + "=" + encodeURIComponent(re))
            })
        } catch (z) {
            throw _.push(R + "type=" + encodeURIComponent("_badmap")),
            z
        }
    }
    function er(c) {
        this.l = c.Ub || null,
        this.j = c.eb || !1
    }
    q(er, jo),
    er.prototype.g = function() {
        return new Ei(this.l,this.j)
    }
    ,
    er.prototype.i = function(c) {
        return function() {
            return c
        }
    }({});
    function Ei(c, _) {
        st.call(this),
        this.D = c,
        this.o = _,
        this.m = void 0,
        this.status = this.readyState = 0,
        this.responseType = this.responseText = this.response = this.statusText = "",
        this.onreadystatechange = null,
        this.u = new Headers,
        this.h = null,
        this.B = "GET",
        this.A = "",
        this.g = !1,
        this.v = this.j = this.l = null
    }
    q(Ei, st),
    r = Ei.prototype,
    r.open = function(c, _) {
        if (this.readyState != 0)
            throw this.abort(),
            Error("Error reopening a connection");
        this.B = c,
        this.A = _,
        this.readyState = 1,
        Wn(this)
    }
    ,
    r.send = function(c) {
        if (this.readyState != 1)
            throw this.abort(),
            Error("need to call open() first. ");
        this.g = !0;
        const _ = {
            headers: this.u,
            method: this.B,
            credentials: this.m,
            cache: void 0
        };
        c && (_.body = c),
        (this.D || d).fetch(new Request(this.A,_)).then(this.Sa.bind(this), this.ga.bind(this))
    }
    ,
    r.abort = function() {
        this.response = this.responseText = "",
        this.u = new Headers,
        this.status = 0,
        this.j && this.j.cancel("Request was aborted.").catch( () => {}
        ),
        1 <= this.readyState && this.g && this.readyState != 4 && (this.g = !1,
        jn(this)),
        this.readyState = 0
    }
    ,
    r.Sa = function(c) {
        if (this.g && (this.l = c,
        this.h || (this.status = this.l.status,
        this.statusText = this.l.statusText,
        this.h = c.headers,
        this.readyState = 2,
        Wn(this)),
        this.g && (this.readyState = 3,
        Wn(this),
        this.g)))
            if (this.responseType === "arraybuffer")
                c.arrayBuffer().then(this.Qa.bind(this), this.ga.bind(this));
            else if (typeof d.ReadableStream < "u" && "body"in c) {
                if (this.j = c.body.getReader(),
                this.o) {
                    if (this.responseType)
                        throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
                    this.response = []
                } else
                    this.response = this.responseText = "",
                    this.v = new TextDecoder;
                ca(this)
            } else
                c.text().then(this.Ra.bind(this), this.ga.bind(this))
    }
    ;
    function ca(c) {
        c.j.read().then(c.Pa.bind(c)).catch(c.ga.bind(c))
    }
    r.Pa = function(c) {
        if (this.g) {
            if (this.o && c.value)
                this.response.push(c.value);
            else if (!this.o) {
                var _ = c.value ? c.value : new Uint8Array(0);
                (_ = this.v.decode(_, {
                    stream: !c.done
                })) && (this.response = this.responseText += _)
            }
            c.done ? jn(this) : Wn(this),
            this.readyState == 3 && ca(this)
        }
    }
    ,
    r.Ra = function(c) {
        this.g && (this.response = this.responseText = c,
        jn(this))
    }
    ,
    r.Qa = function(c) {
        this.g && (this.response = c,
        jn(this))
    }
    ,
    r.ga = function() {
        this.g && jn(this)
    }
    ;
    function jn(c) {
        c.readyState = 4,
        c.l = null,
        c.j = null,
        c.v = null,
        Wn(c)
    }
    r.setRequestHeader = function(c, _) {
        this.u.append(c, _)
    }
    ,
    r.getResponseHeader = function(c) {
        return this.h && this.h.get(c.toLowerCase()) || ""
    }
    ,
    r.getAllResponseHeaders = function() {
        if (!this.h)
            return "";
        const c = []
          , _ = this.h.entries();
        for (var E = _.next(); !E.done; )
            E = E.value,
            c.push(E[0] + ": " + E[1]),
            E = _.next();
        return c.join(`\r
`)
    }
    ;
    function Wn(c) {
        c.onreadystatechange && c.onreadystatechange.call(c)
    }
    Object.defineProperty(Ei.prototype, "withCredentials", {
        get: function() {
            return this.m === "include"
        },
        set: function(c) {
            this.m = c ? "include" : "same-origin"
        }
    });
    function fa(c) {
        let _ = "";
        return Ie(c, function(E, R) {
            _ += R,
            _ += ":",
            _ += E,
            _ += `\r
`
        }),
        _
    }
    function It(c, _, E) {
        e: {
            for (R in E) {
                var R = !1;
                break e
            }
            R = !0
        }
        R || (E = fa(E),
        typeof c == "string" ? E != null && encodeURIComponent(String(E)) : Ye(c, _, E))
    }
    function ze(c) {
        st.call(this),
        this.headers = new Map,
        this.o = c || null,
        this.h = !1,
        this.v = this.g = null,
        this.D = "",
        this.m = 0,
        this.l = "",
        this.j = this.B = this.u = this.A = !1,
        this.I = null,
        this.H = "",
        this.J = !1
    }
    q(ze, st);
    var Qs = /^https?$/i
      , ns = ["POST", "PUT"];
    r = ze.prototype,
    r.Ha = function(c) {
        this.J = c
    }
    ,
    r.ea = function(c, _, E, R) {
        if (this.g)
            throw Error("[goog.net.XhrIo] Object is active with another request=" + this.D + "; newUri=" + c);
        _ = _ ? _.toUpperCase() : "GET",
        this.D = c,
        this.l = "",
        this.m = 0,
        this.A = !1,
        this.h = !0,
        this.g = this.o ? this.o.g() : Kn.g(),
        this.v = this.o ? Wo(this.o) : Wo(Kn),
        this.g.onreadystatechange = I(this.Ea, this);
        try {
            this.B = !0,
            this.g.open(_, String(c), !0),
            this.B = !1
        } catch (Q) {
            Kl(this, Q);
            return
        }
        if (c = E || "",
        E = new Map(this.headers),
        R)
            if (Object.getPrototypeOf(R) === Object.prototype)
                for (var z in R)
                    E.set(z, R[z]);
            else if (typeof R.keys == "function" && typeof R.get == "function")
                for (const Q of R.keys())
                    E.set(Q, R.get(Q));
            else
                throw Error("Unknown input type for opt_headers: " + String(R));
        R = Array.from(E.keys()).find(Q => Q.toLowerCase() == "content-type"),
        z = d.FormData && c instanceof d.FormData,
        !(0 <= Array.prototype.indexOf.call(ns, _, void 0)) || R || z || E.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
        for (const [Q,re] of E)
            this.g.setRequestHeader(Q, re);
        this.H && (this.g.responseType = this.H),
        "withCredentials"in this.g && this.g.withCredentials !== this.J && (this.g.withCredentials = this.J);
        try {
            is(this),
            this.u = !0,
            this.g.send(c),
            this.u = !1
        } catch (Q) {
            Kl(this, Q)
        }
    }
    ;
    function Kl(c, _) {
        c.h = !1,
        c.g && (c.j = !0,
        c.g.abort(),
        c.j = !1),
        c.l = _,
        c.m = 5,
        Xs(c),
        Zn(c)
    }
    function Xs(c) {
        c.A || (c.A = !0,
        Fe(c, "complete"),
        Fe(c, "error"))
    }
    r.abort = function(c) {
        this.g && this.h && (this.h = !1,
        this.j = !0,
        this.g.abort(),
        this.j = !1,
        this.m = c || 7,
        Fe(this, "complete"),
        Fe(this, "abort"),
        Zn(this))
    }
    ,
    r.N = function() {
        this.g && (this.h && (this.h = !1,
        this.j = !0,
        this.g.abort(),
        this.j = !1),
        Zn(this, !0)),
        ze.aa.N.call(this)
    }
    ,
    r.Ea = function() {
        this.s || (this.B || this.u || this.j ? $s(this) : this.bb())
    }
    ,
    r.bb = function() {
        $s(this)
    }
    ;
    function $s(c) {
        if (c.h && typeof f < "u" && (!c.v[1] || Cn(c) != 4 || c.Z() != 2)) {
            if (c.u && Cn(c) == 4)
                Ht(c.Ea, 0, c);
            else if (Fe(c, "readystatechange"),
            Cn(c) == 4) {
                c.h = !1;
                try {
                    const re = c.Z();
                    e: switch (re) {
                    case 200:
                    case 201:
                    case 202:
                    case 204:
                    case 206:
                    case 304:
                    case 1223:
                        var _ = !0;
                        break e;
                    default:
                        _ = !1
                    }
                    var E;
                    if (!(E = _)) {
                        var R;
                        if (R = re === 0) {
                            var z = String(c.D).match(Jr)[1] || null;
                            !z && d.self && d.self.location && (z = d.self.location.protocol.slice(0, -1)),
                            R = !Qs.test(z ? z.toLowerCase() : "")
                        }
                        E = R
                    }
                    if (E)
                        Fe(c, "complete"),
                        Fe(c, "success");
                    else {
                        c.m = 6;
                        try {
                            var Q = 2 < Cn(c) ? c.g.statusText : ""
                        } catch {
                            Q = ""
                        }
                        c.l = Q + " [" + c.Z() + "]",
                        Xs(c)
                    }
                } finally {
                    Zn(c)
                }
            }
        }
    }
    function Zn(c, _) {
        if (c.g) {
            is(c);
            const E = c.g
              , R = c.v[0] ? () => {}
            : null;
            c.g = null,
            c.v = null,
            _ || Fe(c, "ready");
            try {
                E.onreadystatechange = R
            } catch {}
        }
    }
    function is(c) {
        c.I && (d.clearTimeout(c.I),
        c.I = null)
    }
    r.isActive = function() {
        return !!this.g
    }
    ;
    function Cn(c) {
        return c.g ? c.g.readyState : 0
    }
    r.Z = function() {
        try {
            return 2 < Cn(this) ? this.g.status : -1
        } catch {
            return -1
        }
    }
    ,
    r.oa = function() {
        try {
            return this.g ? this.g.responseText : ""
        } catch {
            return ""
        }
    }
    ,
    r.Oa = function(c) {
        if (this.g) {
            var _ = this.g.responseText;
            return c && _.indexOf(c) == 0 && (_ = _.substring(c.length)),
            Bs(_)
        }
    }
    ;
    function Ql(c) {
        try {
            if (!c.g)
                return null;
            if ("response"in c.g)
                return c.g.response;
            switch (c.H) {
            case "":
            case "text":
                return c.g.responseText;
            case "arraybuffer":
                if ("mozResponseArrayBuffer"in c.g)
                    return c.g.mozResponseArrayBuffer
            }
            return null
        } catch {
            return null
        }
    }
    function yf(c) {
        const _ = {};
        c = (c.g && 2 <= Cn(c) && c.g.getAllResponseHeaders() || "").split(`\r
`);
        for (let R = 0; R < c.length; R++) {
            if (se(c[R]))
                continue;
            var E = k(c[R]);
            const z = E[0];
            if (E = E[1],
            typeof E != "string")
                continue;
            E = E.trim();
            const Q = _[z] || [];
            _[z] = Q,
            Q.push(E)
        }
        U(_, function(R) {
            return R.join(", ")
        })
    }
    r.Ba = function() {
        return this.m
    }
    ,
    r.Ka = function() {
        return typeof this.l == "string" ? this.l : String(this.l)
    }
    ;
    function rs(c, _, E) {
        return E && E.internalChannelParams && E.internalChannelParams[c] || _
    }
    function Js(c) {
        this.Aa = 0,
        this.i = [],
        this.j = new Tn,
        this.ia = this.qa = this.I = this.W = this.g = this.ya = this.D = this.H = this.m = this.S = this.o = null,
        this.Ya = this.U = 0,
        this.Va = rs("failFast", !1, c),
        this.F = this.C = this.u = this.s = this.l = null,
        this.X = !0,
        this.za = this.T = -1,
        this.Y = this.v = this.B = 0,
        this.Ta = rs("baseRetryDelayMs", 5e3, c),
        this.cb = rs("retryDelaySeedMs", 1e4, c),
        this.Wa = rs("forwardChannelMaxRetries", 2, c),
        this.wa = rs("forwardChannelRequestTimeoutMs", 2e4, c),
        this.pa = c && c.xmlHttpFactory || void 0,
        this.Xa = c && c.Tb || void 0,
        this.Ca = c && c.useFetchStreams || !1,
        this.L = void 0,
        this.J = c && c.supportsCrossDomainXhr || !1,
        this.K = "",
        this.h = new gi(c && c.concurrentRequestLimit),
        this.Da = new ts,
        this.P = c && c.fastHandshake || !1,
        this.O = c && c.encodeInitMessageHeaders || !1,
        this.P && this.O && (this.O = !1),
        this.Ua = c && c.Rb || !1,
        c && c.xa && this.j.xa(),
        c && c.forceLongPolling && (this.X = !1),
        this.ba = !this.P && this.X && c && c.detectBufferingProxy || !1,
        this.ja = void 0,
        c && c.longPollingTimeout && 0 < c.longPollingTimeout && (this.ja = c.longPollingTimeout),
        this.ca = void 0,
        this.R = 0,
        this.M = !1,
        this.ka = this.A = null
    }
    r = Js.prototype,
    r.la = 8,
    r.G = 1,
    r.connect = function(c, _, E, R) {
        tt(0),
        this.W = c,
        this.H = _ || {},
        E && R !== void 0 && (this.H.OSID = E,
        this.H.OAID = R),
        this.F = this.X,
        this.I = eu(this, null, this.W),
        Ws(this)
    }
    ;
    function ha(c) {
        if (Xl(c),
        c.G == 3) {
            var _ = c.U++
              , E = un(c.I);
            if (Ye(E, "SID", c.K),
            Ye(E, "RID", _),
            Ye(E, "TYPE", "terminate"),
            ss(c, E),
            _ = new jt(c,c.j,_),
            _.L = 2,
            _.v = Wr(un(E)),
            E = !1,
            d.navigator && d.navigator.sendBeacon)
                try {
                    E = d.navigator.sendBeacon(_.v.toString(), "")
                } catch {}
            !E && d.Image && (new Image().src = _.v,
            E = !0),
            E || (_.g = tu(_.j, null),
            _.g.ea(_.v)),
            _.F = Date.now(),
            Xr(_)
        }
        Zl(c)
    }
    function js(c) {
        c.g && (os(c),
        c.g.cancel(),
        c.g = null)
    }
    function Xl(c) {
        js(c),
        c.u && (d.clearTimeout(c.u),
        c.u = null),
        Zs(c),
        c.h.cancel(),
        c.s && (typeof c.s == "number" && d.clearTimeout(c.s),
        c.s = null)
    }
    function Ws(c) {
        if (!Fs(c.h) && !c.s) {
            c.s = !0;
            var _ = c.Ga;
            oe || x(),
            pe || (oe(),
            pe = !0),
            Be.add(_, c),
            c.B = 0
        }
    }
    function vf(c, _) {
        return Hs(c.h) >= c.h.j - (c.s ? 1 : 0) ? !1 : c.s ? (c.i = _.D.concat(c.i),
        !0) : c.G == 1 || c.G == 2 || c.B >= (c.Va ? 0 : c.Wa) ? !1 : (c.s = pt(I(c.Ga, c, _), ma(c, c.B)),
        c.B++,
        !0)
    }
    r.Ga = function(c) {
        if (this.s)
            if (this.s = null,
            this.G == 1) {
                if (!c) {
                    this.U = Math.floor(1e5 * Math.random()),
                    c = this.U++;
                    const z = new jt(this,this.j,c);
                    let Q = this.o;
                    if (this.S && (Q ? (Q = w(Q),
                    P(Q, this.S)) : Q = this.S),
                    this.m !== null || this.O || (z.H = Q,
                    Q = null),
                    this.P)
                        e: {
                            for (var _ = 0, E = 0; E < this.i.length; E++) {
                                t: {
                                    var R = this.i[E];
                                    if ("__data__"in R.map && (R = R.map.__data__,
                                    typeof R == "string")) {
                                        R = R.length;
                                        break t
                                    }
                                    R = void 0
                                }
                                if (R === void 0)
                                    break;
                                if (_ += R,
                                4096 < _) {
                                    _ = E;
                                    break e
                                }
                                if (_ === 4096 || E === this.i.length - 1) {
                                    _ = E + 1;
                                    break e
                                }
                            }
                            _ = 1e3
                        }
                    else
                        _ = 1e3;
                    _ = $l(this, z, _),
                    E = un(this.I),
                    Ye(E, "RID", c),
                    Ye(E, "CVER", 22),
                    this.D && Ye(E, "X-HTTP-Session-Id", this.D),
                    ss(this, E),
                    Q && (this.O ? _ = "headers=" + encodeURIComponent(String(fa(Q))) + "&" + _ : this.m && It(E, this.m, Q)),
                    Gs(this.h, z),
                    this.Ua && Ye(E, "TYPE", "init"),
                    this.P ? (Ye(E, "$req", _),
                    Ye(E, "SID", "null"),
                    z.T = !0,
                    On(z, E, null)) : On(z, E, _),
                    this.G = 2
                }
            } else
                this.G == 3 && (c ? da(this, c) : this.i.length == 0 || Fs(this.h) || da(this))
    }
    ;
    function da(c, _) {
        var E;
        _ ? E = _.l : E = c.U++;
        const R = un(c.I);
        Ye(R, "SID", c.K),
        Ye(R, "RID", E),
        Ye(R, "AID", c.T),
        ss(c, R),
        c.m && c.o && It(R, c.m, c.o),
        E = new jt(c,c.j,E,c.B + 1),
        c.m === null && (E.H = c.o),
        _ && (c.i = _.D.concat(c.i)),
        _ = $l(c, E, 1e3),
        E.I = Math.round(.5 * c.wa) + Math.round(.5 * c.wa * Math.random()),
        Gs(c.h, E),
        On(E, R, _)
    }
    function ss(c, _) {
        c.H && Ie(c.H, function(E, R) {
            Ye(_, R, E)
        }),
        c.l && oa({}, function(E, R) {
            Ye(_, R, E)
        })
    }
    function $l(c, _, E) {
        E = Math.min(c.i.length, E);
        var R = c.l ? I(c.l.Na, c.l, c) : null;
        e: {
            var z = c.i;
            let Q = -1;
            for (; ; ) {
                const re = ["count=" + E];
                Q == -1 ? 0 < E ? (Q = z[0].g,
                re.push("ofs=" + Q)) : Q = 0 : re.push("ofs=" + Q);
                let Pe = !0;
                for (let Et = 0; Et < E; Et++) {
                    let Oe = z[Et].g;
                    const wt = z[Et].map;
                    if (Oe -= Q,
                    0 > Oe)
                        Q = Math.max(0, z[Et].g - 100),
                        Pe = !1;
                    else
                        try {
                            Jn(wt, re, "req" + Oe + "_")
                        } catch {
                            R && R(wt)
                        }
                }
                if (Pe) {
                    R = re.join("&");
                    break e
                }
            }
        }
        return c = c.i.splice(0, E),
        _.D = c,
        R
    }
    function Jl(c) {
        if (!c.g && !c.u) {
            c.Y = 1;
            var _ = c.Fa;
            oe || x(),
            pe || (oe(),
            pe = !0),
            Be.add(_, c),
            c.v = 0
        }
    }
    function pa(c) {
        return c.g || c.u || 3 <= c.v ? !1 : (c.Y++,
        c.u = pt(I(c.Fa, c), ma(c, c.v)),
        c.v++,
        !0)
    }
    r.Fa = function() {
        if (this.u = null,
        jl(this),
        this.ba && !(this.M || this.g == null || 0 >= this.R)) {
            var c = 2 * this.R;
            this.j.info("BP detection timer enabled: " + c),
            this.A = pt(I(this.ab, this), c)
        }
    }
    ,
    r.ab = function() {
        this.A && (this.A = null,
        this.j.info("BP detection timeout reached."),
        this.j.info("Buffering proxy detected and switch to long-polling!"),
        this.F = !1,
        this.M = !0,
        tt(10),
        js(this),
        jl(this))
    }
    ;
    function os(c) {
        c.A != null && (d.clearTimeout(c.A),
        c.A = null)
    }
    function jl(c) {
        c.g = new jt(c,c.j,"rpc",c.Y),
        c.m === null && (c.g.H = c.o),
        c.g.O = 0;
        var _ = un(c.qa);
        Ye(_, "RID", "rpc"),
        Ye(_, "SID", c.K),
        Ye(_, "AID", c.T),
        Ye(_, "CI", c.F ? "0" : "1"),
        !c.F && c.ja && Ye(_, "TO", c.ja),
        Ye(_, "TYPE", "xmlhttp"),
        ss(c, _),
        c.m && c.o && It(_, c.m, c.o),
        c.L && (c.g.I = c.L);
        var E = c.g;
        c = c.ia,
        E.L = 1,
        E.v = Wr(un(_)),
        E.m = null,
        E.P = !0,
        mi(E, c)
    }
    r.Za = function() {
        this.C != null && (this.C = null,
        js(this),
        pa(this),
        tt(19))
    }
    ;
    function Zs(c) {
        c.C != null && (d.clearTimeout(c.C),
        c.C = null)
    }
    function Wl(c, _) {
        var E = null;
        if (c.g == _) {
            Zs(c),
            os(c),
            c.g = null;
            var R = 2
        } else if (ra(c.h, _))
            E = _.D,
            Wt(c.h, _),
            R = 1;
        else
            return;
        if (c.G != 0) {
            if (_.o)
                if (R == 1) {
                    E = _.m ? _.m.length : 0,
                    _ = Date.now() - _.F;
                    var z = c.B;
                    R = Xi(),
                    Fe(R, new Tt(R,E)),
                    Ws(c)
                } else
                    Jl(c);
            else if (z = _.s,
            z == 3 || z == 0 && 0 < _.X || !(R == 1 && vf(c, _) || R == 2 && pa(c)))
                switch (E && 0 < E.length && (_ = c.h,
                _.i = _.i.concat(E)),
                z) {
                case 1:
                    Si(c, 5);
                    break;
                case 4:
                    Si(c, 10);
                    break;
                case 3:
                    Si(c, 6);
                    break;
                default:
                    Si(c, 2)
                }
        }
    }
    function ma(c, _) {
        let E = c.Ta + Math.floor(Math.random() * c.cb);
        return c.isActive() || (E *= 2),
        E * _
    }
    function Si(c, _) {
        if (c.j.info("Error code " + _),
        _ == 2) {
            var E = I(c.fb, c)
              , R = c.Xa;
            const z = !R;
            R = new mt(R || "//www.google.com/images/cleardot.gif"),
            d.location && d.location.protocol == "http" || jr(R, "https"),
            Wr(R),
            z ? es(R.toString(), E) : Vn(R.toString(), E)
        } else
            tt(2);
        c.G = 0,
        c.l && c.l.sa(_),
        Zl(c),
        Xl(c)
    }
    r.fb = function(c) {
        c ? (this.j.info("Successfully pinged google.com"),
        tt(2)) : (this.j.info("Failed to ping google.com"),
        tt(1))
    }
    ;
    function Zl(c) {
        if (c.G = 0,
        c.ka = [],
        c.l) {
            const _ = sa(c.h);
            (_.length != 0 || c.i.length != 0) && (J(c.ka, _),
            J(c.ka, c.i),
            c.h.i.length = 0,
            G(c.i),
            c.i.length = 0),
            c.l.ra()
        }
    }
    function eu(c, _, E) {
        var R = E instanceof mt ? un(E) : new mt(E);
        if (R.g != "")
            _ && (R.g = _ + "." + R.g),
            Zi(R, R.s);
        else {
            var z = d.location;
            R = z.protocol,
            _ = _ ? _ + "." + z.hostname : z.hostname,
            z = +z.port;
            var Q = new mt(null);
            R && jr(Q, R),
            _ && (Q.g = _),
            z && Zi(Q, z),
            E && (Q.l = E),
            R = Q
        }
        return E = c.D,
        _ = c.ya,
        E && _ && Ye(R, E, _),
        Ye(R, "VER", c.la),
        ss(c, R),
        R
    }
    function tu(c, _, E) {
        if (_ && !c.J)
            throw Error("Can't create secondary domain capable XhrIo object.");
        return _ = c.Ca && !c.pa ? new ze(new er({
            eb: E
        })) : new ze(c.pa),
        _.Ha(c.J),
        _
    }
    r.isActive = function() {
        return !!this.l && this.l.isActive(this)
    }
    ;
    function nu() {}
    r = nu.prototype,
    r.ua = function() {}
    ,
    r.ta = function() {}
    ,
    r.sa = function() {}
    ,
    r.ra = function() {}
    ,
    r.isActive = function() {
        return !0
    }
    ,
    r.Na = function() {}
    ;
    function eo() {}
    eo.prototype.g = function(c, _) {
        return new Zt(c,_)
    }
    ;
    function Zt(c, _) {
        st.call(this),
        this.g = new Js(_),
        this.l = c,
        this.h = _ && _.messageUrlParams || null,
        c = _ && _.messageHeaders || null,
        _ && _.clientProtocolHeaderRequired && (c ? c["X-Client-Protocol"] = "webchannel" : c = {
            "X-Client-Protocol": "webchannel"
        }),
        this.g.o = c,
        c = _ && _.initMessageHeaders || null,
        _ && _.messageContentType && (c ? c["X-WebChannel-Content-Type"] = _.messageContentType : c = {
            "X-WebChannel-Content-Type": _.messageContentType
        }),
        _ && _.va && (c ? c["X-WebChannel-Client-Profile"] = _.va : c = {
            "X-WebChannel-Client-Profile": _.va
        }),
        this.g.S = c,
        (c = _ && _.Sb) && !se(c) && (this.g.m = c),
        this.v = _ && _.supportsCrossDomainXhr || !1,
        this.u = _ && _.sendRawJson || !1,
        (_ = _ && _.httpSessionIdParam) && !se(_) && (this.g.D = _,
        c = this.h,
        c !== null && _ in c && (c = this.h,
        _ in c && delete c[_])),
        this.j = new ei(this)
    }
    q(Zt, st),
    Zt.prototype.m = function() {
        this.g.l = this.j,
        this.v && (this.g.J = !0),
        this.g.connect(this.l, this.h || void 0)
    }
    ,
    Zt.prototype.close = function() {
        ha(this.g)
    }
    ,
    Zt.prototype.o = function(c) {
        var _ = this.g;
        if (typeof c == "string") {
            var E = {};
            E.__data__ = c,
            c = E
        } else
            this.u && (E = {},
            E.__data__ = Pn(c),
            c = E);
        _.i.push(new Hl(_.Ya++,c)),
        _.G == 3 && Ws(_)
    }
    ,
    Zt.prototype.N = function() {
        this.g.l = null,
        delete this.j,
        ha(this.g),
        delete this.g,
        Zt.aa.N.call(this)
    }
    ;
    function iu(c) {
        di.call(this),
        c.__headers__ && (this.headers = c.__headers__,
        this.statusCode = c.__status__,
        delete c.__headers__,
        delete c.__status__);
        var _ = c.__sm__;
        if (_) {
            e: {
                for (const E in _) {
                    c = E;
                    break e
                }
                c = void 0
            }
            (this.i = c) && (c = this.i,
            _ = _ !== null && c in _ ? _[c] : void 0),
            this.data = _
        } else
            this.data = c
    }
    q(iu, di);
    function ru() {
        ea.call(this),
        this.status = 1
    }
    q(ru, ea);
    function ei(c) {
        this.g = c
    }
    q(ei, nu),
    ei.prototype.ua = function() {
        Fe(this.g, "a")
    }
    ,
    ei.prototype.ta = function(c) {
        Fe(this.g, new iu(c))
    }
    ,
    ei.prototype.sa = function(c) {
        Fe(this.g, new ru)
    }
    ,
    ei.prototype.ra = function() {
        Fe(this.g, "b")
    }
    ,
    eo.prototype.createWebChannel = eo.prototype.g,
    Zt.prototype.send = Zt.prototype.o,
    Zt.prototype.open = Zt.prototype.m,
    Zt.prototype.close = Zt.prototype.close,
    EE = function() {
        return new eo
    }
    ,
    TE = function() {
        return Xi()
    }
    ,
    _E = Yn,
    Od = {
        mb: 0,
        pb: 1,
        qb: 2,
        Jb: 3,
        Ob: 4,
        Lb: 5,
        Mb: 6,
        Kb: 7,
        Ib: 8,
        Nb: 9,
        PROXY: 10,
        NOPROXY: 11,
        Gb: 12,
        Cb: 13,
        Db: 14,
        Bb: 15,
        Eb: 16,
        Fb: 17,
        ib: 18,
        hb: 19,
        jb: 20
    },
    ji.NO_ERROR = 0,
    ji.TIMEOUT = 8,
    ji.HTTP_ERROR = 6,
    vc = ji,
    pi.COMPLETE = "complete",
    vE = pi,
    Zo.EventType = hi,
    hi.OPEN = "a",
    hi.CLOSE = "b",
    hi.ERROR = "c",
    hi.MESSAGE = "d",
    st.prototype.listen = st.prototype.K,
    al = Zo,
    ze.prototype.listenOnce = ze.prototype.L,
    ze.prototype.getLastError = ze.prototype.Ka,
    ze.prototype.getLastErrorCode = ze.prototype.Ba,
    ze.prototype.getStatus = ze.prototype.Z,
    ze.prototype.getResponseJson = ze.prototype.Oa,
    ze.prototype.getResponseText = ze.prototype.oa,
    ze.prototype.send = ze.prototype.ea,
    ze.prototype.setWithCredentials = ze.prototype.Ha,
    yE = ze
}
).apply(typeof oc < "u" ? oc : typeof self < "u" ? self : typeof window < "u" ? window : {});
const Ov = "@firebase/firestore"
  , Vv = "4.7.11";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Qt {
    constructor(e) {
        this.uid = e
    }
    isAuthenticated() {
        return this.uid != null
    }
    toKey() {
        return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user"
    }
    isEqual(e) {
        return e.uid === this.uid
    }
}
Qt.UNAUTHENTICATED = new Qt(null),
Qt.GOOGLE_CREDENTIALS = new Qt("google-credentials-uid"),
Qt.FIRST_PARTY = new Qt("first-party-uid"),
Qt.MOCK_USER = new Qt("mock-user");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Yo = "11.6.1";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ns = new tp("@firebase/firestore");
function Mo() {
    return Ns.logLevel
}
function he(r, ...e) {
    if (Ns.logLevel <= xe.DEBUG) {
        const t = e.map(gp);
        Ns.debug(`Firestore (${Yo}): ${r}`, ...t)
    }
}
function xs(r, ...e) {
    if (Ns.logLevel <= xe.ERROR) {
        const t = e.map(gp);
        Ns.error(`Firestore (${Yo}): ${r}`, ...t)
    }
}
function jc(r, ...e) {
    if (Ns.logLevel <= xe.WARN) {
        const t = e.map(gp);
        Ns.warn(`Firestore (${Yo}): ${r}`, ...t)
    }
}
function gp(r) {
    if (typeof r == "string")
        return r;
    try {
        /**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
        return function(t) {
            return JSON.stringify(t)
        }(r)
    } catch {
        return r
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function De(r, e, t) {
    let s = "Unexpected state";
    typeof e == "string" ? s = e : t = e,
    SE(r, s, t)
}
function SE(r, e, t) {
    let s = `FIRESTORE (${Yo}) INTERNAL ASSERTION FAILED: ${e} (ID: ${r.toString(16)})`;
    if (t !== void 0)
        try {
            s += " CONTEXT: " + JSON.stringify(t)
        } catch {
            s += " CONTEXT: " + t
        }
    throw xs(s),
    new Error(s)
}
function lt(r, e, t, s) {
    let o = "Unexpected state";
    typeof t == "string" ? o = t : s = t,
    r || SE(e, o, s)
}
function et(r, e) {
    return r
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const te = {
    OK: "ok",
    CANCELLED: "cancelled",
    UNKNOWN: "unknown",
    INVALID_ARGUMENT: "invalid-argument",
    DEADLINE_EXCEEDED: "deadline-exceeded",
    NOT_FOUND: "not-found",
    ALREADY_EXISTS: "already-exists",
    PERMISSION_DENIED: "permission-denied",
    UNAUTHENTICATED: "unauthenticated",
    RESOURCE_EXHAUSTED: "resource-exhausted",
    FAILED_PRECONDITION: "failed-precondition",
    ABORTED: "aborted",
    OUT_OF_RANGE: "out-of-range",
    UNIMPLEMENTED: "unimplemented",
    INTERNAL: "internal",
    UNAVAILABLE: "unavailable",
    DATA_LOSS: "data-loss"
};
class Ee extends Ki {
    constructor(e, t) {
        super(e, t),
        this.code = e,
        this.message = t,
        this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Rs {
    constructor() {
        this.promise = new Promise( (e, t) => {
            this.resolve = e,
            this.reject = t
        }
        )
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AE {
    constructor(e, t) {
        this.user = t,
        this.type = "OAuth",
        this.headers = new Map,
        this.headers.set("Authorization", `Bearer ${e}`)
    }
}
class Ew {
    getToken() {
        return Promise.resolve(null)
    }
    invalidateToken() {}
    start(e, t) {
        e.enqueueRetryable( () => t(Qt.UNAUTHENTICATED))
    }
    shutdown() {}
}
class Sw {
    constructor(e) {
        this.token = e,
        this.changeListener = null
    }
    getToken() {
        return Promise.resolve(this.token)
    }
    invalidateToken() {}
    start(e, t) {
        this.changeListener = t,
        e.enqueueRetryable( () => t(this.token.user))
    }
    shutdown() {
        this.changeListener = null
    }
}
class Aw {
    constructor(e) {
        this.t = e,
        this.currentUser = Qt.UNAUTHENTICATED,
        this.i = 0,
        this.forceRefresh = !1,
        this.auth = null
    }
    start(e, t) {
        lt(this.o === void 0, 42304);
        let s = this.i;
        const o = v => this.i !== s ? (s = this.i,
        t(v)) : Promise.resolve();
        let l = new Rs;
        this.o = () => {
            this.i++,
            this.currentUser = this.u(),
            l.resolve(),
            l = new Rs,
            e.enqueueRetryable( () => o(this.currentUser))
        }
        ;
        const f = () => {
            const v = l;
            e.enqueueRetryable(async () => {
                await v.promise,
                await o(this.currentUser)
            }
            )
        }
          , d = v => {
            he("FirebaseAuthCredentialsProvider", "Auth detected"),
            this.auth = v,
            this.o && (this.auth.addAuthTokenListener(this.o),
            f())
        }
        ;
        this.t.onInit(v => d(v)),
        setTimeout( () => {
            if (!this.auth) {
                const v = this.t.getImmediate({
                    optional: !0
                });
                v ? d(v) : (he("FirebaseAuthCredentialsProvider", "Auth not yet detected"),
                l.resolve(),
                l = new Rs)
            }
        }
        , 0),
        f()
    }
    getToken() {
        const e = this.i
          , t = this.forceRefresh;
        return this.forceRefresh = !1,
        this.auth ? this.auth.getToken(t).then(s => this.i !== e ? (he("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."),
        this.getToken()) : s ? (lt(typeof s.accessToken == "string", 31837, {
            l: s
        }),
        new AE(s.accessToken,this.currentUser)) : null) : Promise.resolve(null)
    }
    invalidateToken() {
        this.forceRefresh = !0
    }
    shutdown() {
        this.auth && this.o && this.auth.removeAuthTokenListener(this.o),
        this.o = void 0
    }
    u() {
        const e = this.auth && this.auth.getUid();
        return lt(e === null || typeof e == "string", 2055, {
            h: e
        }),
        new Qt(e)
    }
}
class Cw {
    constructor(e, t, s) {
        this.P = e,
        this.T = t,
        this.I = s,
        this.type = "FirstParty",
        this.user = Qt.FIRST_PARTY,
        this.A = new Map
    }
    R() {
        return this.I ? this.I() : null
    }
    get headers() {
        this.A.set("X-Goog-AuthUser", this.P);
        const e = this.R();
        return e && this.A.set("Authorization", e),
        this.T && this.A.set("X-Goog-Iam-Authorization-Token", this.T),
        this.A
    }
}
class Rw {
    constructor(e, t, s) {
        this.P = e,
        this.T = t,
        this.I = s
    }
    getToken() {
        return Promise.resolve(new Cw(this.P,this.T,this.I))
    }
    start(e, t) {
        e.enqueueRetryable( () => t(Qt.FIRST_PARTY))
    }
    shutdown() {}
    invalidateToken() {}
}
class Uv {
    constructor(e) {
        this.value = e,
        this.type = "AppCheck",
        this.headers = new Map,
        e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value)
    }
}
class Iw {
    constructor(e, t) {
        this.V = t,
        this.forceRefresh = !1,
        this.appCheck = null,
        this.m = null,
        this.p = null,
        yn(e) && e.settings.appCheckToken && (this.p = e.settings.appCheckToken)
    }
    start(e, t) {
        lt(this.o === void 0, 3512);
        const s = l => {
            l.error != null && he("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${l.error.message}`);
            const f = l.token !== this.m;
            return this.m = l.token,
            he("FirebaseAppCheckTokenProvider", `Received ${f ? "new" : "existing"} token.`),
            f ? t(l.token) : Promise.resolve()
        }
        ;
        this.o = l => {
            e.enqueueRetryable( () => s(l))
        }
        ;
        const o = l => {
            he("FirebaseAppCheckTokenProvider", "AppCheck detected"),
            this.appCheck = l,
            this.o && this.appCheck.addTokenListener(this.o)
        }
        ;
        this.V.onInit(l => o(l)),
        setTimeout( () => {
            if (!this.appCheck) {
                const l = this.V.getImmediate({
                    optional: !0
                });
                l ? o(l) : he("FirebaseAppCheckTokenProvider", "AppCheck not yet detected")
            }
        }
        , 0)
    }
    getToken() {
        if (this.p)
            return Promise.resolve(new Uv(this.p));
        const e = this.forceRefresh;
        return this.forceRefresh = !1,
        this.appCheck ? this.appCheck.getToken(e).then(t => t ? (lt(typeof t.token == "string", 44558, {
            tokenResult: t
        }),
        this.m = t.token,
        new Uv(t.token)) : null) : Promise.resolve(null)
    }
    invalidateToken() {
        this.forceRefresh = !0
    }
    shutdown() {
        this.appCheck && this.o && this.appCheck.removeTokenListener(this.o),
        this.o = void 0
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ww(r) {
    const e = typeof self < "u" && (self.crypto || self.msCrypto)
      , t = new Uint8Array(r);
    if (e && typeof e.getRandomValues == "function")
        e.getRandomValues(t);
    else
        for (let s = 0; s < r; s++)
            t[s] = Math.floor(256 * Math.random());
    return t
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function bw() {
    return new TextEncoder
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CE {
    static newId() {
        const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
          , t = 62 * Math.floor(4.129032258064516);
        let s = "";
        for (; s.length < 20; ) {
            const o = ww(40);
            for (let l = 0; l < o.length; ++l)
                s.length < 20 && o[l] < t && (s += e.charAt(o[l] % 62))
        }
        return s
    }
}
function ke(r, e) {
    return r < e ? -1 : r > e ? 1 : 0
}
function Vd(r, e) {
    let t = 0;
    for (; t < r.length && t < e.length; ) {
        const s = r.codePointAt(t)
          , o = e.codePointAt(t);
        if (s !== o) {
            if (s < 128 && o < 128)
                return ke(s, o);
            {
                const l = bw()
                  , f = Dw(l.encode(kv(r, t)), l.encode(kv(e, t)));
                return f !== 0 ? f : ke(s, o)
            }
        }
        t += s > 65535 ? 2 : 1
    }
    return ke(r.length, e.length)
}
function kv(r, e) {
    return r.codePointAt(e) > 65535 ? r.substring(e, e + 2) : r.substring(e, e + 1)
}
function Dw(r, e) {
    for (let t = 0; t < r.length && t < e.length; ++t)
        if (r[t] !== e[t])
            return ke(r[t], e[t]);
    return ke(r.length, e.length)
}
function Lo(r, e, t) {
    return r.length === e.length && r.every( (s, o) => t(s, e[o]))
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Lv = -62135596800
  , Bv = 1e6;
class Pt {
    static now() {
        return Pt.fromMillis(Date.now())
    }
    static fromDate(e) {
        return Pt.fromMillis(e.getTime())
    }
    static fromMillis(e) {
        const t = Math.floor(e / 1e3)
          , s = Math.floor((e - 1e3 * t) * Bv);
        return new Pt(t,s)
    }
    constructor(e, t) {
        if (this.seconds = e,
        this.nanoseconds = t,
        t < 0)
            throw new Ee(te.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: " + t);
        if (t >= 1e9)
            throw new Ee(te.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: " + t);
        if (e < Lv)
            throw new Ee(te.INVALID_ARGUMENT,"Timestamp seconds out of range: " + e);
        if (e >= 253402300800)
            throw new Ee(te.INVALID_ARGUMENT,"Timestamp seconds out of range: " + e)
    }
    toDate() {
        return new Date(this.toMillis())
    }
    toMillis() {
        return 1e3 * this.seconds + this.nanoseconds / Bv
    }
    _compareTo(e) {
        return this.seconds === e.seconds ? ke(this.nanoseconds, e.nanoseconds) : ke(this.seconds, e.seconds)
    }
    isEqual(e) {
        return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds
    }
    toString() {
        return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")"
    }
    toJSON() {
        return {
            seconds: this.seconds,
            nanoseconds: this.nanoseconds
        }
    }
    valueOf() {
        const e = this.seconds - Lv;
        return String(e).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0")
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class it {
    static fromTimestamp(e) {
        return new it(e)
    }
    static min() {
        return new it(new Pt(0,0))
    }
    static max() {
        return new it(new Pt(253402300799,999999999))
    }
    constructor(e) {
        this.timestamp = e
    }
    compareTo(e) {
        return this.timestamp._compareTo(e.timestamp)
    }
    isEqual(e) {
        return this.timestamp.isEqual(e.timestamp)
    }
    toMicroseconds() {
        return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3
    }
    toString() {
        return "SnapshotVersion(" + this.timestamp.toString() + ")"
    }
    toTimestamp() {
        return this.timestamp
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const qv = "__name__";
class ai {
    constructor(e, t, s) {
        t === void 0 ? t = 0 : t > e.length && De(637, {
            offset: t,
            range: e.length
        }),
        s === void 0 ? s = e.length - t : s > e.length - t && De(1746, {
            length: s,
            range: e.length - t
        }),
        this.segments = e,
        this.offset = t,
        this.len = s
    }
    get length() {
        return this.len
    }
    isEqual(e) {
        return ai.comparator(this, e) === 0
    }
    child(e) {
        const t = this.segments.slice(this.offset, this.limit());
        return e instanceof ai ? e.forEach(s => {
            t.push(s)
        }
        ) : t.push(e),
        this.construct(t)
    }
    limit() {
        return this.offset + this.length
    }
    popFirst(e) {
        return e = e === void 0 ? 1 : e,
        this.construct(this.segments, this.offset + e, this.length - e)
    }
    popLast() {
        return this.construct(this.segments, this.offset, this.length - 1)
    }
    firstSegment() {
        return this.segments[this.offset]
    }
    lastSegment() {
        return this.get(this.length - 1)
    }
    get(e) {
        return this.segments[this.offset + e]
    }
    isEmpty() {
        return this.length === 0
    }
    isPrefixOf(e) {
        if (e.length < this.length)
            return !1;
        for (let t = 0; t < this.length; t++)
            if (this.get(t) !== e.get(t))
                return !1;
        return !0
    }
    isImmediateParentOf(e) {
        if (this.length + 1 !== e.length)
            return !1;
        for (let t = 0; t < this.length; t++)
            if (this.get(t) !== e.get(t))
                return !1;
        return !0
    }
    forEach(e) {
        for (let t = this.offset, s = this.limit(); t < s; t++)
            e(this.segments[t])
    }
    toArray() {
        return this.segments.slice(this.offset, this.limit())
    }
    static comparator(e, t) {
        const s = Math.min(e.length, t.length);
        for (let o = 0; o < s; o++) {
            const l = ai.compareSegments(e.get(o), t.get(o));
            if (l !== 0)
                return l
        }
        return ke(e.length, t.length)
    }
    static compareSegments(e, t) {
        const s = ai.isNumericId(e)
          , o = ai.isNumericId(t);
        return s && !o ? -1 : !s && o ? 1 : s && o ? ai.extractNumericId(e).compare(ai.extractNumericId(t)) : Vd(e, t)
    }
    static isNumericId(e) {
        return e.startsWith("__id") && e.endsWith("__")
    }
    static extractNumericId(e) {
        return mp.fromString(e.substring(4, e.length - 2))
    }
}
class _t extends ai {
    construct(e, t, s) {
        return new _t(e,t,s)
    }
    canonicalString() {
        return this.toArray().join("/")
    }
    toString() {
        return this.canonicalString()
    }
    toUriEncodedString() {
        return this.toArray().map(encodeURIComponent).join("/")
    }
    static fromString(...e) {
        const t = [];
        for (const s of e) {
            if (s.indexOf("//") >= 0)
                throw new Ee(te.INVALID_ARGUMENT,`Invalid segment (${s}). Paths must not contain // in them.`);
            t.push(...s.split("/").filter(o => o.length > 0))
        }
        return new _t(t)
    }
    static emptyPath() {
        return new _t([])
    }
}
const Mw = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
class zt extends ai {
    construct(e, t, s) {
        return new zt(e,t,s)
    }
    static isValidIdentifier(e) {
        return Mw.test(e)
    }
    canonicalString() {
        return this.toArray().map(e => (e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`"),
        zt.isValidIdentifier(e) || (e = "`" + e + "`"),
        e)).join(".")
    }
    toString() {
        return this.canonicalString()
    }
    isKeyField() {
        return this.length === 1 && this.get(0) === qv
    }
    static keyField() {
        return new zt([qv])
    }
    static fromServerFormat(e) {
        const t = [];
        let s = ""
          , o = 0;
        const l = () => {
            if (s.length === 0)
                throw new Ee(te.INVALID_ARGUMENT,`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
            t.push(s),
            s = ""
        }
        ;
        let f = !1;
        for (; o < e.length; ) {
            const d = e[o];
            if (d === "\\") {
                if (o + 1 === e.length)
                    throw new Ee(te.INVALID_ARGUMENT,"Path has trailing escape character: " + e);
                const v = e[o + 1];
                if (v !== "\\" && v !== "." && v !== "`")
                    throw new Ee(te.INVALID_ARGUMENT,"Path has invalid escape sequence: " + e);
                s += v,
                o += 2
            } else
                d === "`" ? (f = !f,
                o++) : d !== "." || f ? (s += d,
                o++) : (l(),
                o++)
        }
        if (l(),
        f)
            throw new Ee(te.INVALID_ARGUMENT,"Unterminated ` in path: " + e);
        return new zt(t)
    }
    static emptyPath() {
        return new zt([])
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Re {
    constructor(e) {
        this.path = e
    }
    static fromPath(e) {
        return new Re(_t.fromString(e))
    }
    static fromName(e) {
        return new Re(_t.fromString(e).popFirst(5))
    }
    static empty() {
        return new Re(_t.emptyPath())
    }
    get collectionGroup() {
        return this.path.popLast().lastSegment()
    }
    hasCollectionId(e) {
        return this.path.length >= 2 && this.path.get(this.path.length - 2) === e
    }
    getCollectionGroup() {
        return this.path.get(this.path.length - 2)
    }
    getCollectionPath() {
        return this.path.popLast()
    }
    isEqual(e) {
        return e !== null && _t.comparator(this.path, e.path) === 0
    }
    toString() {
        return this.path.toString()
    }
    static comparator(e, t) {
        return _t.comparator(e.path, t.path)
    }
    static isDocumentKey(e) {
        return e.length % 2 == 0
    }
    static fromSegments(e) {
        return new Re(new _t(e.slice()))
    }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const gl = -1;
function Nw(r, e) {
    const t = r.toTimestamp().seconds
      , s = r.toTimestamp().nanoseconds + 1
      , o = it.fromTimestamp(s === 1e9 ? new Pt(t + 1,0) : new Pt(t,s));
    return new Dr(o,Re.empty(),e)
}
function xw(r) {
    return new Dr(r.readTime,r.key,gl)
}
class Dr {
    constructor(e, t, s) {
        this.readTime = e,
        this.documentKey = t,
        this.largestBatchId = s
    }
    static min() {
        return new Dr(it.min(),Re.empty(),gl)
    }
    static max() {
        return new Dr(it.max(),Re.empty(),gl)
    }
}
function Pw(r, e) {
    let t = r.readTime.compareTo(e.readTime);
    return t !== 0 ? t : (t = Re.comparator(r.documentKey, e.documentKey),
    t !== 0 ? t : ke(r.largestBatchId, e.largestBatchId))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ow = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
class Vw {
    constructor() {
        this.onCommittedListeners = []
    }
    addOnCommittedListener(e) {
        this.onCommittedListeners.push(e)
    }
    raiseOnCommittedEvent() {
        this.onCommittedListeners.forEach(e => e())
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function yp(r) {
    if (r.code !== te.FAILED_PRECONDITION || r.message !== Ow)
        throw r;
    he("LocalStore", "Unexpectedly lost primary lease")
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Z {
    constructor(e) {
        this.nextCallback = null,
        this.catchCallback = null,
        this.result = void 0,
        this.error = void 0,
        this.isDone = !1,
        this.callbackAttached = !1,
        e(t => {
            this.isDone = !0,
            this.result = t,
            this.nextCallback && this.nextCallback(t)
        }
        , t => {
            this.isDone = !0,
            this.error = t,
            this.catchCallback && this.catchCallback(t)
        }
        )
    }
    catch(e) {
        return this.next(void 0, e)
    }
    next(e, t) {
        return this.callbackAttached && De(59440),
        this.callbackAttached = !0,
        this.isDone ? this.error ? this.wrapFailure(t, this.error) : this.wrapSuccess(e, this.result) : new Z( (s, o) => {
            this.nextCallback = l => {
                this.wrapSuccess(e, l).next(s, o)
            }
            ,
            this.catchCallback = l => {
                this.wrapFailure(t, l).next(s, o)
            }
        }
        )
    }
    toPromise() {
        return new Promise( (e, t) => {
            this.next(e, t)
        }
        )
    }
    wrapUserFunction(e) {
        try {
            const t = e();
            return t instanceof Z ? t : Z.resolve(t)
        } catch (t) {
            return Z.reject(t)
        }
    }
    wrapSuccess(e, t) {
        return e ? this.wrapUserFunction( () => e(t)) : Z.resolve(t)
    }
    wrapFailure(e, t) {
        return e ? this.wrapUserFunction( () => e(t)) : Z.reject(t)
    }
    static resolve(e) {
        return new Z( (t, s) => {
            t(e)
        }
        )
    }
    static reject(e) {
        return new Z( (t, s) => {
            s(e)
        }
        )
    }
    static waitFor(e) {
        return new Z( (t, s) => {
            let o = 0
              , l = 0
              , f = !1;
            e.forEach(d => {
                ++o,
                d.next( () => {
                    ++l,
                    f && l === o && t()
                }
                , v => s(v))
            }
            ),
            f = !0,
            l === o && t()
        }
        )
    }
    static or(e) {
        let t = Z.resolve(!1);
        for (const s of e)
            t = t.next(o => o ? Z.resolve(o) : s());
        return t
    }
    static forEach(e, t) {
        const s = [];
        return e.forEach( (o, l) => {
            s.push(t.call(this, o, l))
        }
        ),
        this.waitFor(s)
    }
    static mapArray(e, t) {
        return new Z( (s, o) => {
            const l = e.length
              , f = new Array(l);
            let d = 0;
            for (let v = 0; v < l; v++) {
                const y = v;
                t(e[y]).next(T => {
                    f[y] = T,
                    ++d,
                    d === l && s(f)
                }
                , T => o(T))
            }
        }
        )
    }
    static doWhile(e, t) {
        return new Z( (s, o) => {
            const l = () => {
                e() === !0 ? t().next( () => {
                    l()
                }
                , o) : s()
            }
            ;
            l()
        }
        )
    }
}
function Uw(r) {
    const e = r.match(/Android ([\d.]+)/i)
      , t = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(t)
}
function Dl(r) {
    return r.name === "IndexedDbTransactionError"
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vp {
    constructor(e, t) {
        this.previousValue = e,
        t && (t.sequenceNumberHandler = s => this.ue(s),
        this.ce = s => t.writeSequenceNumber(s))
    }
    ue(e) {
        return this.previousValue = Math.max(e, this.previousValue),
        this.previousValue
    }
    next() {
        const e = ++this.previousValue;
        return this.ce && this.ce(e),
        e
    }
}
vp.le = -1;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _p = -1;
function Tp(r) {
    return r == null
}
function xc(r) {
    return r === 0 && 1 / r == -1 / 0
}
function kw(r) {
    return typeof r == "number" && Number.isInteger(r) && !xc(r) && r <= Number.MAX_SAFE_INTEGER && r >= Number.MIN_SAFE_INTEGER
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RE = "";
function Lw(r) {
    let e = "";
    for (let t = 0; t < r.length; t++)
        e.length > 0 && (e = zv(e)),
        e = Bw(r.get(t), e);
    return zv(e)
}
function Bw(r, e) {
    let t = e;
    const s = r.length;
    for (let o = 0; o < s; o++) {
        const l = r.charAt(o);
        switch (l) {
        case "\0":
            t += "";
            break;
        case RE:
            t += "";
            break;
        default:
            t += l
        }
    }
    return t
}
function zv(r) {
    return r + RE + ""
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Fv(r) {
    let e = 0;
    for (const t in r)
        Object.prototype.hasOwnProperty.call(r, t) && e++;
    return e
}
function Ko(r, e) {
    for (const t in r)
        Object.prototype.hasOwnProperty.call(r, t) && e(t, r[t])
}
function IE(r) {
    for (const e in r)
        if (Object.prototype.hasOwnProperty.call(r, e))
            return !1;
    return !0
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class an {
    constructor(e, t) {
        this.comparator = e,
        this.root = t || Bt.EMPTY
    }
    insert(e, t) {
        return new an(this.comparator,this.root.insert(e, t, this.comparator).copy(null, null, Bt.BLACK, null, null))
    }
    remove(e) {
        return new an(this.comparator,this.root.remove(e, this.comparator).copy(null, null, Bt.BLACK, null, null))
    }
    get(e) {
        let t = this.root;
        for (; !t.isEmpty(); ) {
            const s = this.comparator(e, t.key);
            if (s === 0)
                return t.value;
            s < 0 ? t = t.left : s > 0 && (t = t.right)
        }
        return null
    }
    indexOf(e) {
        let t = 0
          , s = this.root;
        for (; !s.isEmpty(); ) {
            const o = this.comparator(e, s.key);
            if (o === 0)
                return t + s.left.size;
            o < 0 ? s = s.left : (t += s.left.size + 1,
            s = s.right)
        }
        return -1
    }
    isEmpty() {
        return this.root.isEmpty()
    }
    get size() {
        return this.root.size
    }
    minKey() {
        return this.root.minKey()
    }
    maxKey() {
        return this.root.maxKey()
    }
    inorderTraversal(e) {
        return this.root.inorderTraversal(e)
    }
    forEach(e) {
        this.inorderTraversal( (t, s) => (e(t, s),
        !1))
    }
    toString() {
        const e = [];
        return this.inorderTraversal( (t, s) => (e.push(`${t}:${s}`),
        !1)),
        `{${e.join(", ")}}`
    }
    reverseTraversal(e) {
        return this.root.reverseTraversal(e)
    }
    getIterator() {
        return new ac(this.root,null,this.comparator,!1)
    }
    getIteratorFrom(e) {
        return new ac(this.root,e,this.comparator,!1)
    }
    getReverseIterator() {
        return new ac(this.root,null,this.comparator,!0)
    }
    getReverseIteratorFrom(e) {
        return new ac(this.root,e,this.comparator,!0)
    }
}
class ac {
    constructor(e, t, s, o) {
        this.isReverse = o,
        this.nodeStack = [];
        let l = 1;
        for (; !e.isEmpty(); )
            if (l = t ? s(e.key, t) : 1,
            t && o && (l *= -1),
            l < 0)
                e = this.isReverse ? e.left : e.right;
            else {
                if (l === 0) {
                    this.nodeStack.push(e);
                    break
                }
                this.nodeStack.push(e),
                e = this.isReverse ? e.right : e.left
            }
    }
    getNext() {
        let e = this.nodeStack.pop();
        const t = {
            key: e.key,
            value: e.value
        };
        if (this.isReverse)
            for (e = e.left; !e.isEmpty(); )
                this.nodeStack.push(e),
                e = e.right;
        else
            for (e = e.right; !e.isEmpty(); )
                this.nodeStack.push(e),
                e = e.left;
        return t
    }
    hasNext() {
        return this.nodeStack.length > 0
    }
    peek() {
        if (this.nodeStack.length === 0)
            return null;
        const e = this.nodeStack[this.nodeStack.length - 1];
        return {
            key: e.key,
            value: e.value
        }
    }
}
class Bt {
    constructor(e, t, s, o, l) {
        this.key = e,
        this.value = t,
        this.color = s ?? Bt.RED,
        this.left = o ?? Bt.EMPTY,
        this.right = l ?? Bt.EMPTY,
        this.size = this.left.size + 1 + this.right.size
    }
    copy(e, t, s, o, l) {
        return new Bt(e ?? this.key,t ?? this.value,s ?? this.color,o ?? this.left,l ?? this.right)
    }
    isEmpty() {
        return !1
    }
    inorderTraversal(e) {
        return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e)
    }
    reverseTraversal(e) {
        return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e)
    }
    min() {
        return this.left.isEmpty() ? this : this.left.min()
    }
    minKey() {
        return this.min().key
    }
    maxKey() {
        return this.right.isEmpty() ? this.key : this.right.maxKey()
    }
    insert(e, t, s) {
        let o = this;
        const l = s(e, o.key);
        return o = l < 0 ? o.copy(null, null, null, o.left.insert(e, t, s), null) : l === 0 ? o.copy(null, t, null, null, null) : o.copy(null, null, null, null, o.right.insert(e, t, s)),
        o.fixUp()
    }
    removeMin() {
        if (this.left.isEmpty())
            return Bt.EMPTY;
        let e = this;
        return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()),
        e = e.copy(null, null, null, e.left.removeMin(), null),
        e.fixUp()
    }
    remove(e, t) {
        let s, o = this;
        if (t(e, o.key) < 0)
            o.left.isEmpty() || o.left.isRed() || o.left.left.isRed() || (o = o.moveRedLeft()),
            o = o.copy(null, null, null, o.left.remove(e, t), null);
        else {
            if (o.left.isRed() && (o = o.rotateRight()),
            o.right.isEmpty() || o.right.isRed() || o.right.left.isRed() || (o = o.moveRedRight()),
            t(e, o.key) === 0) {
                if (o.right.isEmpty())
                    return Bt.EMPTY;
                s = o.right.min(),
                o = o.copy(s.key, s.value, null, null, o.right.removeMin())
            }
            o = o.copy(null, null, null, null, o.right.remove(e, t))
        }
        return o.fixUp()
    }
    isRed() {
        return this.color
    }
    fixUp() {
        let e = this;
        return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()),
        e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()),
        e.left.isRed() && e.right.isRed() && (e = e.colorFlip()),
        e
    }
    moveRedLeft() {
        let e = this.colorFlip();
        return e.right.left.isRed() && (e = e.copy(null, null, null, null, e.right.rotateRight()),
        e = e.rotateLeft(),
        e = e.colorFlip()),
        e
    }
    moveRedRight() {
        let e = this.colorFlip();
        return e.left.left.isRed() && (e = e.rotateRight(),
        e = e.colorFlip()),
        e
    }
    rotateLeft() {
        const e = this.copy(null, null, Bt.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, e, null)
    }
    rotateRight() {
        const e = this.copy(null, null, Bt.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, e)
    }
    colorFlip() {
        const e = this.left.copy(null, null, !this.left.color, null, null)
          , t = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, e, t)
    }
    checkMaxDepth() {
        const e = this.check();
        return Math.pow(2, e) <= this.size + 1
    }
    check() {
        if (this.isRed() && this.left.isRed())
            throw De(43730, {
                key: this.key,
                value: this.value
            });
        if (this.right.isRed())
            throw De(14113, {
                key: this.key,
                value: this.value
            });
        const e = this.left.check();
        if (e !== this.right.check())
            throw De(27949);
        return e + (this.isRed() ? 0 : 1)
    }
}
Bt.EMPTY = null,
Bt.RED = !0,
Bt.BLACK = !1;
Bt.EMPTY = new class {
    constructor() {
        this.size = 0
    }
    get key() {
        throw De(57766)
    }
    get value() {
        throw De(16141)
    }
    get color() {
        throw De(16727)
    }
    get left() {
        throw De(29726)
    }
    get right() {
        throw De(36894)
    }
    copy(e, t, s, o, l) {
        return this
    }
    insert(e, t, s) {
        return new Bt(e,t)
    }
    remove(e, t) {
        return this
    }
    isEmpty() {
        return !0
    }
    inorderTraversal(e) {
        return !1
    }
    reverseTraversal(e) {
        return !1
    }
    minKey() {
        return null
    }
    maxKey() {
        return null
    }
    isRed() {
        return !1
    }
    checkMaxDepth() {
        return !0
    }
    check() {
        return 0
    }
}
;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ft {
    constructor(e) {
        this.comparator = e,
        this.data = new an(this.comparator)
    }
    has(e) {
        return this.data.get(e) !== null
    }
    first() {
        return this.data.minKey()
    }
    last() {
        return this.data.maxKey()
    }
    get size() {
        return this.data.size
    }
    indexOf(e) {
        return this.data.indexOf(e)
    }
    forEach(e) {
        this.data.inorderTraversal( (t, s) => (e(t),
        !1))
    }
    forEachInRange(e, t) {
        const s = this.data.getIteratorFrom(e[0]);
        for (; s.hasNext(); ) {
            const o = s.getNext();
            if (this.comparator(o.key, e[1]) >= 0)
                return;
            t(o.key)
        }
    }
    forEachWhile(e, t) {
        let s;
        for (s = t !== void 0 ? this.data.getIteratorFrom(t) : this.data.getIterator(); s.hasNext(); )
            if (!e(s.getNext().key))
                return
    }
    firstAfterOrEqual(e) {
        const t = this.data.getIteratorFrom(e);
        return t.hasNext() ? t.getNext().key : null
    }
    getIterator() {
        return new Hv(this.data.getIterator())
    }
    getIteratorFrom(e) {
        return new Hv(this.data.getIteratorFrom(e))
    }
    add(e) {
        return this.copy(this.data.remove(e).insert(e, !0))
    }
    delete(e) {
        return this.has(e) ? this.copy(this.data.remove(e)) : this
    }
    isEmpty() {
        return this.data.isEmpty()
    }
    unionWith(e) {
        let t = this;
        return t.size < e.size && (t = e,
        e = this),
        e.forEach(s => {
            t = t.add(s)
        }
        ),
        t
    }
    isEqual(e) {
        if (!(e instanceof Ft) || this.size !== e.size)
            return !1;
        const t = this.data.getIterator()
          , s = e.data.getIterator();
        for (; t.hasNext(); ) {
            const o = t.getNext().key
              , l = s.getNext().key;
            if (this.comparator(o, l) !== 0)
                return !1
        }
        return !0
    }
    toArray() {
        const e = [];
        return this.forEach(t => {
            e.push(t)
        }
        ),
        e
    }
    toString() {
        const e = [];
        return this.forEach(t => e.push(t)),
        "SortedSet(" + e.toString() + ")"
    }
    copy(e) {
        const t = new Ft(this.comparator);
        return t.data = e,
        t
    }
}
class Hv {
    constructor(e) {
        this.iter = e
    }
    getNext() {
        return this.iter.getNext().key
    }
    hasNext() {
        return this.iter.hasNext()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fn {
    constructor(e) {
        this.fields = e,
        e.sort(zt.comparator)
    }
    static empty() {
        return new Fn([])
    }
    unionWith(e) {
        let t = new Ft(zt.comparator);
        for (const s of this.fields)
            t = t.add(s);
        for (const s of e)
            t = t.add(s);
        return new Fn(t.toArray())
    }
    covers(e) {
        for (const t of this.fields)
            if (t.isPrefixOf(e))
                return !0;
        return !1
    }
    isEqual(e) {
        return Lo(this.fields, e.fields, (t, s) => t.isEqual(s))
    }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class qw extends Error {
    constructor() {
        super(...arguments),
        this.name = "Base64DecodeError"
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ui {
    constructor(e) {
        this.binaryString = e
    }
    static fromBase64String(e) {
        const t = function(o) {
            try {
                return atob(o)
            } catch (l) {
                throw typeof DOMException < "u" && l instanceof DOMException ? new qw("Invalid base64 string: " + l) : l
            }
        }(e);
        return new ui(t)
    }
    static fromUint8Array(e) {
        const t = function(o) {
            let l = "";
            for (let f = 0; f < o.length; ++f)
                l += String.fromCharCode(o[f]);
            return l
        }(e);
        return new ui(t)
    }
    [Symbol.iterator]() {
        let e = 0;
        return {
            next: () => e < this.binaryString.length ? {
                value: this.binaryString.charCodeAt(e++),
                done: !1
            } : {
                value: void 0,
                done: !0
            }
        }
    }
    toBase64() {
        return function(t) {
            return btoa(t)
        }(this.binaryString)
    }
    toUint8Array() {
        return function(t) {
            const s = new Uint8Array(t.length);
            for (let o = 0; o < t.length; o++)
                s[o] = t.charCodeAt(o);
            return s
        }(this.binaryString)
    }
    approximateByteSize() {
        return 2 * this.binaryString.length
    }
    compareTo(e) {
        return ke(this.binaryString, e.binaryString)
    }
    isEqual(e) {
        return this.binaryString === e.binaryString
    }
}
ui.EMPTY_BYTE_STRING = new ui("");
const zw = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Ps(r) {
    if (lt(!!r, 39018),
    typeof r == "string") {
        let e = 0;
        const t = zw.exec(r);
        if (lt(!!t, 46558, {
            timestamp: r
        }),
        t[1]) {
            let o = t[1];
            o = (o + "000000000").substr(0, 9),
            e = Number(o)
        }
        const s = new Date(r);
        return {
            seconds: Math.floor(s.getTime() / 1e3),
            nanos: e
        }
    }
    return {
        seconds: qt(r.seconds),
        nanos: qt(r.nanos)
    }
}
function qt(r) {
    return typeof r == "number" ? r : typeof r == "string" ? Number(r) : 0
}
function Bo(r) {
    return typeof r == "string" ? ui.fromBase64String(r) : ui.fromUint8Array(r)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const wE = "server_timestamp"
  , bE = "__type__"
  , DE = "__previous_value__"
  , ME = "__local_write_time__";
function Ep(r) {
    var e, t;
    return ((t = (((e = r == null ? void 0 : r.mapValue) === null || e === void 0 ? void 0 : e.fields) || {})[bE]) === null || t === void 0 ? void 0 : t.stringValue) === wE
}
function Sp(r) {
    const e = r.mapValue.fields[DE];
    return Ep(e) ? Sp(e) : e
}
function Pc(r) {
    const e = Ps(r.mapValue.fields[ME].timestampValue);
    return new Pt(e.seconds,e.nanos)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fw {
    constructor(e, t, s, o, l, f, d, v, y) {
        this.databaseId = e,
        this.appId = t,
        this.persistenceKey = s,
        this.host = o,
        this.ssl = l,
        this.forceLongPolling = f,
        this.autoDetectLongPolling = d,
        this.longPollingOptions = v,
        this.useFetchStreams = y
    }
}
const Oc = "(default)";
class Vc {
    constructor(e, t) {
        this.projectId = e,
        this.database = t || Oc
    }
    static empty() {
        return new Vc("","")
    }
    get isDefaultDatabase() {
        return this.database === Oc
    }
    isEqual(e) {
        return e instanceof Vc && e.projectId === this.projectId && e.database === this.database
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const NE = "__type__"
  , Hw = "__max__"
  , lc = {
    mapValue: {}
}
  , xE = "__vector__"
  , Ud = "value";
function Os(r) {
    return "nullValue"in r ? 0 : "booleanValue"in r ? 1 : "integerValue"in r || "doubleValue"in r ? 2 : "timestampValue"in r ? 3 : "stringValue"in r ? 5 : "bytesValue"in r ? 6 : "referenceValue"in r ? 7 : "geoPointValue"in r ? 8 : "arrayValue"in r ? 9 : "mapValue"in r ? Ep(r) ? 4 : Yw(r) ? 9007199254740991 : Gw(r) ? 10 : 11 : De(28295, {
        value: r
    })
}
function ci(r, e) {
    if (r === e)
        return !0;
    const t = Os(r);
    if (t !== Os(e))
        return !1;
    switch (t) {
    case 0:
    case 9007199254740991:
        return !0;
    case 1:
        return r.booleanValue === e.booleanValue;
    case 4:
        return Pc(r).isEqual(Pc(e));
    case 3:
        return function(o, l) {
            if (typeof o.timestampValue == "string" && typeof l.timestampValue == "string" && o.timestampValue.length === l.timestampValue.length)
                return o.timestampValue === l.timestampValue;
            const f = Ps(o.timestampValue)
              , d = Ps(l.timestampValue);
            return f.seconds === d.seconds && f.nanos === d.nanos
        }(r, e);
    case 5:
        return r.stringValue === e.stringValue;
    case 6:
        return function(o, l) {
            return Bo(o.bytesValue).isEqual(Bo(l.bytesValue))
        }(r, e);
    case 7:
        return r.referenceValue === e.referenceValue;
    case 8:
        return function(o, l) {
            return qt(o.geoPointValue.latitude) === qt(l.geoPointValue.latitude) && qt(o.geoPointValue.longitude) === qt(l.geoPointValue.longitude)
        }(r, e);
    case 2:
        return function(o, l) {
            if ("integerValue"in o && "integerValue"in l)
                return qt(o.integerValue) === qt(l.integerValue);
            if ("doubleValue"in o && "doubleValue"in l) {
                const f = qt(o.doubleValue)
                  , d = qt(l.doubleValue);
                return f === d ? xc(f) === xc(d) : isNaN(f) && isNaN(d)
            }
            return !1
        }(r, e);
    case 9:
        return Lo(r.arrayValue.values || [], e.arrayValue.values || [], ci);
    case 10:
    case 11:
        return function(o, l) {
            const f = o.mapValue.fields || {}
              , d = l.mapValue.fields || {};
            if (Fv(f) !== Fv(d))
                return !1;
            for (const v in f)
                if (f.hasOwnProperty(v) && (d[v] === void 0 || !ci(f[v], d[v])))
                    return !1;
            return !0
        }(r, e);
    default:
        return De(52216, {
            left: r
        })
    }
}
function yl(r, e) {
    return (r.values || []).find(t => ci(t, e)) !== void 0
}
function qo(r, e) {
    if (r === e)
        return 0;
    const t = Os(r)
      , s = Os(e);
    if (t !== s)
        return ke(t, s);
    switch (t) {
    case 0:
    case 9007199254740991:
        return 0;
    case 1:
        return ke(r.booleanValue, e.booleanValue);
    case 2:
        return function(l, f) {
            const d = qt(l.integerValue || l.doubleValue)
              , v = qt(f.integerValue || f.doubleValue);
            return d < v ? -1 : d > v ? 1 : d === v ? 0 : isNaN(d) ? isNaN(v) ? 0 : -1 : 1
        }(r, e);
    case 3:
        return Gv(r.timestampValue, e.timestampValue);
    case 4:
        return Gv(Pc(r), Pc(e));
    case 5:
        return Vd(r.stringValue, e.stringValue);
    case 6:
        return function(l, f) {
            const d = Bo(l)
              , v = Bo(f);
            return d.compareTo(v)
        }(r.bytesValue, e.bytesValue);
    case 7:
        return function(l, f) {
            const d = l.split("/")
              , v = f.split("/");
            for (let y = 0; y < d.length && y < v.length; y++) {
                const T = ke(d[y], v[y]);
                if (T !== 0)
                    return T
            }
            return ke(d.length, v.length)
        }(r.referenceValue, e.referenceValue);
    case 8:
        return function(l, f) {
            const d = ke(qt(l.latitude), qt(f.latitude));
            return d !== 0 ? d : ke(qt(l.longitude), qt(f.longitude))
        }(r.geoPointValue, e.geoPointValue);
    case 9:
        return Yv(r.arrayValue, e.arrayValue);
    case 10:
        return function(l, f) {
            var d, v, y, T;
            const A = l.fields || {}
              , I = f.fields || {}
              , V = (d = A[Ud]) === null || d === void 0 ? void 0 : d.arrayValue
              , q = (v = I[Ud]) === null || v === void 0 ? void 0 : v.arrayValue
              , G = ke(((y = V == null ? void 0 : V.values) === null || y === void 0 ? void 0 : y.length) || 0, ((T = q == null ? void 0 : q.values) === null || T === void 0 ? void 0 : T.length) || 0);
            return G !== 0 ? G : Yv(V, q)
        }(r.mapValue, e.mapValue);
    case 11:
        return function(l, f) {
            if (l === lc.mapValue && f === lc.mapValue)
                return 0;
            if (l === lc.mapValue)
                return 1;
            if (f === lc.mapValue)
                return -1;
            const d = l.fields || {}
              , v = Object.keys(d)
              , y = f.fields || {}
              , T = Object.keys(y);
            v.sort(),
            T.sort();
            for (let A = 0; A < v.length && A < T.length; ++A) {
                const I = Vd(v[A], T[A]);
                if (I !== 0)
                    return I;
                const V = qo(d[v[A]], y[T[A]]);
                if (V !== 0)
                    return V
            }
            return ke(v.length, T.length)
        }(r.mapValue, e.mapValue);
    default:
        throw De(23264, {
            Pe: t
        })
    }
}
function Gv(r, e) {
    if (typeof r == "string" && typeof e == "string" && r.length === e.length)
        return ke(r, e);
    const t = Ps(r)
      , s = Ps(e)
      , o = ke(t.seconds, s.seconds);
    return o !== 0 ? o : ke(t.nanos, s.nanos)
}
function Yv(r, e) {
    const t = r.values || []
      , s = e.values || [];
    for (let o = 0; o < t.length && o < s.length; ++o) {
        const l = qo(t[o], s[o]);
        if (l)
            return l
    }
    return ke(t.length, s.length)
}
function zo(r) {
    return kd(r)
}
function kd(r) {
    return "nullValue"in r ? "null" : "booleanValue"in r ? "" + r.booleanValue : "integerValue"in r ? "" + r.integerValue : "doubleValue"in r ? "" + r.doubleValue : "timestampValue"in r ? function(t) {
        const s = Ps(t);
        return `time(${s.seconds},${s.nanos})`
    }(r.timestampValue) : "stringValue"in r ? r.stringValue : "bytesValue"in r ? function(t) {
        return Bo(t).toBase64()
    }(r.bytesValue) : "referenceValue"in r ? function(t) {
        return Re.fromName(t).toString()
    }(r.referenceValue) : "geoPointValue"in r ? function(t) {
        return `geo(${t.latitude},${t.longitude})`
    }(r.geoPointValue) : "arrayValue"in r ? function(t) {
        let s = "["
          , o = !0;
        for (const l of t.values || [])
            o ? o = !1 : s += ",",
            s += kd(l);
        return s + "]"
    }(r.arrayValue) : "mapValue"in r ? function(t) {
        const s = Object.keys(t.fields || {}).sort();
        let o = "{"
          , l = !0;
        for (const f of s)
            l ? l = !1 : o += ",",
            o += `${f}:${kd(t.fields[f])}`;
        return o + "}"
    }(r.mapValue) : De(61005, {
        value: r
    })
}
function _c(r) {
    switch (Os(r)) {
    case 0:
    case 1:
        return 4;
    case 2:
        return 8;
    case 3:
    case 8:
        return 16;
    case 4:
        const e = Sp(r);
        return e ? 16 + _c(e) : 16;
    case 5:
        return 2 * r.stringValue.length;
    case 6:
        return Bo(r.bytesValue).approximateByteSize();
    case 7:
        return r.referenceValue.length;
    case 9:
        return function(s) {
            return (s.values || []).reduce( (o, l) => o + _c(l), 0)
        }(r.arrayValue);
    case 10:
    case 11:
        return function(s) {
            let o = 0;
            return Ko(s.fields, (l, f) => {
                o += l.length + _c(f)
            }
            ),
            o
        }(r.mapValue);
    default:
        throw De(13486, {
            value: r
        })
    }
}
function Ld(r) {
    return !!r && "integerValue"in r
}
function Ap(r) {
    return !!r && "arrayValue"in r
}
function Tc(r) {
    return !!r && "mapValue"in r
}
function Gw(r) {
    var e, t;
    return ((t = (((e = r == null ? void 0 : r.mapValue) === null || e === void 0 ? void 0 : e.fields) || {})[NE]) === null || t === void 0 ? void 0 : t.stringValue) === xE
}
function ul(r) {
    if (r.geoPointValue)
        return {
            geoPointValue: Object.assign({}, r.geoPointValue)
        };
    if (r.timestampValue && typeof r.timestampValue == "object")
        return {
            timestampValue: Object.assign({}, r.timestampValue)
        };
    if (r.mapValue) {
        const e = {
            mapValue: {
                fields: {}
            }
        };
        return Ko(r.mapValue.fields, (t, s) => e.mapValue.fields[t] = ul(s)),
        e
    }
    if (r.arrayValue) {
        const e = {
            arrayValue: {
                values: []
            }
        };
        for (let t = 0; t < (r.arrayValue.values || []).length; ++t)
            e.arrayValue.values[t] = ul(r.arrayValue.values[t]);
        return e
    }
    return Object.assign({}, r)
}
function Yw(r) {
    return (((r.mapValue || {}).fields || {}).__type__ || {}).stringValue === Hw
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class qn {
    constructor(e) {
        this.value = e
    }
    static empty() {
        return new qn({
            mapValue: {}
        })
    }
    field(e) {
        if (e.isEmpty())
            return this.value;
        {
            let t = this.value;
            for (let s = 0; s < e.length - 1; ++s)
                if (t = (t.mapValue.fields || {})[e.get(s)],
                !Tc(t))
                    return null;
            return t = (t.mapValue.fields || {})[e.lastSegment()],
            t || null
        }
    }
    set(e, t) {
        this.getFieldsMap(e.popLast())[e.lastSegment()] = ul(t)
    }
    setAll(e) {
        let t = zt.emptyPath()
          , s = {}
          , o = [];
        e.forEach( (f, d) => {
            if (!t.isImmediateParentOf(d)) {
                const v = this.getFieldsMap(t);
                this.applyChanges(v, s, o),
                s = {},
                o = [],
                t = d.popLast()
            }
            f ? s[d.lastSegment()] = ul(f) : o.push(d.lastSegment())
        }
        );
        const l = this.getFieldsMap(t);
        this.applyChanges(l, s, o)
    }
    delete(e) {
        const t = this.field(e.popLast());
        Tc(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()]
    }
    isEqual(e) {
        return ci(this.value, e.value)
    }
    getFieldsMap(e) {
        let t = this.value;
        t.mapValue.fields || (t.mapValue = {
            fields: {}
        });
        for (let s = 0; s < e.length; ++s) {
            let o = t.mapValue.fields[e.get(s)];
            Tc(o) && o.mapValue.fields || (o = {
                mapValue: {
                    fields: {}
                }
            },
            t.mapValue.fields[e.get(s)] = o),
            t = o
        }
        return t.mapValue.fields
    }
    applyChanges(e, t, s) {
        Ko(t, (o, l) => e[o] = l);
        for (const o of s)
            delete e[o]
    }
    clone() {
        return new qn(ul(this.value))
    }
}
function PE(r) {
    const e = [];
    return Ko(r.fields, (t, s) => {
        const o = new zt([t]);
        if (Tc(s)) {
            const l = PE(s.mapValue).fields;
            if (l.length === 0)
                e.push(o);
            else
                for (const f of l)
                    e.push(o.child(f))
        } else
            e.push(o)
    }
    ),
    new Fn(e)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bn {
    constructor(e, t, s, o, l, f, d) {
        this.key = e,
        this.documentType = t,
        this.version = s,
        this.readTime = o,
        this.createTime = l,
        this.data = f,
        this.documentState = d
    }
    static newInvalidDocument(e) {
        return new Bn(e,0,it.min(),it.min(),it.min(),qn.empty(),0)
    }
    static newFoundDocument(e, t, s, o) {
        return new Bn(e,1,t,it.min(),s,o,0)
    }
    static newNoDocument(e, t) {
        return new Bn(e,2,t,it.min(),it.min(),qn.empty(),0)
    }
    static newUnknownDocument(e, t) {
        return new Bn(e,3,t,it.min(),it.min(),qn.empty(),2)
    }
    convertToFoundDocument(e, t) {
        return !this.createTime.isEqual(it.min()) || this.documentType !== 2 && this.documentType !== 0 || (this.createTime = e),
        this.version = e,
        this.documentType = 1,
        this.data = t,
        this.documentState = 0,
        this
    }
    convertToNoDocument(e) {
        return this.version = e,
        this.documentType = 2,
        this.data = qn.empty(),
        this.documentState = 0,
        this
    }
    convertToUnknownDocument(e) {
        return this.version = e,
        this.documentType = 3,
        this.data = qn.empty(),
        this.documentState = 2,
        this
    }
    setHasCommittedMutations() {
        return this.documentState = 2,
        this
    }
    setHasLocalMutations() {
        return this.documentState = 1,
        this.version = it.min(),
        this
    }
    setReadTime(e) {
        return this.readTime = e,
        this
    }
    get hasLocalMutations() {
        return this.documentState === 1
    }
    get hasCommittedMutations() {
        return this.documentState === 2
    }
    get hasPendingWrites() {
        return this.hasLocalMutations || this.hasCommittedMutations
    }
    isValidDocument() {
        return this.documentType !== 0
    }
    isFoundDocument() {
        return this.documentType === 1
    }
    isNoDocument() {
        return this.documentType === 2
    }
    isUnknownDocument() {
        return this.documentType === 3
    }
    isEqual(e) {
        return e instanceof Bn && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data)
    }
    mutableCopy() {
        return new Bn(this.key,this.documentType,this.version,this.readTime,this.createTime,this.data.clone(),this.documentState)
    }
    toString() {
        return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`
    }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Uc {
    constructor(e, t) {
        this.position = e,
        this.inclusive = t
    }
}
function Kv(r, e, t) {
    let s = 0;
    for (let o = 0; o < r.position.length; o++) {
        const l = e[o]
          , f = r.position[o];
        if (l.field.isKeyField() ? s = Re.comparator(Re.fromName(f.referenceValue), t.key) : s = qo(f, t.data.field(l.field)),
        l.dir === "desc" && (s *= -1),
        s !== 0)
            break
    }
    return s
}
function Qv(r, e) {
    if (r === null)
        return e === null;
    if (e === null || r.inclusive !== e.inclusive || r.position.length !== e.position.length)
        return !1;
    for (let t = 0; t < r.position.length; t++)
        if (!ci(r.position[t], e.position[t]))
            return !1;
    return !0
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class kc {
    constructor(e, t="asc") {
        this.field = e,
        this.dir = t
    }
}
function Kw(r, e) {
    return r.dir === e.dir && r.field.isEqual(e.field)
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class OE {
}
class xt extends OE {
    constructor(e, t, s) {
        super(),
        this.field = e,
        this.op = t,
        this.value = s
    }
    static create(e, t, s) {
        return e.isKeyField() ? t === "in" || t === "not-in" ? this.createKeyFieldInFilter(e, t, s) : new Xw(e,t,s) : t === "array-contains" ? new jw(e,s) : t === "in" ? new Ww(e,s) : t === "not-in" ? new Zw(e,s) : t === "array-contains-any" ? new eb(e,s) : new xt(e,t,s)
    }
    static createKeyFieldInFilter(e, t, s) {
        return t === "in" ? new $w(e,s) : new Jw(e,s)
    }
    matches(e) {
        const t = e.data.field(this.field);
        return this.op === "!=" ? t !== null && t.nullValue === void 0 && this.matchesComparison(qo(t, this.value)) : t !== null && Os(this.value) === Os(t) && this.matchesComparison(qo(t, this.value))
    }
    matchesComparison(e) {
        switch (this.op) {
        case "<":
            return e < 0;
        case "<=":
            return e <= 0;
        case "==":
            return e === 0;
        case "!=":
            return e !== 0;
        case ">":
            return e > 0;
        case ">=":
            return e >= 0;
        default:
            return De(47266, {
                operator: this.op
            })
        }
    }
    isInequality() {
        return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0
    }
    getFlattenedFilters() {
        return [this]
    }
    getFilters() {
        return [this]
    }
}
class Mr extends OE {
    constructor(e, t) {
        super(),
        this.filters = e,
        this.op = t,
        this.Te = null
    }
    static create(e, t) {
        return new Mr(e,t)
    }
    matches(e) {
        return VE(this) ? this.filters.find(t => !t.matches(e)) === void 0 : this.filters.find(t => t.matches(e)) !== void 0
    }
    getFlattenedFilters() {
        return this.Te !== null || (this.Te = this.filters.reduce( (e, t) => e.concat(t.getFlattenedFilters()), [])),
        this.Te
    }
    getFilters() {
        return Object.assign([], this.filters)
    }
}
function VE(r) {
    return r.op === "and"
}
function UE(r) {
    return Qw(r) && VE(r)
}
function Qw(r) {
    for (const e of r.filters)
        if (e instanceof Mr)
            return !1;
    return !0
}
function Bd(r) {
    if (r instanceof xt)
        return r.field.canonicalString() + r.op.toString() + zo(r.value);
    if (UE(r))
        return r.filters.map(e => Bd(e)).join(",");
    {
        const e = r.filters.map(t => Bd(t)).join(",");
        return `${r.op}(${e})`
    }
}
function kE(r, e) {
    return r instanceof xt ? function(s, o) {
        return o instanceof xt && s.op === o.op && s.field.isEqual(o.field) && ci(s.value, o.value)
    }(r, e) : r instanceof Mr ? function(s, o) {
        return o instanceof Mr && s.op === o.op && s.filters.length === o.filters.length ? s.filters.reduce( (l, f, d) => l && kE(f, o.filters[d]), !0) : !1
    }(r, e) : void De(19439)
}
function LE(r) {
    return r instanceof xt ? function(t) {
        return `${t.field.canonicalString()} ${t.op} ${zo(t.value)}`
    }(r) : r instanceof Mr ? function(t) {
        return t.op.toString() + " {" + t.getFilters().map(LE).join(" ,") + "}"
    }(r) : "Filter"
}
class Xw extends xt {
    constructor(e, t, s) {
        super(e, t, s),
        this.key = Re.fromName(s.referenceValue)
    }
    matches(e) {
        const t = Re.comparator(e.key, this.key);
        return this.matchesComparison(t)
    }
}
class $w extends xt {
    constructor(e, t) {
        super(e, "in", t),
        this.keys = BE("in", t)
    }
    matches(e) {
        return this.keys.some(t => t.isEqual(e.key))
    }
}
class Jw extends xt {
    constructor(e, t) {
        super(e, "not-in", t),
        this.keys = BE("not-in", t)
    }
    matches(e) {
        return !this.keys.some(t => t.isEqual(e.key))
    }
}
function BE(r, e) {
    var t;
    return (((t = e.arrayValue) === null || t === void 0 ? void 0 : t.values) || []).map(s => Re.fromName(s.referenceValue))
}
class jw extends xt {
    constructor(e, t) {
        super(e, "array-contains", t)
    }
    matches(e) {
        const t = e.data.field(this.field);
        return Ap(t) && yl(t.arrayValue, this.value)
    }
}
class Ww extends xt {
    constructor(e, t) {
        super(e, "in", t)
    }
    matches(e) {
        const t = e.data.field(this.field);
        return t !== null && yl(this.value.arrayValue, t)
    }
}
class Zw extends xt {
    constructor(e, t) {
        super(e, "not-in", t)
    }
    matches(e) {
        if (yl(this.value.arrayValue, {
            nullValue: "NULL_VALUE"
        }))
            return !1;
        const t = e.data.field(this.field);
        return t !== null && t.nullValue === void 0 && !yl(this.value.arrayValue, t)
    }
}
class eb extends xt {
    constructor(e, t) {
        super(e, "array-contains-any", t)
    }
    matches(e) {
        const t = e.data.field(this.field);
        return !(!Ap(t) || !t.arrayValue.values) && t.arrayValue.values.some(s => yl(this.value.arrayValue, s))
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class tb {
    constructor(e, t=null, s=[], o=[], l=null, f=null, d=null) {
        this.path = e,
        this.collectionGroup = t,
        this.orderBy = s,
        this.filters = o,
        this.limit = l,
        this.startAt = f,
        this.endAt = d,
        this.Ie = null
    }
}
function Xv(r, e=null, t=[], s=[], o=null, l=null, f=null) {
    return new tb(r,e,t,s,o,l,f)
}
function Cp(r) {
    const e = et(r);
    if (e.Ie === null) {
        let t = e.path.canonicalString();
        e.collectionGroup !== null && (t += "|cg:" + e.collectionGroup),
        t += "|f:",
        t += e.filters.map(s => Bd(s)).join(","),
        t += "|ob:",
        t += e.orderBy.map(s => function(l) {
            return l.field.canonicalString() + l.dir
        }(s)).join(","),
        Tp(e.limit) || (t += "|l:",
        t += e.limit),
        e.startAt && (t += "|lb:",
        t += e.startAt.inclusive ? "b:" : "a:",
        t += e.startAt.position.map(s => zo(s)).join(",")),
        e.endAt && (t += "|ub:",
        t += e.endAt.inclusive ? "a:" : "b:",
        t += e.endAt.position.map(s => zo(s)).join(",")),
        e.Ie = t
    }
    return e.Ie
}
function Rp(r, e) {
    if (r.limit !== e.limit || r.orderBy.length !== e.orderBy.length)
        return !1;
    for (let t = 0; t < r.orderBy.length; t++)
        if (!Kw(r.orderBy[t], e.orderBy[t]))
            return !1;
    if (r.filters.length !== e.filters.length)
        return !1;
    for (let t = 0; t < r.filters.length; t++)
        if (!kE(r.filters[t], e.filters[t]))
            return !1;
    return r.collectionGroup === e.collectionGroup && !!r.path.isEqual(e.path) && !!Qv(r.startAt, e.startAt) && Qv(r.endAt, e.endAt)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Wc {
    constructor(e, t=null, s=[], o=[], l=null, f="F", d=null, v=null) {
        this.path = e,
        this.collectionGroup = t,
        this.explicitOrderBy = s,
        this.filters = o,
        this.limit = l,
        this.limitType = f,
        this.startAt = d,
        this.endAt = v,
        this.Ee = null,
        this.de = null,
        this.Ae = null,
        this.startAt,
        this.endAt
    }
}
function nb(r, e, t, s, o, l, f, d) {
    return new Wc(r,e,t,s,o,l,f,d)
}
function ib(r) {
    return new Wc(r)
}
function $v(r) {
    return r.filters.length === 0 && r.limit === null && r.startAt == null && r.endAt == null && (r.explicitOrderBy.length === 0 || r.explicitOrderBy.length === 1 && r.explicitOrderBy[0].field.isKeyField())
}
function rb(r) {
    return r.collectionGroup !== null
}
function cl(r) {
    const e = et(r);
    if (e.Ee === null) {
        e.Ee = [];
        const t = new Set;
        for (const l of e.explicitOrderBy)
            e.Ee.push(l),
            t.add(l.field.canonicalString());
        const s = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        (function(f) {
            let d = new Ft(zt.comparator);
            return f.filters.forEach(v => {
                v.getFlattenedFilters().forEach(y => {
                    y.isInequality() && (d = d.add(y.field))
                }
                )
            }
            ),
            d
        }
        )(e).forEach(l => {
            t.has(l.canonicalString()) || l.isKeyField() || e.Ee.push(new kc(l,s))
        }
        ),
        t.has(zt.keyField().canonicalString()) || e.Ee.push(new kc(zt.keyField(),s))
    }
    return e.Ee
}
function Is(r) {
    const e = et(r);
    return e.de || (e.de = sb(e, cl(r))),
    e.de
}
function sb(r, e) {
    if (r.limitType === "F")
        return Xv(r.path, r.collectionGroup, e, r.filters, r.limit, r.startAt, r.endAt);
    {
        e = e.map(o => {
            const l = o.dir === "desc" ? "asc" : "desc";
            return new kc(o.field,l)
        }
        );
        const t = r.endAt ? new Uc(r.endAt.position,r.endAt.inclusive) : null
          , s = r.startAt ? new Uc(r.startAt.position,r.startAt.inclusive) : null;
        return Xv(r.path, r.collectionGroup, e, r.filters, r.limit, t, s)
    }
}
function qd(r, e, t) {
    return new Wc(r.path,r.collectionGroup,r.explicitOrderBy.slice(),r.filters.slice(),e,t,r.startAt,r.endAt)
}
function qE(r, e) {
    return Rp(Is(r), Is(e)) && r.limitType === e.limitType
}
function zE(r) {
    return `${Cp(Is(r))}|lt:${r.limitType}`
}
function rl(r) {
    return `Query(target=${function(t) {
        let s = t.path.canonicalString();
        return t.collectionGroup !== null && (s += " collectionGroup=" + t.collectionGroup),
        t.filters.length > 0 && (s += `, filters: [${t.filters.map(o => LE(o)).join(", ")}]`),
        Tp(t.limit) || (s += ", limit: " + t.limit),
        t.orderBy.length > 0 && (s += `, orderBy: [${t.orderBy.map(o => function(f) {
            return `${f.field.canonicalString()} (${f.dir})`
        }(o)).join(", ")}]`),
        t.startAt && (s += ", startAt: ",
        s += t.startAt.inclusive ? "b:" : "a:",
        s += t.startAt.position.map(o => zo(o)).join(",")),
        t.endAt && (s += ", endAt: ",
        s += t.endAt.inclusive ? "a:" : "b:",
        s += t.endAt.position.map(o => zo(o)).join(",")),
        `Target(${s})`
    }(Is(r))}; limitType=${r.limitType})`
}
function Ip(r, e) {
    return e.isFoundDocument() && function(s, o) {
        const l = o.key.path;
        return s.collectionGroup !== null ? o.key.hasCollectionId(s.collectionGroup) && s.path.isPrefixOf(l) : Re.isDocumentKey(s.path) ? s.path.isEqual(l) : s.path.isImmediateParentOf(l)
    }(r, e) && function(s, o) {
        for (const l of cl(s))
            if (!l.field.isKeyField() && o.data.field(l.field) === null)
                return !1;
        return !0
    }(r, e) && function(s, o) {
        for (const l of s.filters)
            if (!l.matches(o))
                return !1;
        return !0
    }(r, e) && function(s, o) {
        return !(s.startAt && !function(f, d, v) {
            const y = Kv(f, d, v);
            return f.inclusive ? y <= 0 : y < 0
        }(s.startAt, cl(s), o) || s.endAt && !function(f, d, v) {
            const y = Kv(f, d, v);
            return f.inclusive ? y >= 0 : y > 0
        }(s.endAt, cl(s), o))
    }(r, e)
}
function ob(r) {
    return (e, t) => {
        let s = !1;
        for (const o of cl(r)) {
            const l = ab(o, e, t);
            if (l !== 0)
                return l;
            s = s || o.field.isKeyField()
        }
        return 0
    }
}
function ab(r, e, t) {
    const s = r.field.isKeyField() ? Re.comparator(e.key, t.key) : function(l, f, d) {
        const v = f.data.field(l)
          , y = d.data.field(l);
        return v !== null && y !== null ? qo(v, y) : De(42886)
    }(r.field, e, t);
    switch (r.dir) {
    case "asc":
        return s;
    case "desc":
        return -1 * s;
    default:
        return De(19790, {
            direction: r.dir
        })
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Vs {
    constructor(e, t) {
        this.mapKeyFn = e,
        this.equalsFn = t,
        this.inner = {},
        this.innerSize = 0
    }
    get(e) {
        const t = this.mapKeyFn(e)
          , s = this.inner[t];
        if (s !== void 0) {
            for (const [o,l] of s)
                if (this.equalsFn(o, e))
                    return l
        }
    }
    has(e) {
        return this.get(e) !== void 0
    }
    set(e, t) {
        const s = this.mapKeyFn(e)
          , o = this.inner[s];
        if (o === void 0)
            return this.inner[s] = [[e, t]],
            void this.innerSize++;
        for (let l = 0; l < o.length; l++)
            if (this.equalsFn(o[l][0], e))
                return void (o[l] = [e, t]);
        o.push([e, t]),
        this.innerSize++
    }
    delete(e) {
        const t = this.mapKeyFn(e)
          , s = this.inner[t];
        if (s === void 0)
            return !1;
        for (let o = 0; o < s.length; o++)
            if (this.equalsFn(s[o][0], e))
                return s.length === 1 ? delete this.inner[t] : s.splice(o, 1),
                this.innerSize--,
                !0;
        return !1
    }
    forEach(e) {
        Ko(this.inner, (t, s) => {
            for (const [o,l] of s)
                e(o, l)
        }
        )
    }
    isEmpty() {
        return IE(this.inner)
    }
    size() {
        return this.innerSize
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const lb = new an(Re.comparator);
function Lc() {
    return lb
}
const FE = new an(Re.comparator);
function uc(...r) {
    let e = FE;
    for (const t of r)
        e = e.insert(t.key, t);
    return e
}
function HE(r) {
    let e = FE;
    return r.forEach( (t, s) => e = e.insert(t, s.overlayedDocument)),
    e
}
function Cs() {
    return fl()
}
function GE() {
    return fl()
}
function fl() {
    return new Vs(r => r.toString(), (r, e) => r.isEqual(e))
}
const ub = new an(Re.comparator)
  , cb = new Ft(Re.comparator);
function $t(...r) {
    let e = cb;
    for (const t of r)
        e = e.add(t);
    return e
}
const fb = new Ft(ke);
function hb() {
    return fb
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function wp(r, e) {
    if (r.useProto3Json) {
        if (isNaN(e))
            return {
                doubleValue: "NaN"
            };
        if (e === 1 / 0)
            return {
                doubleValue: "Infinity"
            };
        if (e === -1 / 0)
            return {
                doubleValue: "-Infinity"
            }
    }
    return {
        doubleValue: xc(e) ? "-0" : e
    }
}
function YE(r) {
    return {
        integerValue: "" + r
    }
}
function db(r, e) {
    return kw(e) ? YE(e) : wp(r, e)
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Zc {
    constructor() {
        this._ = void 0
    }
}
function pb(r, e, t) {
    return r instanceof Bc ? function(o, l) {
        const f = {
            fields: {
                [bE]: {
                    stringValue: wE
                },
                [ME]: {
                    timestampValue: {
                        seconds: o.seconds,
                        nanos: o.nanoseconds
                    }
                }
            }
        };
        return l && Ep(l) && (l = Sp(l)),
        l && (f.fields[DE] = l),
        {
            mapValue: f
        }
    }(t, e) : r instanceof vl ? QE(r, e) : r instanceof _l ? XE(r, e) : function(o, l) {
        const f = KE(o, l)
          , d = Jv(f) + Jv(o.Re);
        return Ld(f) && Ld(o.Re) ? YE(d) : wp(o.serializer, d)
    }(r, e)
}
function mb(r, e, t) {
    return r instanceof vl ? QE(r, e) : r instanceof _l ? XE(r, e) : t
}
function KE(r, e) {
    return r instanceof qc ? function(s) {
        return Ld(s) || function(l) {
            return !!l && "doubleValue"in l
        }(s)
    }(e) ? e : {
        integerValue: 0
    } : null
}
class Bc extends Zc {
}
class vl extends Zc {
    constructor(e) {
        super(),
        this.elements = e
    }
}
function QE(r, e) {
    const t = $E(e);
    for (const s of r.elements)
        t.some(o => ci(o, s)) || t.push(s);
    return {
        arrayValue: {
            values: t
        }
    }
}
class _l extends Zc {
    constructor(e) {
        super(),
        this.elements = e
    }
}
function XE(r, e) {
    let t = $E(e);
    for (const s of r.elements)
        t = t.filter(o => !ci(o, s));
    return {
        arrayValue: {
            values: t
        }
    }
}
class qc extends Zc {
    constructor(e, t) {
        super(),
        this.serializer = e,
        this.Re = t
    }
}
function Jv(r) {
    return qt(r.integerValue || r.doubleValue)
}
function $E(r) {
    return Ap(r) && r.arrayValue.values ? r.arrayValue.values.slice() : []
}
function gb(r, e) {
    return r.field.isEqual(e.field) && function(s, o) {
        return s instanceof vl && o instanceof vl || s instanceof _l && o instanceof _l ? Lo(s.elements, o.elements, ci) : s instanceof qc && o instanceof qc ? ci(s.Re, o.Re) : s instanceof Bc && o instanceof Bc
    }(r.transform, e.transform)
}
class yb {
    constructor(e, t) {
        this.version = e,
        this.transformResults = t
    }
}
class zi {
    constructor(e, t) {
        this.updateTime = e,
        this.exists = t
    }
    static none() {
        return new zi
    }
    static exists(e) {
        return new zi(void 0,e)
    }
    static updateTime(e) {
        return new zi(e)
    }
    get isNone() {
        return this.updateTime === void 0 && this.exists === void 0
    }
    isEqual(e) {
        return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime)
    }
}
function Ec(r, e) {
    return r.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(r.updateTime) : r.exists === void 0 || r.exists === e.isFoundDocument()
}
class ef {
}
function JE(r, e) {
    if (!r.hasLocalMutations || e && e.fields.length === 0)
        return null;
    if (e === null)
        return r.isNoDocument() ? new WE(r.key,zi.none()) : new Ml(r.key,r.data,zi.none());
    {
        const t = r.data
          , s = qn.empty();
        let o = new Ft(zt.comparator);
        for (let l of e.fields)
            if (!o.has(l)) {
                let f = t.field(l);
                f === null && l.length > 1 && (l = l.popLast(),
                f = t.field(l)),
                f === null ? s.delete(l) : s.set(l, f),
                o = o.add(l)
            }
        return new Us(r.key,s,new Fn(o.toArray()),zi.none())
    }
}
function vb(r, e, t) {
    r instanceof Ml ? function(o, l, f) {
        const d = o.value.clone()
          , v = Wv(o.fieldTransforms, l, f.transformResults);
        d.setAll(v),
        l.convertToFoundDocument(f.version, d).setHasCommittedMutations()
    }(r, e, t) : r instanceof Us ? function(o, l, f) {
        if (!Ec(o.precondition, l))
            return void l.convertToUnknownDocument(f.version);
        const d = Wv(o.fieldTransforms, l, f.transformResults)
          , v = l.data;
        v.setAll(jE(o)),
        v.setAll(d),
        l.convertToFoundDocument(f.version, v).setHasCommittedMutations()
    }(r, e, t) : function(o, l, f) {
        l.convertToNoDocument(f.version).setHasCommittedMutations()
    }(0, e, t)
}
function hl(r, e, t, s) {
    return r instanceof Ml ? function(l, f, d, v) {
        if (!Ec(l.precondition, f))
            return d;
        const y = l.value.clone()
          , T = Zv(l.fieldTransforms, v, f);
        return y.setAll(T),
        f.convertToFoundDocument(f.version, y).setHasLocalMutations(),
        null
    }(r, e, t, s) : r instanceof Us ? function(l, f, d, v) {
        if (!Ec(l.precondition, f))
            return d;
        const y = Zv(l.fieldTransforms, v, f)
          , T = f.data;
        return T.setAll(jE(l)),
        T.setAll(y),
        f.convertToFoundDocument(f.version, T).setHasLocalMutations(),
        d === null ? null : d.unionWith(l.fieldMask.fields).unionWith(l.fieldTransforms.map(A => A.field))
    }(r, e, t, s) : function(l, f, d) {
        return Ec(l.precondition, f) ? (f.convertToNoDocument(f.version).setHasLocalMutations(),
        null) : d
    }(r, e, t)
}
function _b(r, e) {
    let t = null;
    for (const s of r.fieldTransforms) {
        const o = e.data.field(s.field)
          , l = KE(s.transform, o || null);
        l != null && (t === null && (t = qn.empty()),
        t.set(s.field, l))
    }
    return t || null
}
function jv(r, e) {
    return r.type === e.type && !!r.key.isEqual(e.key) && !!r.precondition.isEqual(e.precondition) && !!function(s, o) {
        return s === void 0 && o === void 0 || !(!s || !o) && Lo(s, o, (l, f) => gb(l, f))
    }(r.fieldTransforms, e.fieldTransforms) && (r.type === 0 ? r.value.isEqual(e.value) : r.type !== 1 || r.data.isEqual(e.data) && r.fieldMask.isEqual(e.fieldMask))
}
class Ml extends ef {
    constructor(e, t, s, o=[]) {
        super(),
        this.key = e,
        this.value = t,
        this.precondition = s,
        this.fieldTransforms = o,
        this.type = 0
    }
    getFieldMask() {
        return null
    }
}
class Us extends ef {
    constructor(e, t, s, o, l=[]) {
        super(),
        this.key = e,
        this.data = t,
        this.fieldMask = s,
        this.precondition = o,
        this.fieldTransforms = l,
        this.type = 1
    }
    getFieldMask() {
        return this.fieldMask
    }
}
function jE(r) {
    const e = new Map;
    return r.fieldMask.fields.forEach(t => {
        if (!t.isEmpty()) {
            const s = r.data.field(t);
            e.set(t, s)
        }
    }
    ),
    e
}
function Wv(r, e, t) {
    const s = new Map;
    lt(r.length === t.length, 32656, {
        Ve: t.length,
        me: r.length
    });
    for (let o = 0; o < t.length; o++) {
        const l = r[o]
          , f = l.transform
          , d = e.data.field(l.field);
        s.set(l.field, mb(f, d, t[o]))
    }
    return s
}
function Zv(r, e, t) {
    const s = new Map;
    for (const o of r) {
        const l = o.transform
          , f = t.data.field(o.field);
        s.set(o.field, pb(l, f, e))
    }
    return s
}
class WE extends ef {
    constructor(e, t) {
        super(),
        this.key = e,
        this.precondition = t,
        this.type = 2,
        this.fieldTransforms = []
    }
    getFieldMask() {
        return null
    }
}
class Tb extends ef {
    constructor(e, t) {
        super(),
        this.key = e,
        this.precondition = t,
        this.type = 3,
        this.fieldTransforms = []
    }
    getFieldMask() {
        return null
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Eb {
    constructor(e, t, s, o) {
        this.batchId = e,
        this.localWriteTime = t,
        this.baseMutations = s,
        this.mutations = o
    }
    applyToRemoteDocument(e, t) {
        const s = t.mutationResults;
        for (let o = 0; o < this.mutations.length; o++) {
            const l = this.mutations[o];
            l.key.isEqual(e.key) && vb(l, e, s[o])
        }
    }
    applyToLocalView(e, t) {
        for (const s of this.baseMutations)
            s.key.isEqual(e.key) && (t = hl(s, e, t, this.localWriteTime));
        for (const s of this.mutations)
            s.key.isEqual(e.key) && (t = hl(s, e, t, this.localWriteTime));
        return t
    }
    applyToLocalDocumentSet(e, t) {
        const s = GE();
        return this.mutations.forEach(o => {
            const l = e.get(o.key)
              , f = l.overlayedDocument;
            let d = this.applyToLocalView(f, l.mutatedFields);
            d = t.has(o.key) ? null : d;
            const v = JE(f, d);
            v !== null && s.set(o.key, v),
            f.isValidDocument() || f.convertToNoDocument(it.min())
        }
        ),
        s
    }
    keys() {
        return this.mutations.reduce( (e, t) => e.add(t.key), $t())
    }
    isEqual(e) {
        return this.batchId === e.batchId && Lo(this.mutations, e.mutations, (t, s) => jv(t, s)) && Lo(this.baseMutations, e.baseMutations, (t, s) => jv(t, s))
    }
}
class bp {
    constructor(e, t, s, o) {
        this.batch = e,
        this.commitVersion = t,
        this.mutationResults = s,
        this.docVersions = o
    }
    static from(e, t, s) {
        lt(e.mutations.length === s.length, 58842, {
            fe: e.mutations.length,
            ge: s.length
        });
        let o = function() {
            return ub
        }();
        const l = e.mutations;
        for (let f = 0; f < l.length; f++)
            o = o.insert(l[f].key, s[f].version);
        return new bp(e,t,s,o)
    }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Sb {
    constructor(e, t) {
        this.largestBatchId = e,
        this.mutation = t
    }
    getKey() {
        return this.mutation.key
    }
    isEqual(e) {
        return e !== null && this.mutation === e.mutation
    }
    toString() {
        return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var vt, Ue;
function Ab(r) {
    switch (r) {
    case te.OK:
        return De(64938);
    case te.CANCELLED:
    case te.UNKNOWN:
    case te.DEADLINE_EXCEEDED:
    case te.RESOURCE_EXHAUSTED:
    case te.INTERNAL:
    case te.UNAVAILABLE:
    case te.UNAUTHENTICATED:
        return !1;
    case te.INVALID_ARGUMENT:
    case te.NOT_FOUND:
    case te.ALREADY_EXISTS:
    case te.PERMISSION_DENIED:
    case te.FAILED_PRECONDITION:
    case te.ABORTED:
    case te.OUT_OF_RANGE:
    case te.UNIMPLEMENTED:
    case te.DATA_LOSS:
        return !0;
    default:
        return De(15467, {
            code: r
        })
    }
}
function Cb(r) {
    if (r === void 0)
        return xs("GRPC error has no .code"),
        te.UNKNOWN;
    switch (r) {
    case vt.OK:
        return te.OK;
    case vt.CANCELLED:
        return te.CANCELLED;
    case vt.UNKNOWN:
        return te.UNKNOWN;
    case vt.DEADLINE_EXCEEDED:
        return te.DEADLINE_EXCEEDED;
    case vt.RESOURCE_EXHAUSTED:
        return te.RESOURCE_EXHAUSTED;
    case vt.INTERNAL:
        return te.INTERNAL;
    case vt.UNAVAILABLE:
        return te.UNAVAILABLE;
    case vt.UNAUTHENTICATED:
        return te.UNAUTHENTICATED;
    case vt.INVALID_ARGUMENT:
        return te.INVALID_ARGUMENT;
    case vt.NOT_FOUND:
        return te.NOT_FOUND;
    case vt.ALREADY_EXISTS:
        return te.ALREADY_EXISTS;
    case vt.PERMISSION_DENIED:
        return te.PERMISSION_DENIED;
    case vt.FAILED_PRECONDITION:
        return te.FAILED_PRECONDITION;
    case vt.ABORTED:
        return te.ABORTED;
    case vt.OUT_OF_RANGE:
        return te.OUT_OF_RANGE;
    case vt.UNIMPLEMENTED:
        return te.UNIMPLEMENTED;
    case vt.DATA_LOSS:
        return te.DATA_LOSS;
    default:
        return De(39323, {
            code: r
        })
    }
}
(Ue = vt || (vt = {}))[Ue.OK = 0] = "OK",
Ue[Ue.CANCELLED = 1] = "CANCELLED",
Ue[Ue.UNKNOWN = 2] = "UNKNOWN",
Ue[Ue.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT",
Ue[Ue.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED",
Ue[Ue.NOT_FOUND = 5] = "NOT_FOUND",
Ue[Ue.ALREADY_EXISTS = 6] = "ALREADY_EXISTS",
Ue[Ue.PERMISSION_DENIED = 7] = "PERMISSION_DENIED",
Ue[Ue.UNAUTHENTICATED = 16] = "UNAUTHENTICATED",
Ue[Ue.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED",
Ue[Ue.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION",
Ue[Ue.ABORTED = 10] = "ABORTED",
Ue[Ue.OUT_OF_RANGE = 11] = "OUT_OF_RANGE",
Ue[Ue.UNIMPLEMENTED = 12] = "UNIMPLEMENTED",
Ue[Ue.INTERNAL = 13] = "INTERNAL",
Ue[Ue.UNAVAILABLE = 14] = "UNAVAILABLE",
Ue[Ue.DATA_LOSS = 15] = "DATA_LOSS";
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
new mp([4294967295, 4294967295],0);
class Rb {
    constructor(e, t) {
        this.databaseId = e,
        this.useProto3Json = t
    }
}
function zd(r, e) {
    return r.useProto3Json ? `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z` : {
        seconds: "" + e.seconds,
        nanos: e.nanoseconds
    }
}
function Ib(r, e) {
    return r.useProto3Json ? e.toBase64() : e.toUint8Array()
}
function wb(r, e) {
    return zd(r, e.toTimestamp())
}
function Uo(r) {
    return lt(!!r, 49232),
    it.fromTimestamp(function(t) {
        const s = Ps(t);
        return new Pt(s.seconds,s.nanos)
    }(r))
}
function ZE(r, e) {
    return Fd(r, e).canonicalString()
}
function Fd(r, e) {
    const t = function(o) {
        return new _t(["projects", o.projectId, "databases", o.database])
    }(r).child("documents");
    return e === void 0 ? t : t.child(e)
}
function bb(r) {
    const e = _t.fromString(r);
    return lt(Ub(e), 10190, {
        key: e.toString()
    }),
    e
}
function Hd(r, e) {
    return ZE(r.databaseId, e.path)
}
function Db(r) {
    const e = bb(r);
    return e.length === 4 ? _t.emptyPath() : Nb(e)
}
function Mb(r) {
    return new _t(["projects", r.databaseId.projectId, "databases", r.databaseId.database]).canonicalString()
}
function Nb(r) {
    return lt(r.length > 4 && r.get(4) === "documents", 29091, {
        key: r.toString()
    }),
    r.popFirst(5)
}
function e_(r, e, t) {
    return {
        name: Hd(r, e),
        fields: t.value.mapValue.fields
    }
}
function xb(r, e) {
    let t;
    if (e instanceof Ml)
        t = {
            update: e_(r, e.key, e.value)
        };
    else if (e instanceof WE)
        t = {
            delete: Hd(r, e.key)
        };
    else if (e instanceof Us)
        t = {
            update: e_(r, e.key, e.data),
            updateMask: Vb(e.fieldMask)
        };
    else {
        if (!(e instanceof Tb))
            return De(16599, {
                ft: e.type
            });
        t = {
            verify: Hd(r, e.key)
        }
    }
    return e.fieldTransforms.length > 0 && (t.updateTransforms = e.fieldTransforms.map(s => function(l, f) {
        const d = f.transform;
        if (d instanceof Bc)
            return {
                fieldPath: f.field.canonicalString(),
                setToServerValue: "REQUEST_TIME"
            };
        if (d instanceof vl)
            return {
                fieldPath: f.field.canonicalString(),
                appendMissingElements: {
                    values: d.elements
                }
            };
        if (d instanceof _l)
            return {
                fieldPath: f.field.canonicalString(),
                removeAllFromArray: {
                    values: d.elements
                }
            };
        if (d instanceof qc)
            return {
                fieldPath: f.field.canonicalString(),
                increment: d.Re
            };
        throw De(20930, {
            transform: f.transform
        })
    }(0, s))),
    e.precondition.isNone || (t.currentDocument = function(o, l) {
        return l.updateTime !== void 0 ? {
            updateTime: wb(o, l.updateTime)
        } : l.exists !== void 0 ? {
            exists: l.exists
        } : De(27497)
    }(r, e.precondition)),
    t
}
function Pb(r, e) {
    return r && r.length > 0 ? (lt(e !== void 0, 14353),
    r.map(t => function(o, l) {
        let f = o.updateTime ? Uo(o.updateTime) : Uo(l);
        return f.isEqual(it.min()) && (f = Uo(l)),
        new yb(f,o.transformResults || [])
    }(t, e))) : []
}
function Ob(r) {
    let e = Db(r.parent);
    const t = r.structuredQuery
      , s = t.from ? t.from.length : 0;
    let o = null;
    if (s > 0) {
        lt(s === 1, 65062);
        const T = t.from[0];
        T.allDescendants ? o = T.collectionId : e = e.child(T.collectionId)
    }
    let l = [];
    t.where && (l = function(A) {
        const I = e0(A);
        return I instanceof Mr && UE(I) ? I.getFilters() : [I]
    }(t.where));
    let f = [];
    t.orderBy && (f = function(A) {
        return A.map(I => function(q) {
            return new kc(No(q.field),function(J) {
                switch (J) {
                case "ASCENDING":
                    return "asc";
                case "DESCENDING":
                    return "desc";
                default:
                    return
                }
            }(q.direction))
        }(I))
    }(t.orderBy));
    let d = null;
    t.limit && (d = function(A) {
        let I;
        return I = typeof A == "object" ? A.value : A,
        Tp(I) ? null : I
    }(t.limit));
    let v = null;
    t.startAt && (v = function(A) {
        const I = !!A.before
          , V = A.values || [];
        return new Uc(V,I)
    }(t.startAt));
    let y = null;
    return t.endAt && (y = function(A) {
        const I = !A.before
          , V = A.values || [];
        return new Uc(V,I)
    }(t.endAt)),
    nb(e, o, f, l, d, "F", v, y)
}
function e0(r) {
    return r.unaryFilter !== void 0 ? function(t) {
        switch (t.unaryFilter.op) {
        case "IS_NAN":
            const s = No(t.unaryFilter.field);
            return xt.create(s, "==", {
                doubleValue: NaN
            });
        case "IS_NULL":
            const o = No(t.unaryFilter.field);
            return xt.create(o, "==", {
                nullValue: "NULL_VALUE"
            });
        case "IS_NOT_NAN":
            const l = No(t.unaryFilter.field);
            return xt.create(l, "!=", {
                doubleValue: NaN
            });
        case "IS_NOT_NULL":
            const f = No(t.unaryFilter.field);
            return xt.create(f, "!=", {
                nullValue: "NULL_VALUE"
            });
        case "OPERATOR_UNSPECIFIED":
            return De(61313);
        default:
            return De(60726)
        }
    }(r) : r.fieldFilter !== void 0 ? function(t) {
        return xt.create(No(t.fieldFilter.field), function(o) {
            switch (o) {
            case "EQUAL":
                return "==";
            case "NOT_EQUAL":
                return "!=";
            case "GREATER_THAN":
                return ">";
            case "GREATER_THAN_OR_EQUAL":
                return ">=";
            case "LESS_THAN":
                return "<";
            case "LESS_THAN_OR_EQUAL":
                return "<=";
            case "ARRAY_CONTAINS":
                return "array-contains";
            case "IN":
                return "in";
            case "NOT_IN":
                return "not-in";
            case "ARRAY_CONTAINS_ANY":
                return "array-contains-any";
            case "OPERATOR_UNSPECIFIED":
                return De(58110);
            default:
                return De(50506)
            }
        }(t.fieldFilter.op), t.fieldFilter.value)
    }(r) : r.compositeFilter !== void 0 ? function(t) {
        return Mr.create(t.compositeFilter.filters.map(s => e0(s)), function(o) {
            switch (o) {
            case "AND":
                return "and";
            case "OR":
                return "or";
            default:
                return De(1026)
            }
        }(t.compositeFilter.op))
    }(r) : De(30097, {
        filter: r
    })
}
function No(r) {
    return zt.fromServerFormat(r.fieldPath)
}
function Vb(r) {
    const e = [];
    return r.fields.forEach(t => e.push(t.canonicalString())),
    {
        fieldPaths: e
    }
}
function Ub(r) {
    return r.length >= 4 && r.get(0) === "projects" && r.get(2) === "databases"
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class kb {
    constructor(e) {
        this.wt = e
    }
}
function Lb(r) {
    const e = Ob({
        parent: r.parent,
        structuredQuery: r.structuredQuery
    });
    return r.limitType === "LAST" ? qd(e, e.limit, "L") : e
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bb {
    constructor() {
        this.yn = new qb
    }
    addToCollectionParentIndex(e, t) {
        return this.yn.add(t),
        Z.resolve()
    }
    getCollectionParents(e, t) {
        return Z.resolve(this.yn.getEntries(t))
    }
    addFieldIndex(e, t) {
        return Z.resolve()
    }
    deleteFieldIndex(e, t) {
        return Z.resolve()
    }
    deleteAllFieldIndexes(e) {
        return Z.resolve()
    }
    createTargetIndexes(e, t) {
        return Z.resolve()
    }
    getDocumentsMatchingTarget(e, t) {
        return Z.resolve(null)
    }
    getIndexType(e, t) {
        return Z.resolve(0)
    }
    getFieldIndexes(e, t) {
        return Z.resolve([])
    }
    getNextCollectionGroupToUpdate(e) {
        return Z.resolve(null)
    }
    getMinOffset(e, t) {
        return Z.resolve(Dr.min())
    }
    getMinOffsetFromCollectionGroup(e, t) {
        return Z.resolve(Dr.min())
    }
    updateCollectionGroup(e, t, s) {
        return Z.resolve()
    }
    updateIndexEntries(e, t) {
        return Z.resolve()
    }
}
class qb {
    constructor() {
        this.index = {}
    }
    add(e) {
        const t = e.lastSegment()
          , s = e.popLast()
          , o = this.index[t] || new Ft(_t.comparator)
          , l = !o.has(s);
        return this.index[t] = o.add(s),
        l
    }
    has(e) {
        const t = e.lastSegment()
          , s = e.popLast()
          , o = this.index[t];
        return o && o.has(s)
    }
    getEntries(e) {
        return (this.index[e] || new Ft(_t.comparator)).toArray()
    }
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const t_ = {
    didRun: !1,
    sequenceNumbersCollected: 0,
    targetsRemoved: 0,
    documentsRemoved: 0
}
  , t0 = 41943040;
class sn {
    static withCacheSize(e) {
        return new sn(e,sn.DEFAULT_COLLECTION_PERCENTILE,sn.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)
    }
    constructor(e, t, s) {
        this.cacheSizeCollectionThreshold = e,
        this.percentileToCollect = t,
        this.maximumSequenceNumbersToCollect = s
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
sn.DEFAULT_COLLECTION_PERCENTILE = 10,
sn.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3,
sn.DEFAULT = new sn(t0,sn.DEFAULT_COLLECTION_PERCENTILE,sn.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT),
sn.DISABLED = new sn(-1,0,0);
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fo {
    constructor(e) {
        this.nr = e
    }
    next() {
        return this.nr += 2,
        this.nr
    }
    static rr() {
        return new Fo(0)
    }
    static ir() {
        return new Fo(-1)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const n_ = "LruGarbageCollector"
  , zb = 1048576;
function i_([r,e], [t,s]) {
    const o = ke(r, t);
    return o === 0 ? ke(e, s) : o
}
class Fb {
    constructor(e) {
        this.cr = e,
        this.buffer = new Ft(i_),
        this.lr = 0
    }
    hr() {
        return ++this.lr
    }
    Pr(e) {
        const t = [e, this.hr()];
        if (this.buffer.size < this.cr)
            this.buffer = this.buffer.add(t);
        else {
            const s = this.buffer.last();
            i_(t, s) < 0 && (this.buffer = this.buffer.delete(s).add(t))
        }
    }
    get maxValue() {
        return this.buffer.last()[0]
    }
}
class Hb {
    constructor(e, t, s) {
        this.garbageCollector = e,
        this.asyncQueue = t,
        this.localStore = s,
        this.Tr = null
    }
    start() {
        this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this.Ir(6e4)
    }
    stop() {
        this.Tr && (this.Tr.cancel(),
        this.Tr = null)
    }
    get started() {
        return this.Tr !== null
    }
    Ir(e) {
        he(n_, `Garbage collection scheduled in ${e}ms`),
        this.Tr = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
            this.Tr = null;
            try {
                await this.localStore.collectGarbage(this.garbageCollector)
            } catch (t) {
                Dl(t) ? he(n_, "Ignoring IndexedDB error during garbage collection: ", t) : await yp(t)
            }
            await this.Ir(3e5)
        }
        )
    }
}
class Gb {
    constructor(e, t) {
        this.Er = e,
        this.params = t
    }
    calculateTargetCount(e, t) {
        return this.Er.dr(e).next(s => Math.floor(t / 100 * s))
    }
    nthSequenceNumber(e, t) {
        if (t === 0)
            return Z.resolve(vp.le);
        const s = new Fb(t);
        return this.Er.forEachTarget(e, o => s.Pr(o.sequenceNumber)).next( () => this.Er.Ar(e, o => s.Pr(o))).next( () => s.maxValue)
    }
    removeTargets(e, t, s) {
        return this.Er.removeTargets(e, t, s)
    }
    removeOrphanedDocuments(e, t) {
        return this.Er.removeOrphanedDocuments(e, t)
    }
    collect(e, t) {
        return this.params.cacheSizeCollectionThreshold === -1 ? (he("LruGarbageCollector", "Garbage collection skipped; disabled"),
        Z.resolve(t_)) : this.getCacheSize(e).next(s => s < this.params.cacheSizeCollectionThreshold ? (he("LruGarbageCollector", `Garbage collection skipped; Cache size ${s} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`),
        t_) : this.Rr(e, t))
    }
    getCacheSize(e) {
        return this.Er.getCacheSize(e)
    }
    Rr(e, t) {
        let s, o, l, f, d, v, y;
        const T = Date.now();
        return this.calculateTargetCount(e, this.params.percentileToCollect).next(A => (A > this.params.maximumSequenceNumbersToCollect ? (he("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${A}`),
        o = this.params.maximumSequenceNumbersToCollect) : o = A,
        f = Date.now(),
        this.nthSequenceNumber(e, o))).next(A => (s = A,
        d = Date.now(),
        this.removeTargets(e, s, t))).next(A => (l = A,
        v = Date.now(),
        this.removeOrphanedDocuments(e, s))).next(A => (y = Date.now(),
        Mo() <= xe.DEBUG && he("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${f - T}ms
	Determined least recently used ${o} in ` + (d - f) + `ms
	Removed ${l} targets in ` + (v - d) + `ms
	Removed ${A} documents in ` + (y - v) + `ms
Total Duration: ${y - T}ms`),
        Z.resolve({
            didRun: !0,
            sequenceNumbersCollected: o,
            targetsRemoved: l,
            documentsRemoved: A
        })))
    }
}
function Yb(r, e) {
    return new Gb(r,e)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Kb {
    constructor() {
        this.changes = new Vs(e => e.toString(), (e, t) => e.isEqual(t)),
        this.changesApplied = !1
    }
    addEntry(e) {
        this.assertNotApplied(),
        this.changes.set(e.key, e)
    }
    removeEntry(e, t) {
        this.assertNotApplied(),
        this.changes.set(e, Bn.newInvalidDocument(e).setReadTime(t))
    }
    getEntry(e, t) {
        this.assertNotApplied();
        const s = this.changes.get(t);
        return s !== void 0 ? Z.resolve(s) : this.getFromCache(e, t)
    }
    getEntries(e, t) {
        return this.getAllFromCache(e, t)
    }
    apply(e) {
        return this.assertNotApplied(),
        this.changesApplied = !0,
        this.applyChanges(e)
    }
    assertNotApplied() {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Qb {
    constructor(e, t) {
        this.overlayedDocument = e,
        this.mutatedFields = t
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xb {
    constructor(e, t, s, o) {
        this.remoteDocumentCache = e,
        this.mutationQueue = t,
        this.documentOverlayCache = s,
        this.indexManager = o
    }
    getDocument(e, t) {
        let s = null;
        return this.documentOverlayCache.getOverlay(e, t).next(o => (s = o,
        this.remoteDocumentCache.getEntry(e, t))).next(o => (s !== null && hl(s.mutation, o, Fn.empty(), Pt.now()),
        o))
    }
    getDocuments(e, t) {
        return this.remoteDocumentCache.getEntries(e, t).next(s => this.getLocalViewOfDocuments(e, s, $t()).next( () => s))
    }
    getLocalViewOfDocuments(e, t, s=$t()) {
        const o = Cs();
        return this.populateOverlays(e, o, t).next( () => this.computeViews(e, t, o, s).next(l => {
            let f = uc();
            return l.forEach( (d, v) => {
                f = f.insert(d, v.overlayedDocument)
            }
            ),
            f
        }
        ))
    }
    getOverlayedDocuments(e, t) {
        const s = Cs();
        return this.populateOverlays(e, s, t).next( () => this.computeViews(e, t, s, $t()))
    }
    populateOverlays(e, t, s) {
        const o = [];
        return s.forEach(l => {
            t.has(l) || o.push(l)
        }
        ),
        this.documentOverlayCache.getOverlays(e, o).next(l => {
            l.forEach( (f, d) => {
                t.set(f, d)
            }
            )
        }
        )
    }
    computeViews(e, t, s, o) {
        let l = Lc();
        const f = fl()
          , d = function() {
            return fl()
        }();
        return t.forEach( (v, y) => {
            const T = s.get(y.key);
            o.has(y.key) && (T === void 0 || T.mutation instanceof Us) ? l = l.insert(y.key, y) : T !== void 0 ? (f.set(y.key, T.mutation.getFieldMask()),
            hl(T.mutation, y, T.mutation.getFieldMask(), Pt.now())) : f.set(y.key, Fn.empty())
        }
        ),
        this.recalculateAndSaveOverlays(e, l).next(v => (v.forEach( (y, T) => f.set(y, T)),
        t.forEach( (y, T) => {
            var A;
            return d.set(y, new Qb(T,(A = f.get(y)) !== null && A !== void 0 ? A : null))
        }
        ),
        d))
    }
    recalculateAndSaveOverlays(e, t) {
        const s = fl();
        let o = new an( (f, d) => f - d)
          , l = $t();
        return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e, t).next(f => {
            for (const d of f)
                d.keys().forEach(v => {
                    const y = t.get(v);
                    if (y === null)
                        return;
                    let T = s.get(v) || Fn.empty();
                    T = d.applyToLocalView(y, T),
                    s.set(v, T);
                    const A = (o.get(d.batchId) || $t()).add(v);
                    o = o.insert(d.batchId, A)
                }
                )
        }
        ).next( () => {
            const f = []
              , d = o.getReverseIterator();
            for (; d.hasNext(); ) {
                const v = d.getNext()
                  , y = v.key
                  , T = v.value
                  , A = GE();
                T.forEach(I => {
                    if (!l.has(I)) {
                        const V = JE(t.get(I), s.get(I));
                        V !== null && A.set(I, V),
                        l = l.add(I)
                    }
                }
                ),
                f.push(this.documentOverlayCache.saveOverlays(e, y, A))
            }
            return Z.waitFor(f)
        }
        ).next( () => s)
    }
    recalculateAndSaveOverlaysForDocumentKeys(e, t) {
        return this.remoteDocumentCache.getEntries(e, t).next(s => this.recalculateAndSaveOverlays(e, s))
    }
    getDocumentsMatchingQuery(e, t, s, o) {
        return function(f) {
            return Re.isDocumentKey(f.path) && f.collectionGroup === null && f.filters.length === 0
        }(t) ? this.getDocumentsMatchingDocumentQuery(e, t.path) : rb(t) ? this.getDocumentsMatchingCollectionGroupQuery(e, t, s, o) : this.getDocumentsMatchingCollectionQuery(e, t, s, o)
    }
    getNextDocuments(e, t, s, o) {
        return this.remoteDocumentCache.getAllFromCollectionGroup(e, t, s, o).next(l => {
            const f = o - l.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(e, t, s.largestBatchId, o - l.size) : Z.resolve(Cs());
            let d = gl
              , v = l;
            return f.next(y => Z.forEach(y, (T, A) => (d < A.largestBatchId && (d = A.largestBatchId),
            l.get(T) ? Z.resolve() : this.remoteDocumentCache.getEntry(e, T).next(I => {
                v = v.insert(T, I)
            }
            ))).next( () => this.populateOverlays(e, y, l)).next( () => this.computeViews(e, v, y, $t())).next(T => ({
                batchId: d,
                changes: HE(T)
            })))
        }
        )
    }
    getDocumentsMatchingDocumentQuery(e, t) {
        return this.getDocument(e, new Re(t)).next(s => {
            let o = uc();
            return s.isFoundDocument() && (o = o.insert(s.key, s)),
            o
        }
        )
    }
    getDocumentsMatchingCollectionGroupQuery(e, t, s, o) {
        const l = t.collectionGroup;
        let f = uc();
        return this.indexManager.getCollectionParents(e, l).next(d => Z.forEach(d, v => {
            const y = function(A, I) {
                return new Wc(I,null,A.explicitOrderBy.slice(),A.filters.slice(),A.limit,A.limitType,A.startAt,A.endAt)
            }(t, v.child(l));
            return this.getDocumentsMatchingCollectionQuery(e, y, s, o).next(T => {
                T.forEach( (A, I) => {
                    f = f.insert(A, I)
                }
                )
            }
            )
        }
        ).next( () => f))
    }
    getDocumentsMatchingCollectionQuery(e, t, s, o) {
        let l;
        return this.documentOverlayCache.getOverlaysForCollection(e, t.path, s.largestBatchId).next(f => (l = f,
        this.remoteDocumentCache.getDocumentsMatchingQuery(e, t, s, l, o))).next(f => {
            l.forEach( (v, y) => {
                const T = y.getKey();
                f.get(T) === null && (f = f.insert(T, Bn.newInvalidDocument(T)))
            }
            );
            let d = uc();
            return f.forEach( (v, y) => {
                const T = l.get(v);
                T !== void 0 && hl(T.mutation, y, Fn.empty(), Pt.now()),
                Ip(t, y) && (d = d.insert(v, y))
            }
            ),
            d
        }
        )
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $b {
    constructor(e) {
        this.serializer = e,
        this.Fr = new Map,
        this.Mr = new Map
    }
    getBundleMetadata(e, t) {
        return Z.resolve(this.Fr.get(t))
    }
    saveBundleMetadata(e, t) {
        return this.Fr.set(t.id, function(o) {
            return {
                id: o.id,
                version: o.version,
                createTime: Uo(o.createTime)
            }
        }(t)),
        Z.resolve()
    }
    getNamedQuery(e, t) {
        return Z.resolve(this.Mr.get(t))
    }
    saveNamedQuery(e, t) {
        return this.Mr.set(t.name, function(o) {
            return {
                name: o.name,
                query: Lb(o.bundledQuery),
                readTime: Uo(o.readTime)
            }
        }(t)),
        Z.resolve()
    }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Jb {
    constructor() {
        this.overlays = new an(Re.comparator),
        this.Or = new Map
    }
    getOverlay(e, t) {
        return Z.resolve(this.overlays.get(t))
    }
    getOverlays(e, t) {
        const s = Cs();
        return Z.forEach(t, o => this.getOverlay(e, o).next(l => {
            l !== null && s.set(o, l)
        }
        )).next( () => s)
    }
    saveOverlays(e, t, s) {
        return s.forEach( (o, l) => {
            this.St(e, t, l)
        }
        ),
        Z.resolve()
    }
    removeOverlaysForBatchId(e, t, s) {
        const o = this.Or.get(s);
        return o !== void 0 && (o.forEach(l => this.overlays = this.overlays.remove(l)),
        this.Or.delete(s)),
        Z.resolve()
    }
    getOverlaysForCollection(e, t, s) {
        const o = Cs()
          , l = t.length + 1
          , f = new Re(t.child(""))
          , d = this.overlays.getIteratorFrom(f);
        for (; d.hasNext(); ) {
            const v = d.getNext().value
              , y = v.getKey();
            if (!t.isPrefixOf(y.path))
                break;
            y.path.length === l && v.largestBatchId > s && o.set(v.getKey(), v)
        }
        return Z.resolve(o)
    }
    getOverlaysForCollectionGroup(e, t, s, o) {
        let l = new an( (y, T) => y - T);
        const f = this.overlays.getIterator();
        for (; f.hasNext(); ) {
            const y = f.getNext().value;
            if (y.getKey().getCollectionGroup() === t && y.largestBatchId > s) {
                let T = l.get(y.largestBatchId);
                T === null && (T = Cs(),
                l = l.insert(y.largestBatchId, T)),
                T.set(y.getKey(), y)
            }
        }
        const d = Cs()
          , v = l.getIterator();
        for (; v.hasNext() && (v.getNext().value.forEach( (y, T) => d.set(y, T)),
        !(d.size() >= o)); )
            ;
        return Z.resolve(d)
    }
    St(e, t, s) {
        const o = this.overlays.get(s.key);
        if (o !== null) {
            const f = this.Or.get(o.largestBatchId).delete(s.key);
            this.Or.set(o.largestBatchId, f)
        }
        this.overlays = this.overlays.insert(s.key, new Sb(t,s));
        let l = this.Or.get(t);
        l === void 0 && (l = $t(),
        this.Or.set(t, l)),
        this.Or.set(t, l.add(s.key))
    }
}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class jb {
    constructor() {
        this.sessionToken = ui.EMPTY_BYTE_STRING
    }
    getSessionToken(e) {
        return Z.resolve(this.sessionToken)
    }
    setSessionToken(e, t) {
        return this.sessionToken = t,
        Z.resolve()
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Dp {
    constructor() {
        this.Nr = new Ft(Nt.Br),
        this.Lr = new Ft(Nt.kr)
    }
    isEmpty() {
        return this.Nr.isEmpty()
    }
    addReference(e, t) {
        const s = new Nt(e,t);
        this.Nr = this.Nr.add(s),
        this.Lr = this.Lr.add(s)
    }
    qr(e, t) {
        e.forEach(s => this.addReference(s, t))
    }
    removeReference(e, t) {
        this.Qr(new Nt(e,t))
    }
    $r(e, t) {
        e.forEach(s => this.removeReference(s, t))
    }
    Ur(e) {
        const t = new Re(new _t([]))
          , s = new Nt(t,e)
          , o = new Nt(t,e + 1)
          , l = [];
        return this.Lr.forEachInRange([s, o], f => {
            this.Qr(f),
            l.push(f.key)
        }
        ),
        l
    }
    Kr() {
        this.Nr.forEach(e => this.Qr(e))
    }
    Qr(e) {
        this.Nr = this.Nr.delete(e),
        this.Lr = this.Lr.delete(e)
    }
    Wr(e) {
        const t = new Re(new _t([]))
          , s = new Nt(t,e)
          , o = new Nt(t,e + 1);
        let l = $t();
        return this.Lr.forEachInRange([s, o], f => {
            l = l.add(f.key)
        }
        ),
        l
    }
    containsKey(e) {
        const t = new Nt(e,0)
          , s = this.Nr.firstAfterOrEqual(t);
        return s !== null && e.isEqual(s.key)
    }
}
class Nt {
    constructor(e, t) {
        this.key = e,
        this.Gr = t
    }
    static Br(e, t) {
        return Re.comparator(e.key, t.key) || ke(e.Gr, t.Gr)
    }
    static kr(e, t) {
        return ke(e.Gr, t.Gr) || Re.comparator(e.key, t.key)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Wb {
    constructor(e, t) {
        this.indexManager = e,
        this.referenceDelegate = t,
        this.mutationQueue = [],
        this.Jn = 1,
        this.zr = new Ft(Nt.Br)
    }
    checkEmpty(e) {
        return Z.resolve(this.mutationQueue.length === 0)
    }
    addMutationBatch(e, t, s, o) {
        const l = this.Jn;
        this.Jn++,
        this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
        const f = new Eb(l,t,s,o);
        this.mutationQueue.push(f);
        for (const d of o)
            this.zr = this.zr.add(new Nt(d.key,l)),
            this.indexManager.addToCollectionParentIndex(e, d.key.path.popLast());
        return Z.resolve(f)
    }
    lookupMutationBatch(e, t) {
        return Z.resolve(this.jr(t))
    }
    getNextMutationBatchAfterBatchId(e, t) {
        const s = t + 1
          , o = this.Hr(s)
          , l = o < 0 ? 0 : o;
        return Z.resolve(this.mutationQueue.length > l ? this.mutationQueue[l] : null)
    }
    getHighestUnacknowledgedBatchId() {
        return Z.resolve(this.mutationQueue.length === 0 ? _p : this.Jn - 1)
    }
    getAllMutationBatches(e) {
        return Z.resolve(this.mutationQueue.slice())
    }
    getAllMutationBatchesAffectingDocumentKey(e, t) {
        const s = new Nt(t,0)
          , o = new Nt(t,Number.POSITIVE_INFINITY)
          , l = [];
        return this.zr.forEachInRange([s, o], f => {
            const d = this.jr(f.Gr);
            l.push(d)
        }
        ),
        Z.resolve(l)
    }
    getAllMutationBatchesAffectingDocumentKeys(e, t) {
        let s = new Ft(ke);
        return t.forEach(o => {
            const l = new Nt(o,0)
              , f = new Nt(o,Number.POSITIVE_INFINITY);
            this.zr.forEachInRange([l, f], d => {
                s = s.add(d.Gr)
            }
            )
        }
        ),
        Z.resolve(this.Jr(s))
    }
    getAllMutationBatchesAffectingQuery(e, t) {
        const s = t.path
          , o = s.length + 1;
        let l = s;
        Re.isDocumentKey(l) || (l = l.child(""));
        const f = new Nt(new Re(l),0);
        let d = new Ft(ke);
        return this.zr.forEachWhile(v => {
            const y = v.key.path;
            return !!s.isPrefixOf(y) && (y.length === o && (d = d.add(v.Gr)),
            !0)
        }
        , f),
        Z.resolve(this.Jr(d))
    }
    Jr(e) {
        const t = [];
        return e.forEach(s => {
            const o = this.jr(s);
            o !== null && t.push(o)
        }
        ),
        t
    }
    removeMutationBatch(e, t) {
        lt(this.Yr(t.batchId, "removed") === 0, 55003),
        this.mutationQueue.shift();
        let s = this.zr;
        return Z.forEach(t.mutations, o => {
            const l = new Nt(o.key,t.batchId);
            return s = s.delete(l),
            this.referenceDelegate.markPotentiallyOrphaned(e, o.key)
        }
        ).next( () => {
            this.zr = s
        }
        )
    }
    Xn(e) {}
    containsKey(e, t) {
        const s = new Nt(t,0)
          , o = this.zr.firstAfterOrEqual(s);
        return Z.resolve(t.isEqual(o && o.key))
    }
    performConsistencyCheck(e) {
        return this.mutationQueue.length,
        Z.resolve()
    }
    Yr(e, t) {
        return this.Hr(e)
    }
    Hr(e) {
        return this.mutationQueue.length === 0 ? 0 : e - this.mutationQueue[0].batchId
    }
    jr(e) {
        const t = this.Hr(e);
        return t < 0 || t >= this.mutationQueue.length ? null : this.mutationQueue[t]
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Zb {
    constructor(e) {
        this.Zr = e,
        this.docs = function() {
            return new an(Re.comparator)
        }(),
        this.size = 0
    }
    setIndexManager(e) {
        this.indexManager = e
    }
    addEntry(e, t) {
        const s = t.key
          , o = this.docs.get(s)
          , l = o ? o.size : 0
          , f = this.Zr(t);
        return this.docs = this.docs.insert(s, {
            document: t.mutableCopy(),
            size: f
        }),
        this.size += f - l,
        this.indexManager.addToCollectionParentIndex(e, s.path.popLast())
    }
    removeEntry(e) {
        const t = this.docs.get(e);
        t && (this.docs = this.docs.remove(e),
        this.size -= t.size)
    }
    getEntry(e, t) {
        const s = this.docs.get(t);
        return Z.resolve(s ? s.document.mutableCopy() : Bn.newInvalidDocument(t))
    }
    getEntries(e, t) {
        let s = Lc();
        return t.forEach(o => {
            const l = this.docs.get(o);
            s = s.insert(o, l ? l.document.mutableCopy() : Bn.newInvalidDocument(o))
        }
        ),
        Z.resolve(s)
    }
    getDocumentsMatchingQuery(e, t, s, o) {
        let l = Lc();
        const f = t.path
          , d = new Re(f.child("__id-9223372036854775808__"))
          , v = this.docs.getIteratorFrom(d);
        for (; v.hasNext(); ) {
            const {key: y, value: {document: T}} = v.getNext();
            if (!f.isPrefixOf(y.path))
                break;
            y.path.length > f.length + 1 || Pw(xw(T), s) <= 0 || (o.has(T.key) || Ip(t, T)) && (l = l.insert(T.key, T.mutableCopy()))
        }
        return Z.resolve(l)
    }
    getAllFromCollectionGroup(e, t, s, o) {
        De(9500)
    }
    Xr(e, t) {
        return Z.forEach(this.docs, s => t(s))
    }
    newChangeBuffer(e) {
        return new eD(this)
    }
    getSize(e) {
        return Z.resolve(this.size)
    }
}
class eD extends Kb {
    constructor(e) {
        super(),
        this.vr = e
    }
    applyChanges(e) {
        const t = [];
        return this.changes.forEach( (s, o) => {
            o.isValidDocument() ? t.push(this.vr.addEntry(e, o)) : this.vr.removeEntry(s)
        }
        ),
        Z.waitFor(t)
    }
    getFromCache(e, t) {
        return this.vr.getEntry(e, t)
    }
    getAllFromCache(e, t) {
        return this.vr.getEntries(e, t)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class tD {
    constructor(e) {
        this.persistence = e,
        this.ei = new Vs(t => Cp(t),Rp),
        this.lastRemoteSnapshotVersion = it.min(),
        this.highestTargetId = 0,
        this.ti = 0,
        this.ni = new Dp,
        this.targetCount = 0,
        this.ri = Fo.rr()
    }
    forEachTarget(e, t) {
        return this.ei.forEach( (s, o) => t(o)),
        Z.resolve()
    }
    getLastRemoteSnapshotVersion(e) {
        return Z.resolve(this.lastRemoteSnapshotVersion)
    }
    getHighestSequenceNumber(e) {
        return Z.resolve(this.ti)
    }
    allocateTargetId(e) {
        return this.highestTargetId = this.ri.next(),
        Z.resolve(this.highestTargetId)
    }
    setTargetsMetadata(e, t, s) {
        return s && (this.lastRemoteSnapshotVersion = s),
        t > this.ti && (this.ti = t),
        Z.resolve()
    }
    ar(e) {
        this.ei.set(e.target, e);
        const t = e.targetId;
        t > this.highestTargetId && (this.ri = new Fo(t),
        this.highestTargetId = t),
        e.sequenceNumber > this.ti && (this.ti = e.sequenceNumber)
    }
    addTargetData(e, t) {
        return this.ar(t),
        this.targetCount += 1,
        Z.resolve()
    }
    updateTargetData(e, t) {
        return this.ar(t),
        Z.resolve()
    }
    removeTargetData(e, t) {
        return this.ei.delete(t.target),
        this.ni.Ur(t.targetId),
        this.targetCount -= 1,
        Z.resolve()
    }
    removeTargets(e, t, s) {
        let o = 0;
        const l = [];
        return this.ei.forEach( (f, d) => {
            d.sequenceNumber <= t && s.get(d.targetId) === null && (this.ei.delete(f),
            l.push(this.removeMatchingKeysForTargetId(e, d.targetId)),
            o++)
        }
        ),
        Z.waitFor(l).next( () => o)
    }
    getTargetCount(e) {
        return Z.resolve(this.targetCount)
    }
    getTargetData(e, t) {
        const s = this.ei.get(t) || null;
        return Z.resolve(s)
    }
    addMatchingKeys(e, t, s) {
        return this.ni.qr(t, s),
        Z.resolve()
    }
    removeMatchingKeys(e, t, s) {
        this.ni.$r(t, s);
        const o = this.persistence.referenceDelegate
          , l = [];
        return o && t.forEach(f => {
            l.push(o.markPotentiallyOrphaned(e, f))
        }
        ),
        Z.waitFor(l)
    }
    removeMatchingKeysForTargetId(e, t) {
        return this.ni.Ur(t),
        Z.resolve()
    }
    getMatchingKeysForTargetId(e, t) {
        const s = this.ni.Wr(t);
        return Z.resolve(s)
    }
    containsKey(e, t) {
        return Z.resolve(this.ni.containsKey(t))
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class n0 {
    constructor(e, t) {
        this.ii = {},
        this.overlays = {},
        this.si = new vp(0),
        this.oi = !1,
        this.oi = !0,
        this._i = new jb,
        this.referenceDelegate = e(this),
        this.ai = new tD(this),
        this.indexManager = new Bb,
        this.remoteDocumentCache = function(o) {
            return new Zb(o)
        }(s => this.referenceDelegate.ui(s)),
        this.serializer = new kb(t),
        this.ci = new $b(this.serializer)
    }
    start() {
        return Promise.resolve()
    }
    shutdown() {
        return this.oi = !1,
        Promise.resolve()
    }
    get started() {
        return this.oi
    }
    setDatabaseDeletedListener() {}
    setNetworkEnabled() {}
    getIndexManager(e) {
        return this.indexManager
    }
    getDocumentOverlayCache(e) {
        let t = this.overlays[e.toKey()];
        return t || (t = new Jb,
        this.overlays[e.toKey()] = t),
        t
    }
    getMutationQueue(e, t) {
        let s = this.ii[e.toKey()];
        return s || (s = new Wb(t,this.referenceDelegate),
        this.ii[e.toKey()] = s),
        s
    }
    getGlobalsCache() {
        return this._i
    }
    getTargetCache() {
        return this.ai
    }
    getRemoteDocumentCache() {
        return this.remoteDocumentCache
    }
    getBundleCache() {
        return this.ci
    }
    runTransaction(e, t, s) {
        he("MemoryPersistence", "Starting transaction:", e);
        const o = new nD(this.si.next());
        return this.referenceDelegate.li(),
        s(o).next(l => this.referenceDelegate.hi(o).next( () => l)).toPromise().then(l => (o.raiseOnCommittedEvent(),
        l))
    }
    Pi(e, t) {
        return Z.or(Object.values(this.ii).map(s => () => s.containsKey(e, t)))
    }
}
class nD extends Vw {
    constructor(e) {
        super(),
        this.currentSequenceNumber = e
    }
}
class Mp {
    constructor(e) {
        this.persistence = e,
        this.Ti = new Dp,
        this.Ii = null
    }
    static Ei(e) {
        return new Mp(e)
    }
    get di() {
        if (this.Ii)
            return this.Ii;
        throw De(60996)
    }
    addReference(e, t, s) {
        return this.Ti.addReference(s, t),
        this.di.delete(s.toString()),
        Z.resolve()
    }
    removeReference(e, t, s) {
        return this.Ti.removeReference(s, t),
        this.di.add(s.toString()),
        Z.resolve()
    }
    markPotentiallyOrphaned(e, t) {
        return this.di.add(t.toString()),
        Z.resolve()
    }
    removeTarget(e, t) {
        this.Ti.Ur(t.targetId).forEach(o => this.di.add(o.toString()));
        const s = this.persistence.getTargetCache();
        return s.getMatchingKeysForTargetId(e, t.targetId).next(o => {
            o.forEach(l => this.di.add(l.toString()))
        }
        ).next( () => s.removeTargetData(e, t))
    }
    li() {
        this.Ii = new Set
    }
    hi(e) {
        const t = this.persistence.getRemoteDocumentCache().newChangeBuffer();
        return Z.forEach(this.di, s => {
            const o = Re.fromPath(s);
            return this.Ai(e, o).next(l => {
                l || t.removeEntry(o, it.min())
            }
            )
        }
        ).next( () => (this.Ii = null,
        t.apply(e)))
    }
    updateLimboDocument(e, t) {
        return this.Ai(e, t).next(s => {
            s ? this.di.delete(t.toString()) : this.di.add(t.toString())
        }
        )
    }
    ui(e) {
        return 0
    }
    Ai(e, t) {
        return Z.or([ () => Z.resolve(this.Ti.containsKey(t)), () => this.persistence.getTargetCache().containsKey(e, t), () => this.persistence.Pi(e, t)])
    }
}
class zc {
    constructor(e, t) {
        this.persistence = e,
        this.Ri = new Vs(s => Lw(s.path), (s, o) => s.isEqual(o)),
        this.garbageCollector = Yb(this, t)
    }
    static Ei(e, t) {
        return new zc(e,t)
    }
    li() {}
    hi(e) {
        return Z.resolve()
    }
    forEachTarget(e, t) {
        return this.persistence.getTargetCache().forEachTarget(e, t)
    }
    dr(e) {
        const t = this.Vr(e);
        return this.persistence.getTargetCache().getTargetCount(e).next(s => t.next(o => s + o))
    }
    Vr(e) {
        let t = 0;
        return this.Ar(e, s => {
            t++
        }
        ).next( () => t)
    }
    Ar(e, t) {
        return Z.forEach(this.Ri, (s, o) => this.gr(e, s, o).next(l => l ? Z.resolve() : t(o)))
    }
    removeTargets(e, t, s) {
        return this.persistence.getTargetCache().removeTargets(e, t, s)
    }
    removeOrphanedDocuments(e, t) {
        let s = 0;
        const o = this.persistence.getRemoteDocumentCache()
          , l = o.newChangeBuffer();
        return o.Xr(e, f => this.gr(e, f, t).next(d => {
            d || (s++,
            l.removeEntry(f, it.min()))
        }
        )).next( () => l.apply(e)).next( () => s)
    }
    markPotentiallyOrphaned(e, t) {
        return this.Ri.set(t, e.currentSequenceNumber),
        Z.resolve()
    }
    removeTarget(e, t) {
        const s = t.withSequenceNumber(e.currentSequenceNumber);
        return this.persistence.getTargetCache().updateTargetData(e, s)
    }
    addReference(e, t, s) {
        return this.Ri.set(s, e.currentSequenceNumber),
        Z.resolve()
    }
    removeReference(e, t, s) {
        return this.Ri.set(s, e.currentSequenceNumber),
        Z.resolve()
    }
    updateLimboDocument(e, t) {
        return this.Ri.set(t, e.currentSequenceNumber),
        Z.resolve()
    }
    ui(e) {
        let t = e.key.toString().length;
        return e.isFoundDocument() && (t += _c(e.data.value)),
        t
    }
    gr(e, t, s) {
        return Z.or([ () => this.persistence.Pi(e, t), () => this.persistence.getTargetCache().containsKey(e, t), () => {
            const o = this.Ri.get(t);
            return Z.resolve(o !== void 0 && o > s)
        }
        ])
    }
    getCacheSize(e) {
        return this.persistence.getRemoteDocumentCache().getSize(e)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Np {
    constructor(e, t, s, o) {
        this.targetId = e,
        this.fromCache = t,
        this.ls = s,
        this.hs = o
    }
    static Ps(e, t) {
        let s = $t()
          , o = $t();
        for (const l of t.docChanges)
            switch (l.type) {
            case 0:
                s = s.add(l.doc.key);
                break;
            case 1:
                o = o.add(l.doc.key)
            }
        return new Np(e,t.fromCache,s,o)
    }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class iD {
    constructor() {
        this._documentReadCount = 0
    }
    get documentReadCount() {
        return this._documentReadCount
    }
    incrementDocumentReadCount(e) {
        this._documentReadCount += e
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class rD {
    constructor() {
        this.Ts = !1,
        this.Is = !1,
        this.Es = 100,
        this.ds = function() {
            return BA() ? 8 : Uw(Jt()) > 0 ? 6 : 4
        }()
    }
    initialize(e, t) {
        this.As = e,
        this.indexManager = t,
        this.Ts = !0
    }
    getDocumentsMatchingQuery(e, t, s, o) {
        const l = {
            result: null
        };
        return this.Rs(e, t).next(f => {
            l.result = f
        }
        ).next( () => {
            if (!l.result)
                return this.Vs(e, t, o, s).next(f => {
                    l.result = f
                }
                )
        }
        ).next( () => {
            if (l.result)
                return;
            const f = new iD;
            return this.fs(e, t, f).next(d => {
                if (l.result = d,
                this.Is)
                    return this.gs(e, t, f, d.size)
            }
            )
        }
        ).next( () => l.result)
    }
    gs(e, t, s, o) {
        return s.documentReadCount < this.Es ? (Mo() <= xe.DEBUG && he("QueryEngine", "SDK will not create cache indexes for query:", rl(t), "since it only creates cache indexes for collection contains", "more than or equal to", this.Es, "documents"),
        Z.resolve()) : (Mo() <= xe.DEBUG && he("QueryEngine", "Query:", rl(t), "scans", s.documentReadCount, "local documents and returns", o, "documents as results."),
        s.documentReadCount > this.ds * o ? (Mo() <= xe.DEBUG && he("QueryEngine", "The SDK decides to create cache indexes for query:", rl(t), "as using cache indexes may help improve performance."),
        this.indexManager.createTargetIndexes(e, Is(t))) : Z.resolve())
    }
    Rs(e, t) {
        if ($v(t))
            return Z.resolve(null);
        let s = Is(t);
        return this.indexManager.getIndexType(e, s).next(o => o === 0 ? null : (t.limit !== null && o === 1 && (t = qd(t, null, "F"),
        s = Is(t)),
        this.indexManager.getDocumentsMatchingTarget(e, s).next(l => {
            const f = $t(...l);
            return this.As.getDocuments(e, f).next(d => this.indexManager.getMinOffset(e, s).next(v => {
                const y = this.ps(t, d);
                return this.ys(t, y, f, v.readTime) ? this.Rs(e, qd(t, null, "F")) : this.ws(e, y, t, v)
            }
            ))
        }
        )))
    }
    Vs(e, t, s, o) {
        return $v(t) || o.isEqual(it.min()) ? Z.resolve(null) : this.As.getDocuments(e, s).next(l => {
            const f = this.ps(t, l);
            return this.ys(t, f, s, o) ? Z.resolve(null) : (Mo() <= xe.DEBUG && he("QueryEngine", "Re-using previous result from %s to execute query: %s", o.toString(), rl(t)),
            this.ws(e, f, t, Nw(o, gl)).next(d => d))
        }
        )
    }
    ps(e, t) {
        let s = new Ft(ob(e));
        return t.forEach( (o, l) => {
            Ip(e, l) && (s = s.add(l))
        }
        ),
        s
    }
    ys(e, t, s, o) {
        if (e.limit === null)
            return !1;
        if (s.size !== t.size)
            return !0;
        const l = e.limitType === "F" ? t.last() : t.first();
        return !!l && (l.hasPendingWrites || l.version.compareTo(o) > 0)
    }
    fs(e, t, s) {
        return Mo() <= xe.DEBUG && he("QueryEngine", "Using full collection scan to execute query:", rl(t)),
        this.As.getDocumentsMatchingQuery(e, t, Dr.min(), s)
    }
    ws(e, t, s, o) {
        return this.As.getDocumentsMatchingQuery(e, s, o).next(l => (t.forEach(f => {
            l = l.insert(f.key, f)
        }
        ),
        l))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const sD = "LocalStore";
class oD {
    constructor(e, t, s, o) {
        this.persistence = e,
        this.bs = t,
        this.serializer = o,
        this.Ss = new an(ke),
        this.Ds = new Vs(l => Cp(l),Rp),
        this.vs = new Map,
        this.Cs = e.getRemoteDocumentCache(),
        this.ai = e.getTargetCache(),
        this.ci = e.getBundleCache(),
        this.Fs(s)
    }
    Fs(e) {
        this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e),
        this.indexManager = this.persistence.getIndexManager(e),
        this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager),
        this.localDocuments = new Xb(this.Cs,this.mutationQueue,this.documentOverlayCache,this.indexManager),
        this.Cs.setIndexManager(this.indexManager),
        this.bs.initialize(this.localDocuments, this.indexManager)
    }
    collectGarbage(e) {
        return this.persistence.runTransaction("Collect garbage", "readwrite-primary", t => e.collect(t, this.Ss))
    }
}
function aD(r, e, t, s) {
    return new oD(r,e,t,s)
}
async function i0(r, e) {
    const t = et(r);
    return await t.persistence.runTransaction("Handle user change", "readonly", s => {
        let o;
        return t.mutationQueue.getAllMutationBatches(s).next(l => (o = l,
        t.Fs(e),
        t.mutationQueue.getAllMutationBatches(s))).next(l => {
            const f = []
              , d = [];
            let v = $t();
            for (const y of o) {
                f.push(y.batchId);
                for (const T of y.mutations)
                    v = v.add(T.key)
            }
            for (const y of l) {
                d.push(y.batchId);
                for (const T of y.mutations)
                    v = v.add(T.key)
            }
            return t.localDocuments.getDocuments(s, v).next(y => ({
                Ms: y,
                removedBatchIds: f,
                addedBatchIds: d
            }))
        }
        )
    }
    )
}
function lD(r, e) {
    const t = et(r);
    return t.persistence.runTransaction("Acknowledge batch", "readwrite-primary", s => {
        const o = e.batch.keys()
          , l = t.Cs.newChangeBuffer({
            trackRemovals: !0
        });
        return function(d, v, y, T) {
            const A = y.batch
              , I = A.keys();
            let V = Z.resolve();
            return I.forEach(q => {
                V = V.next( () => T.getEntry(v, q)).next(G => {
                    const J = y.docVersions.get(q);
                    lt(J !== null, 48541),
                    G.version.compareTo(J) < 0 && (A.applyToRemoteDocument(G, y),
                    G.isValidDocument() && (G.setReadTime(y.commitVersion),
                    T.addEntry(G)))
                }
                )
            }
            ),
            V.next( () => d.mutationQueue.removeMutationBatch(v, A))
        }(t, s, e, l).next( () => l.apply(s)).next( () => t.mutationQueue.performConsistencyCheck(s)).next( () => t.documentOverlayCache.removeOverlaysForBatchId(s, o, e.batch.batchId)).next( () => t.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(s, function(d) {
            let v = $t();
            for (let y = 0; y < d.mutationResults.length; ++y)
                d.mutationResults[y].transformResults.length > 0 && (v = v.add(d.batch.mutations[y].key));
            return v
        }(e))).next( () => t.localDocuments.getDocuments(s, o))
    }
    )
}
function uD(r) {
    const e = et(r);
    return e.persistence.runTransaction("Get last remote snapshot version", "readonly", t => e.ai.getLastRemoteSnapshotVersion(t))
}
function cD(r, e) {
    const t = et(r);
    return t.persistence.runTransaction("Get next mutation batch", "readonly", s => (e === void 0 && (e = _p),
    t.mutationQueue.getNextMutationBatchAfterBatchId(s, e)))
}
class r_ {
    constructor() {
        this.activeTargetIds = hb()
    }
    $s(e) {
        this.activeTargetIds = this.activeTargetIds.add(e)
    }
    Us(e) {
        this.activeTargetIds = this.activeTargetIds.delete(e)
    }
    Qs() {
        const e = {
            activeTargetIds: this.activeTargetIds.toArray(),
            updateTimeMs: Date.now()
        };
        return JSON.stringify(e)
    }
}
class fD {
    constructor() {
        this.So = new r_,
        this.Do = {},
        this.onlineStateHandler = null,
        this.sequenceNumberHandler = null
    }
    addPendingMutation(e) {}
    updateMutationState(e, t, s) {}
    addLocalQueryTarget(e, t=!0) {
        return t && this.So.$s(e),
        this.Do[e] || "not-current"
    }
    updateQueryState(e, t, s) {
        this.Do[e] = t
    }
    removeLocalQueryTarget(e) {
        this.So.Us(e)
    }
    isLocalQueryTarget(e) {
        return this.So.activeTargetIds.has(e)
    }
    clearQueryState(e) {
        delete this.Do[e]
    }
    getAllActiveQueryTargets() {
        return this.So.activeTargetIds
    }
    isActiveQueryTarget(e) {
        return this.So.activeTargetIds.has(e)
    }
    start() {
        return this.So = new r_,
        Promise.resolve()
    }
    handleUserChange(e, t, s) {}
    setOnlineState(e) {}
    shutdown() {}
    writeSequenceNumber(e) {}
    notifyBundleLoaded(e) {}
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hD {
    vo(e) {}
    shutdown() {}
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const s_ = "ConnectivityMonitor";
class o_ {
    constructor() {
        this.Co = () => this.Fo(),
        this.Mo = () => this.xo(),
        this.Oo = [],
        this.No()
    }
    vo(e) {
        this.Oo.push(e)
    }
    shutdown() {
        window.removeEventListener("online", this.Co),
        window.removeEventListener("offline", this.Mo)
    }
    No() {
        window.addEventListener("online", this.Co),
        window.addEventListener("offline", this.Mo)
    }
    Fo() {
        he(s_, "Network connectivity changed: AVAILABLE");
        for (const e of this.Oo)
            e(0)
    }
    xo() {
        he(s_, "Network connectivity changed: UNAVAILABLE");
        for (const e of this.Oo)
            e(1)
    }
    static C() {
        return typeof window < "u" && window.addEventListener !== void 0 && window.removeEventListener !== void 0
    }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let cc = null;
function Gd() {
    return cc === null ? cc = function() {
        return 268435456 + Math.round(2147483648 * Math.random())
    }() : cc++,
    "0x" + cc.toString(16)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Sd = "RestConnection"
  , dD = {
    BatchGetDocuments: "batchGet",
    Commit: "commit",
    RunQuery: "runQuery",
    RunAggregationQuery: "runAggregationQuery"
};
class pD {
    get Bo() {
        return !1
    }
    constructor(e) {
        this.databaseInfo = e,
        this.databaseId = e.databaseId;
        const t = e.ssl ? "https" : "http"
          , s = encodeURIComponent(this.databaseId.projectId)
          , o = encodeURIComponent(this.databaseId.database);
        this.Lo = t + "://" + e.host,
        this.ko = `projects/${s}/databases/${o}`,
        this.qo = this.databaseId.database === Oc ? `project_id=${s}` : `project_id=${s}&database_id=${o}`
    }
    Qo(e, t, s, o, l) {
        const f = Gd()
          , d = this.$o(e, t.toUriEncodedString());
        he(Sd, `Sending RPC '${e}' ${f}:`, d, s);
        const v = {
            "google-cloud-resource-prefix": this.ko,
            "x-goog-request-params": this.qo
        };
        return this.Uo(v, o, l),
        this.Ko(e, d, v, s).then(y => (he(Sd, `Received RPC '${e}' ${f}: `, y),
        y), y => {
            throw jc(Sd, `RPC '${e}' ${f} failed with error: `, y, "url: ", d, "request:", s),
            y
        }
        )
    }
    Wo(e, t, s, o, l, f) {
        return this.Qo(e, t, s, o, l)
    }
    Uo(e, t, s) {
        e["X-Goog-Api-Client"] = function() {
            return "gl-js/ fire/" + Yo
        }(),
        e["Content-Type"] = "text/plain",
        this.databaseInfo.appId && (e["X-Firebase-GMPID"] = this.databaseInfo.appId),
        t && t.headers.forEach( (o, l) => e[l] = o),
        s && s.headers.forEach( (o, l) => e[l] = o)
    }
    $o(e, t) {
        const s = dD[e];
        return `${this.Lo}/v1/${t}:${s}`
    }
    terminate() {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class mD {
    constructor(e) {
        this.Go = e.Go,
        this.zo = e.zo
    }
    jo(e) {
        this.Ho = e
    }
    Jo(e) {
        this.Yo = e
    }
    Zo(e) {
        this.Xo = e
    }
    onMessage(e) {
        this.e_ = e
    }
    close() {
        this.zo()
    }
    send(e) {
        this.Go(e)
    }
    t_() {
        this.Ho()
    }
    n_() {
        this.Yo()
    }
    r_(e) {
        this.Xo(e)
    }
    i_(e) {
        this.e_(e)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Kt = "WebChannelConnection";
class gD extends pD {
    constructor(e) {
        super(e),
        this.forceLongPolling = e.forceLongPolling,
        this.autoDetectLongPolling = e.autoDetectLongPolling,
        this.useFetchStreams = e.useFetchStreams,
        this.longPollingOptions = e.longPollingOptions
    }
    Ko(e, t, s, o) {
        const l = Gd();
        return new Promise( (f, d) => {
            const v = new yE;
            v.setWithCredentials(!0),
            v.listenOnce(vE.COMPLETE, () => {
                try {
                    switch (v.getLastErrorCode()) {
                    case vc.NO_ERROR:
                        const T = v.getResponseJson();
                        he(Kt, `XHR for RPC '${e}' ${l} received:`, JSON.stringify(T)),
                        f(T);
                        break;
                    case vc.TIMEOUT:
                        he(Kt, `RPC '${e}' ${l} timed out`),
                        d(new Ee(te.DEADLINE_EXCEEDED,"Request time out"));
                        break;
                    case vc.HTTP_ERROR:
                        const A = v.getStatus();
                        if (he(Kt, `RPC '${e}' ${l} failed with status:`, A, "response text:", v.getResponseText()),
                        A > 0) {
                            let I = v.getResponseJson();
                            Array.isArray(I) && (I = I[0]);
                            const V = I == null ? void 0 : I.error;
                            if (V && V.status && V.message) {
                                const q = function(J) {
                                    const ne = J.toLowerCase().replace(/_/g, "-");
                                    return Object.values(te).indexOf(ne) >= 0 ? ne : te.UNKNOWN
                                }(V.status);
                                d(new Ee(q,V.message))
                            } else
                                d(new Ee(te.UNKNOWN,"Server responded with status " + v.getStatus()))
                        } else
                            d(new Ee(te.UNAVAILABLE,"Connection failed."));
                        break;
                    default:
                        De(9055, {
                            s_: e,
                            streamId: l,
                            o_: v.getLastErrorCode(),
                            __: v.getLastError()
                        })
                    }
                } finally {
                    he(Kt, `RPC '${e}' ${l} completed.`)
                }
            }
            );
            const y = JSON.stringify(o);
            he(Kt, `RPC '${e}' ${l} sending request:`, o),
            v.send(t, "POST", y, s, 15)
        }
        )
    }
    a_(e, t, s) {
        const o = Gd()
          , l = [this.Lo, "/", "google.firestore.v1.Firestore", "/", e, "/channel"]
          , f = EE()
          , d = TE()
          , v = {
            httpSessionIdParam: "gsessionid",
            initMessageHeaders: {},
            messageUrlParams: {
                database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
            },
            sendRawJson: !0,
            supportsCrossDomainXhr: !0,
            internalChannelParams: {
                forwardChannelRequestTimeoutMs: 6e5
            },
            forceLongPolling: this.forceLongPolling,
            detectBufferingProxy: this.autoDetectLongPolling
        }
          , y = this.longPollingOptions.timeoutSeconds;
        y !== void 0 && (v.longPollingTimeout = Math.round(1e3 * y)),
        this.useFetchStreams && (v.useFetchStreams = !0),
        this.Uo(v.initMessageHeaders, t, s),
        v.encodeInitMessageHeaders = !0;
        const T = l.join("");
        he(Kt, `Creating RPC '${e}' stream ${o}: ${T}`, v);
        const A = f.createWebChannel(T, v);
        let I = !1
          , V = !1;
        const q = new mD({
            Go: J => {
                V ? he(Kt, `Not sending because RPC '${e}' stream ${o} is closed:`, J) : (I || (he(Kt, `Opening RPC '${e}' stream ${o} transport.`),
                A.open(),
                I = !0),
                he(Kt, `RPC '${e}' stream ${o} sending:`, J),
                A.send(J))
            }
            ,
            zo: () => A.close()
        })
          , G = (J, ne, se) => {
            J.listen(ne, le => {
                try {
                    se(le)
                } catch (ue) {
                    setTimeout( () => {
                        throw ue
                    }
                    , 0)
                }
            }
            )
        }
        ;
        return G(A, al.EventType.OPEN, () => {
            V || (he(Kt, `RPC '${e}' stream ${o} transport opened.`),
            q.t_())
        }
        ),
        G(A, al.EventType.CLOSE, () => {
            V || (V = !0,
            he(Kt, `RPC '${e}' stream ${o} transport closed`),
            q.r_())
        }
        ),
        G(A, al.EventType.ERROR, J => {
            V || (V = !0,
            jc(Kt, `RPC '${e}' stream ${o} transport errored. Name:`, J.name, "Message:", J.message),
            q.r_(new Ee(te.UNAVAILABLE,"The operation could not be completed")))
        }
        ),
        G(A, al.EventType.MESSAGE, J => {
            var ne;
            if (!V) {
                const se = J.data[0];
                lt(!!se, 16349);
                const le = se
                  , ue = (le == null ? void 0 : le.error) || ((ne = le[0]) === null || ne === void 0 ? void 0 : ne.error);
                if (ue) {
                    he(Kt, `RPC '${e}' stream ${o} received error:`, ue);
                    const fe = ue.status;
                    let Ie = function(M) {
                        const P = vt[M];
                        if (P !== void 0)
                            return Cb(P)
                    }(fe)
                      , U = ue.message;
                    Ie === void 0 && (Ie = te.INTERNAL,
                    U = "Unknown error status: " + fe + " with message " + ue.message),
                    V = !0,
                    q.r_(new Ee(Ie,U)),
                    A.close()
                } else
                    he(Kt, `RPC '${e}' stream ${o} received:`, se),
                    q.i_(se)
            }
        }
        ),
        G(d, _E.STAT_EVENT, J => {
            J.stat === Od.PROXY ? he(Kt, `RPC '${e}' stream ${o} detected buffering proxy`) : J.stat === Od.NOPROXY && he(Kt, `RPC '${e}' stream ${o} detected no buffering proxy`)
        }
        ),
        setTimeout( () => {
            q.n_()
        }
        , 0),
        q
    }
}
function Ad() {
    return typeof document < "u" ? document : null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function tf(r) {
    return new Rb(r,!0)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class r0 {
    constructor(e, t, s=1e3, o=1.5, l=6e4) {
        this.bi = e,
        this.timerId = t,
        this.u_ = s,
        this.c_ = o,
        this.l_ = l,
        this.h_ = 0,
        this.P_ = null,
        this.T_ = Date.now(),
        this.reset()
    }
    reset() {
        this.h_ = 0
    }
    I_() {
        this.h_ = this.l_
    }
    E_(e) {
        this.cancel();
        const t = Math.floor(this.h_ + this.d_())
          , s = Math.max(0, Date.now() - this.T_)
          , o = Math.max(0, t - s);
        o > 0 && he("ExponentialBackoff", `Backing off for ${o} ms (base delay: ${this.h_} ms, delay with jitter: ${t} ms, last attempt: ${s} ms ago)`),
        this.P_ = this.bi.enqueueAfterDelay(this.timerId, o, () => (this.T_ = Date.now(),
        e())),
        this.h_ *= this.c_,
        this.h_ < this.u_ && (this.h_ = this.u_),
        this.h_ > this.l_ && (this.h_ = this.l_)
    }
    A_() {
        this.P_ !== null && (this.P_.skipDelay(),
        this.P_ = null)
    }
    cancel() {
        this.P_ !== null && (this.P_.cancel(),
        this.P_ = null)
    }
    d_() {
        return (Math.random() - .5) * this.h_
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const a_ = "PersistentStream";
class yD {
    constructor(e, t, s, o, l, f, d, v) {
        this.bi = e,
        this.R_ = s,
        this.V_ = o,
        this.connection = l,
        this.authCredentialsProvider = f,
        this.appCheckCredentialsProvider = d,
        this.listener = v,
        this.state = 0,
        this.m_ = 0,
        this.f_ = null,
        this.g_ = null,
        this.stream = null,
        this.p_ = 0,
        this.y_ = new r0(e,t)
    }
    w_() {
        return this.state === 1 || this.state === 5 || this.b_()
    }
    b_() {
        return this.state === 2 || this.state === 3
    }
    start() {
        this.p_ = 0,
        this.state !== 4 ? this.auth() : this.S_()
    }
    async stop() {
        this.w_() && await this.close(0)
    }
    D_() {
        this.state = 0,
        this.y_.reset()
    }
    v_() {
        this.b_() && this.f_ === null && (this.f_ = this.bi.enqueueAfterDelay(this.R_, 6e4, () => this.C_()))
    }
    F_(e) {
        this.M_(),
        this.stream.send(e)
    }
    async C_() {
        if (this.b_())
            return this.close(0)
    }
    M_() {
        this.f_ && (this.f_.cancel(),
        this.f_ = null)
    }
    x_() {
        this.g_ && (this.g_.cancel(),
        this.g_ = null)
    }
    async close(e, t) {
        this.M_(),
        this.x_(),
        this.y_.cancel(),
        this.m_++,
        e !== 4 ? this.y_.reset() : t && t.code === te.RESOURCE_EXHAUSTED ? (xs(t.toString()),
        xs("Using maximum backoff delay to prevent overloading the backend."),
        this.y_.I_()) : t && t.code === te.UNAUTHENTICATED && this.state !== 3 && (this.authCredentialsProvider.invalidateToken(),
        this.appCheckCredentialsProvider.invalidateToken()),
        this.stream !== null && (this.O_(),
        this.stream.close(),
        this.stream = null),
        this.state = e,
        await this.listener.Zo(t)
    }
    O_() {}
    auth() {
        this.state = 1;
        const e = this.N_(this.m_)
          , t = this.m_;
        Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then( ([s,o]) => {
            this.m_ === t && this.B_(s, o)
        }
        , s => {
            e( () => {
                const o = new Ee(te.UNKNOWN,"Fetching auth token failed: " + s.message);
                return this.L_(o)
            }
            )
        }
        )
    }
    B_(e, t) {
        const s = this.N_(this.m_);
        this.stream = this.k_(e, t),
        this.stream.jo( () => {
            s( () => this.listener.jo())
        }
        ),
        this.stream.Jo( () => {
            s( () => (this.state = 2,
            this.g_ = this.bi.enqueueAfterDelay(this.V_, 1e4, () => (this.b_() && (this.state = 3),
            Promise.resolve())),
            this.listener.Jo()))
        }
        ),
        this.stream.Zo(o => {
            s( () => this.L_(o))
        }
        ),
        this.stream.onMessage(o => {
            s( () => ++this.p_ == 1 ? this.q_(o) : this.onNext(o))
        }
        )
    }
    S_() {
        this.state = 5,
        this.y_.E_(async () => {
            this.state = 0,
            this.start()
        }
        )
    }
    L_(e) {
        return he(a_, `close with error: ${e}`),
        this.stream = null,
        this.close(4, e)
    }
    N_(e) {
        return t => {
            this.bi.enqueueAndForget( () => this.m_ === e ? t() : (he(a_, "stream callback skipped by getCloseGuardedDispatcher."),
            Promise.resolve()))
        }
    }
}
class vD extends yD {
    constructor(e, t, s, o, l, f) {
        super(e, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", t, s, o, f),
        this.serializer = l
    }
    get W_() {
        return this.p_ > 0
    }
    start() {
        this.lastStreamToken = void 0,
        super.start()
    }
    O_() {
        this.W_ && this.G_([])
    }
    k_(e, t) {
        return this.connection.a_("Write", e, t)
    }
    q_(e) {
        return lt(!!e.streamToken, 31322),
        this.lastStreamToken = e.streamToken,
        lt(!e.writeResults || e.writeResults.length === 0, 55816),
        this.listener.z_()
    }
    onNext(e) {
        lt(!!e.streamToken, 12678),
        this.lastStreamToken = e.streamToken,
        this.y_.reset();
        const t = Pb(e.writeResults, e.commitTime)
          , s = Uo(e.commitTime);
        return this.listener.j_(s, t)
    }
    H_() {
        const e = {};
        e.database = Mb(this.serializer),
        this.F_(e)
    }
    G_(e) {
        const t = {
            streamToken: this.lastStreamToken,
            writes: e.map(s => xb(this.serializer, s))
        };
        this.F_(t)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _D {
}
class TD extends _D {
    constructor(e, t, s, o) {
        super(),
        this.authCredentials = e,
        this.appCheckCredentials = t,
        this.connection = s,
        this.serializer = o,
        this.J_ = !1
    }
    Y_() {
        if (this.J_)
            throw new Ee(te.FAILED_PRECONDITION,"The client has already been terminated.")
    }
    Qo(e, t, s, o) {
        return this.Y_(),
        Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then( ([l,f]) => this.connection.Qo(e, Fd(t, s), o, l, f)).catch(l => {
            throw l.name === "FirebaseError" ? (l.code === te.UNAUTHENTICATED && (this.authCredentials.invalidateToken(),
            this.appCheckCredentials.invalidateToken()),
            l) : new Ee(te.UNKNOWN,l.toString())
        }
        )
    }
    Wo(e, t, s, o, l) {
        return this.Y_(),
        Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then( ([f,d]) => this.connection.Wo(e, Fd(t, s), o, f, d, l)).catch(f => {
            throw f.name === "FirebaseError" ? (f.code === te.UNAUTHENTICATED && (this.authCredentials.invalidateToken(),
            this.appCheckCredentials.invalidateToken()),
            f) : new Ee(te.UNKNOWN,f.toString())
        }
        )
    }
    terminate() {
        this.J_ = !0,
        this.connection.terminate()
    }
}
class ED {
    constructor(e, t) {
        this.asyncQueue = e,
        this.onlineStateHandler = t,
        this.state = "Unknown",
        this.Z_ = 0,
        this.X_ = null,
        this.ea = !0
    }
    ta() {
        this.Z_ === 0 && (this.na("Unknown"),
        this.X_ = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.X_ = null,
        this.ra("Backend didn't respond within 10 seconds."),
        this.na("Offline"),
        Promise.resolve())))
    }
    ia(e) {
        this.state === "Online" ? this.na("Unknown") : (this.Z_++,
        this.Z_ >= 1 && (this.sa(),
        this.ra(`Connection failed 1 times. Most recent error: ${e.toString()}`),
        this.na("Offline")))
    }
    set(e) {
        this.sa(),
        this.Z_ = 0,
        e === "Online" && (this.ea = !1),
        this.na(e)
    }
    na(e) {
        e !== this.state && (this.state = e,
        this.onlineStateHandler(e))
    }
    ra(e) {
        const t = `Could not reach Cloud Firestore backend. ${e}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
        this.ea ? (xs(t),
        this.ea = !1) : he("OnlineStateTracker", t)
    }
    sa() {
        this.X_ !== null && (this.X_.cancel(),
        this.X_ = null)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Nl = "RemoteStore";
class SD {
    constructor(e, t, s, o, l) {
        this.localStore = e,
        this.datastore = t,
        this.asyncQueue = s,
        this.remoteSyncer = {},
        this.oa = [],
        this._a = new Map,
        this.aa = new Set,
        this.ua = [],
        this.ca = l,
        this.ca.vo(f => {
            s.enqueueAndForget(async () => {
                Pl(this) && (he(Nl, "Restarting streams for network reachability change."),
                await async function(v) {
                    const y = et(v);
                    y.aa.add(4),
                    await xl(y),
                    y.la.set("Unknown"),
                    y.aa.delete(4),
                    await nf(y)
                }(this))
            }
            )
        }
        ),
        this.la = new ED(s,o)
    }
}
async function nf(r) {
    if (Pl(r))
        for (const e of r.ua)
            await e(!0)
}
async function xl(r) {
    for (const e of r.ua)
        await e(!1)
}
function Pl(r) {
    return et(r).aa.size === 0
}
async function s0(r, e, t) {
    if (!Dl(e))
        throw e;
    r.aa.add(1),
    await xl(r),
    r.la.set("Offline"),
    t || (t = () => uD(r.localStore)),
    r.asyncQueue.enqueueRetryable(async () => {
        he(Nl, "Retrying IndexedDB access"),
        await t(),
        r.aa.delete(1),
        await nf(r)
    }
    )
}
function o0(r, e) {
    return e().catch(t => s0(r, t, e))
}
async function rf(r) {
    const e = et(r)
      , t = Nr(e);
    let s = e.oa.length > 0 ? e.oa[e.oa.length - 1].batchId : _p;
    for (; AD(e); )
        try {
            const o = await cD(e.localStore, s);
            if (o === null) {
                e.oa.length === 0 && t.v_();
                break
            }
            s = o.batchId,
            CD(e, o)
        } catch (o) {
            await s0(e, o)
        }
    a0(e) && l0(e)
}
function AD(r) {
    return Pl(r) && r.oa.length < 10
}
function CD(r, e) {
    r.oa.push(e);
    const t = Nr(r);
    t.b_() && t.W_ && t.G_(e.mutations)
}
function a0(r) {
    return Pl(r) && !Nr(r).w_() && r.oa.length > 0
}
function l0(r) {
    Nr(r).start()
}
async function RD(r) {
    Nr(r).H_()
}
async function ID(r) {
    const e = Nr(r);
    for (const t of r.oa)
        e.G_(t.mutations)
}
async function wD(r, e, t) {
    const s = r.oa.shift()
      , o = bp.from(s, e, t);
    await o0(r, () => r.remoteSyncer.applySuccessfulWrite(o)),
    await rf(r)
}
async function bD(r, e) {
    e && Nr(r).W_ && await async function(s, o) {
        if (function(f) {
            return Ab(f) && f !== te.ABORTED
        }(o.code)) {
            const l = s.oa.shift();
            Nr(s).D_(),
            await o0(s, () => s.remoteSyncer.rejectFailedWrite(l.batchId, o)),
            await rf(s)
        }
    }(r, e),
    a0(r) && l0(r)
}
async function l_(r, e) {
    const t = et(r);
    t.asyncQueue.verifyOperationInProgress(),
    he(Nl, "RemoteStore received new credentials");
    const s = Pl(t);
    t.aa.add(3),
    await xl(t),
    s && t.la.set("Unknown"),
    await t.remoteSyncer.handleCredentialChange(e),
    t.aa.delete(3),
    await nf(t)
}
async function DD(r, e) {
    const t = et(r);
    e ? (t.aa.delete(2),
    await nf(t)) : e || (t.aa.add(2),
    await xl(t),
    t.la.set("Unknown"))
}
function Nr(r) {
    return r.Ta || (r.Ta = function(t, s, o) {
        const l = et(t);
        return l.Y_(),
        new vD(s,l.connection,l.authCredentials,l.appCheckCredentials,l.serializer,o)
    }(r.datastore, r.asyncQueue, {
        jo: () => Promise.resolve(),
        Jo: RD.bind(null, r),
        Zo: bD.bind(null, r),
        z_: ID.bind(null, r),
        j_: wD.bind(null, r)
    }),
    r.ua.push(async e => {
        e ? (r.Ta.D_(),
        await rf(r)) : (await r.Ta.stop(),
        r.oa.length > 0 && (he(Nl, `Stopping write stream with ${r.oa.length} pending writes`),
        r.oa = []))
    }
    )),
    r.Ta
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class xp {
    constructor(e, t, s, o, l) {
        this.asyncQueue = e,
        this.timerId = t,
        this.targetTimeMs = s,
        this.op = o,
        this.removalCallback = l,
        this.deferred = new Rs,
        this.then = this.deferred.promise.then.bind(this.deferred.promise),
        this.deferred.promise.catch(f => {}
        )
    }
    get promise() {
        return this.deferred.promise
    }
    static createAndSchedule(e, t, s, o, l) {
        const f = Date.now() + s
          , d = new xp(e,t,f,o,l);
        return d.start(s),
        d
    }
    start(e) {
        this.timerHandle = setTimeout( () => this.handleDelayElapsed(), e)
    }
    skipDelay() {
        return this.handleDelayElapsed()
    }
    cancel(e) {
        this.timerHandle !== null && (this.clearTimeout(),
        this.deferred.reject(new Ee(te.CANCELLED,"Operation cancelled" + (e ? ": " + e : ""))))
    }
    handleDelayElapsed() {
        this.asyncQueue.enqueueAndForget( () => this.timerHandle !== null ? (this.clearTimeout(),
        this.op().then(e => this.deferred.resolve(e))) : Promise.resolve())
    }
    clearTimeout() {
        this.timerHandle !== null && (this.removalCallback(this),
        clearTimeout(this.timerHandle),
        this.timerHandle = null)
    }
}
function u0(r, e) {
    if (xs("AsyncQueue", `${e}: ${r}`),
    Dl(r))
        return new Ee(te.UNAVAILABLE,`${e}: ${r}`);
    throw r
}
class MD {
    constructor() {
        this.queries = u_(),
        this.onlineState = "Unknown",
        this.fa = new Set
    }
    terminate() {
        (function(t, s) {
            const o = et(t)
              , l = o.queries;
            o.queries = u_(),
            l.forEach( (f, d) => {
                for (const v of d.Ra)
                    v.onError(s)
            }
            )
        }
        )(this, new Ee(te.ABORTED,"Firestore shutting down"))
    }
}
function u_() {
    return new Vs(r => zE(r),qE)
}
function ND(r) {
    r.fa.forEach(e => {
        e.next()
    }
    )
}
var c_, f_;
(f_ = c_ || (c_ = {})).ya = "default",
f_.Cache = "cache";
const xD = "SyncEngine";
class PD {
    constructor(e, t, s, o, l, f) {
        this.localStore = e,
        this.remoteStore = t,
        this.eventManager = s,
        this.sharedClientState = o,
        this.currentUser = l,
        this.maxConcurrentLimboResolutions = f,
        this.nu = {},
        this.ru = new Vs(d => zE(d),qE),
        this.iu = new Map,
        this.su = new Set,
        this.ou = new an(Re.comparator),
        this._u = new Map,
        this.au = new Dp,
        this.uu = {},
        this.cu = new Map,
        this.lu = Fo.ir(),
        this.onlineState = "Unknown",
        this.hu = void 0
    }
    get isPrimaryClient() {
        return this.hu === !0
    }
}
async function OD(r, e, t) {
    const s = LD(r);
    try {
        const o = await function(f, d) {
            const v = et(f)
              , y = Pt.now()
              , T = d.reduce( (V, q) => V.add(q.key), $t());
            let A, I;
            return v.persistence.runTransaction("Locally write mutations", "readwrite", V => {
                let q = Lc()
                  , G = $t();
                return v.Cs.getEntries(V, T).next(J => {
                    q = J,
                    q.forEach( (ne, se) => {
                        se.isValidDocument() || (G = G.add(ne))
                    }
                    )
                }
                ).next( () => v.localDocuments.getOverlayedDocuments(V, q)).next(J => {
                    A = J;
                    const ne = [];
                    for (const se of d) {
                        const le = _b(se, A.get(se.key).overlayedDocument);
                        le != null && ne.push(new Us(se.key,le,PE(le.value.mapValue),zi.exists(!0)))
                    }
                    return v.mutationQueue.addMutationBatch(V, y, ne, d)
                }
                ).next(J => {
                    I = J;
                    const ne = J.applyToLocalDocumentSet(A, G);
                    return v.documentOverlayCache.saveOverlays(V, J.batchId, ne)
                }
                )
            }
            ).then( () => ({
                batchId: I.batchId,
                changes: HE(A)
            }))
        }(s.localStore, e);
        s.sharedClientState.addPendingMutation(o.batchId),
        function(f, d, v) {
            let y = f.uu[f.currentUser.toKey()];
            y || (y = new an(ke)),
            y = y.insert(d, v),
            f.uu[f.currentUser.toKey()] = y
        }(s, o.batchId, t),
        await sf(s, o.changes),
        await rf(s.remoteStore)
    } catch (o) {
        const l = u0(o, "Failed to persist write");
        t.reject(l)
    }
}
function h_(r, e, t) {
    const s = et(r);
    if (s.isPrimaryClient && t === 0 || !s.isPrimaryClient && t === 1) {
        const o = [];
        s.ru.forEach( (l, f) => {
            const d = f.view.ga(e);
            d.snapshot && o.push(d.snapshot)
        }
        ),
        function(f, d) {
            const v = et(f);
            v.onlineState = d;
            let y = !1;
            v.queries.forEach( (T, A) => {
                for (const I of A.Ra)
                    I.ga(d) && (y = !0)
            }
            ),
            y && ND(v)
        }(s.eventManager, e),
        o.length && s.nu.Q_(o),
        s.onlineState = e,
        s.isPrimaryClient && s.sharedClientState.setOnlineState(e)
    }
}
async function VD(r, e) {
    const t = et(r)
      , s = e.batch.batchId;
    try {
        const o = await lD(t.localStore, e);
        f0(t, s, null),
        c0(t, s),
        t.sharedClientState.updateMutationState(s, "acknowledged"),
        await sf(t, o)
    } catch (o) {
        await yp(o)
    }
}
async function UD(r, e, t) {
    const s = et(r);
    try {
        const o = await function(f, d) {
            const v = et(f);
            return v.persistence.runTransaction("Reject batch", "readwrite-primary", y => {
                let T;
                return v.mutationQueue.lookupMutationBatch(y, d).next(A => (lt(A !== null, 37113),
                T = A.keys(),
                v.mutationQueue.removeMutationBatch(y, A))).next( () => v.mutationQueue.performConsistencyCheck(y)).next( () => v.documentOverlayCache.removeOverlaysForBatchId(y, T, d)).next( () => v.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(y, T)).next( () => v.localDocuments.getDocuments(y, T))
            }
            )
        }(s.localStore, e);
        f0(s, e, t),
        c0(s, e),
        s.sharedClientState.updateMutationState(e, "rejected", t),
        await sf(s, o)
    } catch (o) {
        await yp(o)
    }
}
function c0(r, e) {
    (r.cu.get(e) || []).forEach(t => {
        t.resolve()
    }
    ),
    r.cu.delete(e)
}
function f0(r, e, t) {
    const s = et(r);
    let o = s.uu[s.currentUser.toKey()];
    if (o) {
        const l = o.get(e);
        l && (t ? l.reject(t) : l.resolve(),
        o = o.remove(e)),
        s.uu[s.currentUser.toKey()] = o
    }
}
async function sf(r, e, t) {
    const s = et(r)
      , o = []
      , l = []
      , f = [];
    s.ru.isEmpty() || (s.ru.forEach( (d, v) => {
        f.push(s.Pu(v, e, t).then(y => {
            var T;
            if ((y || t) && s.isPrimaryClient) {
                const A = y ? !y.fromCache : (T = void 0) === null || T === void 0 ? void 0 : T.current;
                s.sharedClientState.updateQueryState(v.targetId, A ? "current" : "not-current")
            }
            if (y) {
                o.push(y);
                const A = Np.Ps(v.targetId, y);
                l.push(A)
            }
        }
        ))
    }
    ),
    await Promise.all(f),
    s.nu.Q_(o),
    await async function(v, y) {
        const T = et(v);
        try {
            await T.persistence.runTransaction("notifyLocalViewChanges", "readwrite", A => Z.forEach(y, I => Z.forEach(I.ls, V => T.persistence.referenceDelegate.addReference(A, I.targetId, V)).next( () => Z.forEach(I.hs, V => T.persistence.referenceDelegate.removeReference(A, I.targetId, V)))))
        } catch (A) {
            if (!Dl(A))
                throw A;
            he(sD, "Failed to update sequence numbers: " + A)
        }
        for (const A of y) {
            const I = A.targetId;
            if (!A.fromCache) {
                const V = T.Ss.get(I)
                  , q = V.snapshotVersion
                  , G = V.withLastLimboFreeSnapshotVersion(q);
                T.Ss = T.Ss.insert(I, G)
            }
        }
    }(s.localStore, l))
}
async function kD(r, e) {
    const t = et(r);
    if (!t.currentUser.isEqual(e)) {
        he(xD, "User change. New user:", e.toKey());
        const s = await i0(t.localStore, e);
        t.currentUser = e,
        function(l, f) {
            l.cu.forEach(d => {
                d.forEach(v => {
                    v.reject(new Ee(te.CANCELLED,f))
                }
                )
            }
            ),
            l.cu.clear()
        }(t, "'waitForPendingWrites' promise is rejected due to a user change."),
        t.sharedClientState.handleUserChange(e, s.removedBatchIds, s.addedBatchIds),
        await sf(t, s.Ms)
    }
}
function LD(r) {
    const e = et(r);
    return e.remoteStore.remoteSyncer.applySuccessfulWrite = VD.bind(null, e),
    e.remoteStore.remoteSyncer.rejectFailedWrite = UD.bind(null, e),
    e
}
class Fc {
    constructor() {
        this.kind = "memory",
        this.synchronizeTabs = !1
    }
    async initialize(e) {
        this.serializer = tf(e.databaseInfo.databaseId),
        this.sharedClientState = this.Au(e),
        this.persistence = this.Ru(e),
        await this.persistence.start(),
        this.localStore = this.Vu(e),
        this.gcScheduler = this.mu(e, this.localStore),
        this.indexBackfillerScheduler = this.fu(e, this.localStore)
    }
    mu(e, t) {
        return null
    }
    fu(e, t) {
        return null
    }
    Vu(e) {
        return aD(this.persistence, new rD, e.initialUser, this.serializer)
    }
    Ru(e) {
        return new n0(Mp.Ei,this.serializer)
    }
    Au(e) {
        return new fD
    }
    async terminate() {
        var e, t;
        (e = this.gcScheduler) === null || e === void 0 || e.stop(),
        (t = this.indexBackfillerScheduler) === null || t === void 0 || t.stop(),
        this.sharedClientState.shutdown(),
        await this.persistence.shutdown()
    }
}
Fc.provider = {
    build: () => new Fc
};
class BD extends Fc {
    constructor(e) {
        super(),
        this.cacheSizeBytes = e
    }
    mu(e, t) {
        lt(this.persistence.referenceDelegate instanceof zc, 46915);
        const s = this.persistence.referenceDelegate.garbageCollector;
        return new Hb(s,e.asyncQueue,t)
    }
    Ru(e) {
        const t = this.cacheSizeBytes !== void 0 ? sn.withCacheSize(this.cacheSizeBytes) : sn.DEFAULT;
        return new n0(s => zc.Ei(s, t),this.serializer)
    }
}
class Yd {
    async initialize(e, t) {
        this.localStore || (this.localStore = e.localStore,
        this.sharedClientState = e.sharedClientState,
        this.datastore = this.createDatastore(t),
        this.remoteStore = this.createRemoteStore(t),
        this.eventManager = this.createEventManager(t),
        this.syncEngine = this.createSyncEngine(t, !e.synchronizeTabs),
        this.sharedClientState.onlineStateHandler = s => h_(this.syncEngine, s, 1),
        this.remoteStore.remoteSyncer.handleCredentialChange = kD.bind(null, this.syncEngine),
        await DD(this.remoteStore, this.syncEngine.isPrimaryClient))
    }
    createEventManager(e) {
        return function() {
            return new MD
        }()
    }
    createDatastore(e) {
        const t = tf(e.databaseInfo.databaseId)
          , s = function(l) {
            return new gD(l)
        }(e.databaseInfo);
        return function(l, f, d, v) {
            return new TD(l,f,d,v)
        }(e.authCredentials, e.appCheckCredentials, s, t)
    }
    createRemoteStore(e) {
        return function(s, o, l, f, d) {
            return new SD(s,o,l,f,d)
        }(this.localStore, this.datastore, e.asyncQueue, t => h_(this.syncEngine, t, 0), function() {
            return o_.C() ? new o_ : new hD
        }())
    }
    createSyncEngine(e, t) {
        return function(o, l, f, d, v, y, T) {
            const A = new PD(o,l,f,d,v,y);
            return T && (A.hu = !0),
            A
        }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, e.initialUser, e.maxConcurrentLimboResolutions, t)
    }
    async terminate() {
        var e, t;
        await async function(o) {
            const l = et(o);
            he(Nl, "RemoteStore shutting down."),
            l.aa.add(5),
            await xl(l),
            l.ca.shutdown(),
            l.la.set("Unknown")
        }(this.remoteStore),
        (e = this.datastore) === null || e === void 0 || e.terminate(),
        (t = this.eventManager) === null || t === void 0 || t.terminate()
    }
}
Yd.provider = {
    build: () => new Yd
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const xr = "FirestoreClient";
class qD {
    constructor(e, t, s, o, l) {
        this.authCredentials = e,
        this.appCheckCredentials = t,
        this.asyncQueue = s,
        this.databaseInfo = o,
        this.user = Qt.UNAUTHENTICATED,
        this.clientId = CE.newId(),
        this.authCredentialListener = () => Promise.resolve(),
        this.appCheckCredentialListener = () => Promise.resolve(),
        this._uninitializedComponentsProvider = l,
        this.authCredentials.start(s, async f => {
            he(xr, "Received user=", f.uid),
            await this.authCredentialListener(f),
            this.user = f
        }
        ),
        this.appCheckCredentials.start(s, f => (he(xr, "Received new app check token=", f),
        this.appCheckCredentialListener(f, this.user)))
    }
    get configuration() {
        return {
            asyncQueue: this.asyncQueue,
            databaseInfo: this.databaseInfo,
            clientId: this.clientId,
            authCredentials: this.authCredentials,
            appCheckCredentials: this.appCheckCredentials,
            initialUser: this.user,
            maxConcurrentLimboResolutions: 100
        }
    }
    setCredentialChangeListener(e) {
        this.authCredentialListener = e
    }
    setAppCheckTokenChangeListener(e) {
        this.appCheckCredentialListener = e
    }
    terminate() {
        this.asyncQueue.enterRestrictedMode();
        const e = new Rs;
        return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
            try {
                this._onlineComponents && await this._onlineComponents.terminate(),
                this._offlineComponents && await this._offlineComponents.terminate(),
                this.authCredentials.shutdown(),
                this.appCheckCredentials.shutdown(),
                e.resolve()
            } catch (t) {
                const s = u0(t, "Failed to shutdown persistence");
                e.reject(s)
            }
        }
        ),
        e.promise
    }
}
async function Cd(r, e) {
    r.asyncQueue.verifyOperationInProgress(),
    he(xr, "Initializing OfflineComponentProvider");
    const t = r.configuration;
    await e.initialize(t);
    let s = t.initialUser;
    r.setCredentialChangeListener(async o => {
        s.isEqual(o) || (await i0(e.localStore, o),
        s = o)
    }
    ),
    e.persistence.setDatabaseDeletedListener( () => r.terminate()),
    r._offlineComponents = e
}
async function d_(r, e) {
    r.asyncQueue.verifyOperationInProgress();
    const t = await zD(r);
    he(xr, "Initializing OnlineComponentProvider"),
    await e.initialize(t, r.configuration),
    r.setCredentialChangeListener(s => l_(e.remoteStore, s)),
    r.setAppCheckTokenChangeListener( (s, o) => l_(e.remoteStore, o)),
    r._onlineComponents = e
}
async function zD(r) {
    if (!r._offlineComponents)
        if (r._uninitializedComponentsProvider) {
            he(xr, "Using user provided OfflineComponentProvider");
            try {
                await Cd(r, r._uninitializedComponentsProvider._offline)
            } catch (e) {
                const t = e;
                if (!function(o) {
                    return o.name === "FirebaseError" ? o.code === te.FAILED_PRECONDITION || o.code === te.UNIMPLEMENTED : !(typeof DOMException < "u" && o instanceof DOMException) || o.code === 22 || o.code === 20 || o.code === 11
                }(t))
                    throw t;
                jc("Error using user provided cache. Falling back to memory cache: " + t),
                await Cd(r, new Fc)
            }
        } else
            he(xr, "Using default OfflineComponentProvider"),
            await Cd(r, new BD(void 0));
    return r._offlineComponents
}
async function FD(r) {
    return r._onlineComponents || (r._uninitializedComponentsProvider ? (he(xr, "Using user provided OnlineComponentProvider"),
    await d_(r, r._uninitializedComponentsProvider._online)) : (he(xr, "Using default OnlineComponentProvider"),
    await d_(r, new Yd))),
    r._onlineComponents
}
function HD(r) {
    return FD(r).then(e => e.syncEngine)
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function h0(r) {
    const e = {};
    return r.timeoutSeconds !== void 0 && (e.timeoutSeconds = r.timeoutSeconds),
    e
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const p_ = new Map;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function GD(r, e, t) {
    if (!t)
        throw new Ee(te.INVALID_ARGUMENT,`Function ${r}() cannot be called with an empty ${e}.`)
}
function YD(r, e, t, s) {
    if (e === !0 && s === !0)
        throw new Ee(te.INVALID_ARGUMENT,`${r} and ${t} cannot be used together.`)
}
function m_(r) {
    if (!Re.isDocumentKey(r))
        throw new Ee(te.INVALID_ARGUMENT,`Invalid document reference. Document references must have an even number of segments, but ${r} has ${r.length}.`)
}
function Pp(r) {
    if (r === void 0)
        return "undefined";
    if (r === null)
        return "null";
    if (typeof r == "string")
        return r.length > 20 && (r = `${r.substring(0, 20)}...`),
        JSON.stringify(r);
    if (typeof r == "number" || typeof r == "boolean")
        return "" + r;
    if (typeof r == "object") {
        if (r instanceof Array)
            return "an array";
        {
            const e = function(s) {
                return s.constructor ? s.constructor.name : null
            }(r);
            return e ? `a custom ${e} object` : "an object"
        }
    }
    return typeof r == "function" ? "a function" : De(12329, {
        type: typeof r
    })
}
function Kd(r, e) {
    if ("_delegate"in r && (r = r._delegate),
    !(r instanceof e)) {
        if (e.name === r.constructor.name)
            throw new Ee(te.INVALID_ARGUMENT,"Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
        {
            const t = Pp(r);
            throw new Ee(te.INVALID_ARGUMENT,`Expected type '${e.name}', but it was: ${t}`)
        }
    }
    return r
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const d0 = "firestore.googleapis.com"
  , g_ = !0;
class y_ {
    constructor(e) {
        var t, s;
        if (e.host === void 0) {
            if (e.ssl !== void 0)
                throw new Ee(te.INVALID_ARGUMENT,"Can't provide ssl option if host option is not set");
            this.host = d0,
            this.ssl = g_
        } else
            this.host = e.host,
            this.ssl = (t = e.ssl) !== null && t !== void 0 ? t : g_;
        if (this.credentials = e.credentials,
        this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties,
        this.localCache = e.localCache,
        e.cacheSizeBytes === void 0)
            this.cacheSizeBytes = t0;
        else {
            if (e.cacheSizeBytes !== -1 && e.cacheSizeBytes < zb)
                throw new Ee(te.INVALID_ARGUMENT,"cacheSizeBytes must be at least 1048576");
            this.cacheSizeBytes = e.cacheSizeBytes
        }
        YD("experimentalForceLongPolling", e.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e.experimentalAutoDetectLongPolling),
        this.experimentalForceLongPolling = !!e.experimentalForceLongPolling,
        this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = !1 : e.experimentalAutoDetectLongPolling === void 0 ? this.experimentalAutoDetectLongPolling = !0 : this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling,
        this.experimentalLongPollingOptions = h0((s = e.experimentalLongPollingOptions) !== null && s !== void 0 ? s : {}),
        function(l) {
            if (l.timeoutSeconds !== void 0) {
                if (isNaN(l.timeoutSeconds))
                    throw new Ee(te.INVALID_ARGUMENT,`invalid long polling timeout: ${l.timeoutSeconds} (must not be NaN)`);
                if (l.timeoutSeconds < 5)
                    throw new Ee(te.INVALID_ARGUMENT,`invalid long polling timeout: ${l.timeoutSeconds} (minimum allowed value is 5)`);
                if (l.timeoutSeconds > 30)
                    throw new Ee(te.INVALID_ARGUMENT,`invalid long polling timeout: ${l.timeoutSeconds} (maximum allowed value is 30)`)
            }
        }(this.experimentalLongPollingOptions),
        this.useFetchStreams = !!e.useFetchStreams
    }
    isEqual(e) {
        return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && function(s, o) {
            return s.timeoutSeconds === o.timeoutSeconds
        }(this.experimentalLongPollingOptions, e.experimentalLongPollingOptions) && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams
    }
}
class Op {
    constructor(e, t, s, o) {
        this._authCredentials = e,
        this._appCheckCredentials = t,
        this._databaseId = s,
        this._app = o,
        this.type = "firestore-lite",
        this._persistenceKey = "(lite)",
        this._settings = new y_({}),
        this._settingsFrozen = !1,
        this._emulatorOptions = {},
        this._terminateTask = "notTerminated"
    }
    get app() {
        if (!this._app)
            throw new Ee(te.FAILED_PRECONDITION,"Firestore was not initialized using the Firebase SDK. 'app' is not available");
        return this._app
    }
    get _initialized() {
        return this._settingsFrozen
    }
    get _terminated() {
        return this._terminateTask !== "notTerminated"
    }
    _setSettings(e) {
        if (this._settingsFrozen)
            throw new Ee(te.FAILED_PRECONDITION,"Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
        this._settings = new y_(e),
        this._emulatorOptions = e.emulatorOptions || {},
        e.credentials !== void 0 && (this._authCredentials = function(s) {
            if (!s)
                return new Ew;
            switch (s.type) {
            case "firstParty":
                return new Rw(s.sessionIndex || "0",s.iamToken || null,s.authTokenFactory || null);
            case "provider":
                return s.client;
            default:
                throw new Ee(te.INVALID_ARGUMENT,"makeAuthCredentialsProvider failed due to invalid credential type")
            }
        }(e.credentials))
    }
    _getSettings() {
        return this._settings
    }
    _getEmulatorOptions() {
        return this._emulatorOptions
    }
    _freezeSettings() {
        return this._settingsFrozen = !0,
        this._settings
    }
    _delete() {
        return this._terminateTask === "notTerminated" && (this._terminateTask = this._terminate()),
        this._terminateTask
    }
    async _restart() {
        this._terminateTask === "notTerminated" ? await this._terminate() : this._terminateTask = "notTerminated"
    }
    toJSON() {
        return {
            app: this._app,
            databaseId: this._databaseId,
            settings: this._settings
        }
    }
    _terminate() {
        return function(t) {
            const s = p_.get(t);
            s && (he("ComponentProvider", "Removing Datastore"),
            p_.delete(t),
            s.terminate())
        }(this),
        Promise.resolve()
    }
}
function KD(r, e, t, s={}) {
    var o;
    const l = (r = Kd(r, Op))._getSettings()
      , f = Object.assign(Object.assign({}, l), {
        emulatorOptions: r._getEmulatorOptions()
    })
      , d = `${e}:${t}`;
    l.host !== d0 && l.host !== d && jc("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used.");
    const v = Object.assign(Object.assign({}, l), {
        host: d,
        ssl: !1,
        emulatorOptions: s
    });
    if (!ws(v, f) && (r._setSettings(v),
    s.mockUserToken)) {
        let y, T;
        if (typeof s.mockUserToken == "string")
            y = s.mockUserToken,
            T = Qt.MOCK_USER;
        else {
            y = xA(s.mockUserToken, (o = r._app) === null || o === void 0 ? void 0 : o.options.projectId);
            const A = s.mockUserToken.sub || s.mockUserToken.user_id;
            if (!A)
                throw new Ee(te.INVALID_ARGUMENT,"mockUserToken must contain 'sub' or 'user_id' field!");
            T = new Qt(A)
        }
        r._authCredentials = new Sw(new AE(y,T))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Vp {
    constructor(e, t, s) {
        this.converter = t,
        this._query = s,
        this.type = "query",
        this.firestore = e
    }
    withConverter(e) {
        return new Vp(this.firestore,e,this._query)
    }
}
class Fi {
    constructor(e, t, s) {
        this.converter = t,
        this._key = s,
        this.type = "document",
        this.firestore = e
    }
    get _path() {
        return this._key.path
    }
    get id() {
        return this._key.path.lastSegment()
    }
    get path() {
        return this._key.path.canonicalString()
    }
    get parent() {
        return new Tl(this.firestore,this.converter,this._key.path.popLast())
    }
    withConverter(e) {
        return new Fi(this.firestore,e,this._key)
    }
}
class Tl extends Vp {
    constructor(e, t, s) {
        super(e, t, ib(s)),
        this._path = s,
        this.type = "collection"
    }
    get id() {
        return this._query.path.lastSegment()
    }
    get path() {
        return this._query.path.canonicalString()
    }
    get parent() {
        const e = this._path.popLast();
        return e.isEmpty() ? null : new Fi(this.firestore,null,new Re(e))
    }
    withConverter(e) {
        return new Tl(this.firestore,e,this._path)
    }
}
function v_(r, e, ...t) {
    if (r = vn(r),
    arguments.length === 1 && (e = CE.newId()),
    GD("doc", "path", e),
    r instanceof Op) {
        const s = _t.fromString(e, ...t);
        return m_(s),
        new Fi(r,null,new Re(s))
    }
    {
        if (!(r instanceof Fi || r instanceof Tl))
            throw new Ee(te.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
        const s = r._path.child(_t.fromString(e, ...t));
        return m_(s),
        new Fi(r.firestore,r instanceof Tl ? r.converter : null,new Re(s))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const __ = "AsyncQueue";
class T_ {
    constructor(e=Promise.resolve()) {
        this.Qu = [],
        this.$u = !1,
        this.Uu = [],
        this.Ku = null,
        this.Wu = !1,
        this.Gu = !1,
        this.zu = [],
        this.y_ = new r0(this,"async_queue_retry"),
        this.ju = () => {
            const s = Ad();
            s && he(__, "Visibility state changed to " + s.visibilityState),
            this.y_.A_()
        }
        ,
        this.Hu = e;
        const t = Ad();
        t && typeof t.addEventListener == "function" && t.addEventListener("visibilitychange", this.ju)
    }
    get isShuttingDown() {
        return this.$u
    }
    enqueueAndForget(e) {
        this.enqueue(e)
    }
    enqueueAndForgetEvenWhileRestricted(e) {
        this.Ju(),
        this.Yu(e)
    }
    enterRestrictedMode(e) {
        if (!this.$u) {
            this.$u = !0,
            this.Gu = e || !1;
            const t = Ad();
            t && typeof t.removeEventListener == "function" && t.removeEventListener("visibilitychange", this.ju)
        }
    }
    enqueue(e) {
        if (this.Ju(),
        this.$u)
            return new Promise( () => {}
            );
        const t = new Rs;
        return this.Yu( () => this.$u && this.Gu ? Promise.resolve() : (e().then(t.resolve, t.reject),
        t.promise)).then( () => t.promise)
    }
    enqueueRetryable(e) {
        this.enqueueAndForget( () => (this.Qu.push(e),
        this.Zu()))
    }
    async Zu() {
        if (this.Qu.length !== 0) {
            try {
                await this.Qu[0](),
                this.Qu.shift(),
                this.y_.reset()
            } catch (e) {
                if (!Dl(e))
                    throw e;
                he(__, "Operation failed with retryable error: " + e)
            }
            this.Qu.length > 0 && this.y_.E_( () => this.Zu())
        }
    }
    Yu(e) {
        const t = this.Hu.then( () => (this.Wu = !0,
        e().catch(s => {
            throw this.Ku = s,
            this.Wu = !1,
            xs("INTERNAL UNHANDLED ERROR: ", E_(s)),
            s
        }
        ).then(s => (this.Wu = !1,
        s))));
        return this.Hu = t,
        t
    }
    enqueueAfterDelay(e, t, s) {
        this.Ju(),
        this.zu.indexOf(e) > -1 && (t = 0);
        const o = xp.createAndSchedule(this, e, t, s, l => this.Xu(l));
        return this.Uu.push(o),
        o
    }
    Ju() {
        this.Ku && De(47125, {
            ec: E_(this.Ku)
        })
    }
    verifyOperationInProgress() {}
    async tc() {
        let e;
        do
            e = this.Hu,
            await e;
        while (e !== this.Hu)
    }
    nc(e) {
        for (const t of this.Uu)
            if (t.timerId === e)
                return !0;
        return !1
    }
    rc(e) {
        return this.tc().then( () => {
            this.Uu.sort( (t, s) => t.targetTimeMs - s.targetTimeMs);
            for (const t of this.Uu)
                if (t.skipDelay(),
                e !== "all" && t.timerId === e)
                    break;
            return this.tc()
        }
        )
    }
    sc(e) {
        this.zu.push(e)
    }
    Xu(e) {
        const t = this.Uu.indexOf(e);
        this.Uu.splice(t, 1)
    }
}
function E_(r) {
    let e = r.message || "";
    return r.stack && (e = r.stack.includes(r.message) ? r.stack : r.message + `
` + r.stack),
    e
}
class p0 extends Op {
    constructor(e, t, s, o) {
        super(e, t, s, o),
        this.type = "firestore",
        this._queue = new T_,
        this._persistenceKey = (o == null ? void 0 : o.name) || "[DEFAULT]"
    }
    async _terminate() {
        if (this._firestoreClient) {
            const e = this._firestoreClient.terminate();
            this._queue = new T_(e),
            this._firestoreClient = void 0,
            await e
        }
    }
}
function QD(r, e) {
    const t = typeof r == "object" ? r : VT()
      , s = typeof r == "string" ? r : Oc
      , o = ip(t, "firestore").getImmediate({
        identifier: s
    });
    if (!o._initialized) {
        const l = MA("firestore");
        l && KD(o, ...l)
    }
    return o
}
function XD(r) {
    if (r._terminated)
        throw new Ee(te.FAILED_PRECONDITION,"The client has already been terminated.");
    return r._firestoreClient || $D(r),
    r._firestoreClient
}
function $D(r) {
    var e, t, s;
    const o = r._freezeSettings()
      , l = function(d, v, y, T) {
        return new Fw(d,v,y,T.host,T.ssl,T.experimentalForceLongPolling,T.experimentalAutoDetectLongPolling,h0(T.experimentalLongPollingOptions),T.useFetchStreams)
    }(r._databaseId, ((e = r._app) === null || e === void 0 ? void 0 : e.options.appId) || "", r._persistenceKey, o);
    r._componentsProvider || !((t = o.localCache) === null || t === void 0) && t._offlineComponentProvider && (!((s = o.localCache) === null || s === void 0) && s._onlineComponentProvider) && (r._componentsProvider = {
        _offline: o.localCache._offlineComponentProvider,
        _online: o.localCache._onlineComponentProvider
    }),
    r._firestoreClient = new qD(r._authCredentials,r._appCheckCredentials,r._queue,l,r._componentsProvider && function(d) {
        const v = d == null ? void 0 : d._online.build();
        return {
            _offline: d == null ? void 0 : d._offline.build(v),
            _online: v
        }
    }(r._componentsProvider))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class El {
    constructor(e) {
        this._byteString = e
    }
    static fromBase64String(e) {
        try {
            return new El(ui.fromBase64String(e))
        } catch (t) {
            throw new Ee(te.INVALID_ARGUMENT,"Failed to construct data from Base64 string: " + t)
        }
    }
    static fromUint8Array(e) {
        return new El(ui.fromUint8Array(e))
    }
    toBase64() {
        return this._byteString.toBase64()
    }
    toUint8Array() {
        return this._byteString.toUint8Array()
    }
    toString() {
        return "Bytes(base64: " + this.toBase64() + ")"
    }
    isEqual(e) {
        return this._byteString.isEqual(e._byteString)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class m0 {
    constructor(...e) {
        for (let t = 0; t < e.length; ++t)
            if (e[t].length === 0)
                throw new Ee(te.INVALID_ARGUMENT,"Invalid field name at argument $(i + 1). Field names must not be empty.");
        this._internalPath = new zt(e)
    }
    isEqual(e) {
        return this._internalPath.isEqual(e._internalPath)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class g0 {
    constructor(e) {
        this._methodName = e
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class y0 {
    constructor(e, t) {
        if (!isFinite(e) || e < -90 || e > 90)
            throw new Ee(te.INVALID_ARGUMENT,"Latitude must be a number between -90 and 90, but was: " + e);
        if (!isFinite(t) || t < -180 || t > 180)
            throw new Ee(te.INVALID_ARGUMENT,"Longitude must be a number between -180 and 180, but was: " + t);
        this._lat = e,
        this._long = t
    }
    get latitude() {
        return this._lat
    }
    get longitude() {
        return this._long
    }
    isEqual(e) {
        return this._lat === e._lat && this._long === e._long
    }
    toJSON() {
        return {
            latitude: this._lat,
            longitude: this._long
        }
    }
    _compareTo(e) {
        return ke(this._lat, e._lat) || ke(this._long, e._long)
    }
}
/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class v0 {
    constructor(e) {
        this._values = (e || []).map(t => t)
    }
    toArray() {
        return this._values.map(e => e)
    }
    isEqual(e) {
        return function(s, o) {
            if (s.length !== o.length)
                return !1;
            for (let l = 0; l < s.length; ++l)
                if (s[l] !== o[l])
                    return !1;
            return !0
        }(this._values, e._values)
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const JD = /^__.*__$/;
class jD {
    constructor(e, t, s) {
        this.data = e,
        this.fieldMask = t,
        this.fieldTransforms = s
    }
    toMutation(e, t) {
        return this.fieldMask !== null ? new Us(e,this.data,this.fieldMask,t,this.fieldTransforms) : new Ml(e,this.data,t,this.fieldTransforms)
    }
}
function _0(r) {
    switch (r) {
    case 0:
    case 2:
    case 1:
        return !0;
    case 3:
    case 4:
        return !1;
    default:
        throw De(40011, {
            oc: r
        })
    }
}
class Up {
    constructor(e, t, s, o, l, f) {
        this.settings = e,
        this.databaseId = t,
        this.serializer = s,
        this.ignoreUndefinedProperties = o,
        l === void 0 && this._c(),
        this.fieldTransforms = l || [],
        this.fieldMask = f || []
    }
    get path() {
        return this.settings.path
    }
    get oc() {
        return this.settings.oc
    }
    ac(e) {
        return new Up(Object.assign(Object.assign({}, this.settings), e),this.databaseId,this.serializer,this.ignoreUndefinedProperties,this.fieldTransforms,this.fieldMask)
    }
    uc(e) {
        var t;
        const s = (t = this.path) === null || t === void 0 ? void 0 : t.child(e)
          , o = this.ac({
            path: s,
            cc: !1
        });
        return o.lc(e),
        o
    }
    hc(e) {
        var t;
        const s = (t = this.path) === null || t === void 0 ? void 0 : t.child(e)
          , o = this.ac({
            path: s,
            cc: !1
        });
        return o._c(),
        o
    }
    Pc(e) {
        return this.ac({
            path: void 0,
            cc: !0
        })
    }
    Tc(e) {
        return Hc(e, this.settings.methodName, this.settings.Ic || !1, this.path, this.settings.Ec)
    }
    contains(e) {
        return this.fieldMask.find(t => e.isPrefixOf(t)) !== void 0 || this.fieldTransforms.find(t => e.isPrefixOf(t.field)) !== void 0
    }
    _c() {
        if (this.path)
            for (let e = 0; e < this.path.length; e++)
                this.lc(this.path.get(e))
    }
    lc(e) {
        if (e.length === 0)
            throw this.Tc("Document fields must not be empty");
        if (_0(this.oc) && JD.test(e))
            throw this.Tc('Document fields cannot begin and end with "__"')
    }
}
class WD {
    constructor(e, t, s) {
        this.databaseId = e,
        this.ignoreUndefinedProperties = t,
        this.serializer = s || tf(e)
    }
    dc(e, t, s, o=!1) {
        return new Up({
            oc: e,
            methodName: t,
            Ec: s,
            path: zt.emptyPath(),
            cc: !1,
            Ic: o
        },this.databaseId,this.serializer,this.ignoreUndefinedProperties)
    }
}
function ZD(r) {
    const e = r._freezeSettings()
      , t = tf(r._databaseId);
    return new WD(r._databaseId,!!e.ignoreUndefinedProperties,t)
}
function eM(r, e, t, s, o, l={}) {
    const f = r.dc(l.merge || l.mergeFields ? 2 : 0, e, t, o);
    A0("Data must be an object, but it was:", f, s);
    const d = E0(s, f);
    let v, y;
    if (l.merge)
        v = new Fn(f.fieldMask),
        y = f.fieldTransforms;
    else if (l.mergeFields) {
        const T = [];
        for (const A of l.mergeFields) {
            const I = tM(e, A, t);
            if (!f.contains(I))
                throw new Ee(te.INVALID_ARGUMENT,`Field '${I}' is specified in your field mask but missing from your input data.`);
            rM(T, I) || T.push(I)
        }
        v = new Fn(T),
        y = f.fieldTransforms.filter(A => v.covers(A.field))
    } else
        v = null,
        y = f.fieldTransforms;
    return new jD(new qn(d),v,y)
}
function T0(r, e) {
    if (S0(r = vn(r)))
        return A0("Unsupported field value:", e, r),
        E0(r, e);
    if (r instanceof g0)
        return function(s, o) {
            if (!_0(o.oc))
                throw o.Tc(`${s._methodName}() can only be used with update() and set()`);
            if (!o.path)
                throw o.Tc(`${s._methodName}() is not currently supported inside arrays`);
            const l = s._toFieldTransform(o);
            l && o.fieldTransforms.push(l)
        }(r, e),
        null;
    if (r === void 0 && e.ignoreUndefinedProperties)
        return null;
    if (e.path && e.fieldMask.push(e.path),
    r instanceof Array) {
        if (e.settings.cc && e.oc !== 4)
            throw e.Tc("Nested arrays are not supported");
        return function(s, o) {
            const l = [];
            let f = 0;
            for (const d of s) {
                let v = T0(d, o.Pc(f));
                v == null && (v = {
                    nullValue: "NULL_VALUE"
                }),
                l.push(v),
                f++
            }
            return {
                arrayValue: {
                    values: l
                }
            }
        }(r, e)
    }
    return function(s, o) {
        if ((s = vn(s)) === null)
            return {
                nullValue: "NULL_VALUE"
            };
        if (typeof s == "number")
            return db(o.serializer, s);
        if (typeof s == "boolean")
            return {
                booleanValue: s
            };
        if (typeof s == "string")
            return {
                stringValue: s
            };
        if (s instanceof Date) {
            const l = Pt.fromDate(s);
            return {
                timestampValue: zd(o.serializer, l)
            }
        }
        if (s instanceof Pt) {
            const l = new Pt(s.seconds,1e3 * Math.floor(s.nanoseconds / 1e3));
            return {
                timestampValue: zd(o.serializer, l)
            }
        }
        if (s instanceof y0)
            return {
                geoPointValue: {
                    latitude: s.latitude,
                    longitude: s.longitude
                }
            };
        if (s instanceof El)
            return {
                bytesValue: Ib(o.serializer, s._byteString)
            };
        if (s instanceof Fi) {
            const l = o.databaseId
              , f = s.firestore._databaseId;
            if (!f.isEqual(l))
                throw o.Tc(`Document reference is for database ${f.projectId}/${f.database} but should be for database ${l.projectId}/${l.database}`);
            return {
                referenceValue: ZE(s.firestore._databaseId || o.databaseId, s._key.path)
            }
        }
        if (s instanceof v0)
            return function(f, d) {
                return {
                    mapValue: {
                        fields: {
                            [NE]: {
                                stringValue: xE
                            },
                            [Ud]: {
                                arrayValue: {
                                    values: f.toArray().map(y => {
                                        if (typeof y != "number")
                                            throw d.Tc("VectorValues must only contain numeric values.");
                                        return wp(d.serializer, y)
                                    }
                                    )
                                }
                            }
                        }
                    }
                }
            }(s, o);
        throw o.Tc(`Unsupported field value: ${Pp(s)}`)
    }(r, e)
}
function E0(r, e) {
    const t = {};
    return IE(r) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : Ko(r, (s, o) => {
        const l = T0(o, e.uc(s));
        l != null && (t[s] = l)
    }
    ),
    {
        mapValue: {
            fields: t
        }
    }
}
function S0(r) {
    return !(typeof r != "object" || r === null || r instanceof Array || r instanceof Date || r instanceof Pt || r instanceof y0 || r instanceof El || r instanceof Fi || r instanceof g0 || r instanceof v0)
}
function A0(r, e, t) {
    if (!S0(t) || !function(o) {
        return typeof o == "object" && o !== null && (Object.getPrototypeOf(o) === Object.prototype || Object.getPrototypeOf(o) === null)
    }(t)) {
        const s = Pp(t);
        throw s === "an object" ? e.Tc(r + " a custom object") : e.Tc(r + " " + s)
    }
}
function tM(r, e, t) {
    if ((e = vn(e))instanceof m0)
        return e._internalPath;
    if (typeof e == "string")
        return iM(r, e);
    throw Hc("Field path arguments must be of type string or ", r, !1, void 0, t)
}
const nM = new RegExp("[~\\*/\\[\\]]");
function iM(r, e, t) {
    if (e.search(nM) >= 0)
        throw Hc(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, r, !1, void 0, t);
    try {
        return new m0(...e.split("."))._internalPath
    } catch {
        throw Hc(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, r, !1, void 0, t)
    }
}
function Hc(r, e, t, s, o) {
    const l = s && !s.isEmpty()
      , f = o !== void 0;
    let d = `Function ${e}() called with invalid data`;
    t && (d += " (via `toFirestore()`)"),
    d += ". ";
    let v = "";
    return (l || f) && (v += " (found",
    l && (v += ` in field ${s}`),
    f && (v += ` in document ${o}`),
    v += ")"),
    new Ee(te.INVALID_ARGUMENT,d + r + v)
}
function rM(r, e) {
    return r.some(t => t.isEqual(e))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function sM(r, e, t) {
    let s;
    return s = r ? t && (t.merge || t.mergeFields) ? r.toFirestore(e, t) : r.toFirestore(e) : e,
    s
}
function S_(r, e, t) {
    r = Kd(r, Fi);
    const s = Kd(r.firestore, p0)
      , o = sM(r.converter, e, t);
    return oM(s, [eM(ZD(s), "setDoc", r._key, o, r.converter !== null, t).toMutation(r._key, zi.none())])
}
function oM(r, e) {
    return function(s, o) {
        const l = new Rs;
        return s.asyncQueue.enqueueAndForget(async () => OD(await HD(s), o, l)),
        l.promise
    }(XD(r), e)
}
(function(e, t=!0) {
    (function(o) {
        Yo = o
    }
    )(Ho),
    ko(new bs("firestore", (s, {instanceIdentifier: o, options: l}) => {
        const f = s.getProvider("app").getImmediate()
          , d = new p0(new Aw(s.getProvider("auth-internal")),new Iw(f,s.getProvider("app-check-internal")),function(y, T) {
            if (!Object.prototype.hasOwnProperty.apply(y.options, ["projectId"]))
                throw new Ee(te.INVALID_ARGUMENT,'"projectId" not provided in firebase.initializeApp.');
            return new Vc(y.options.projectId,T)
        }(f, o),f);
        return l = Object.assign({
            useFetchStreams: t
        }, l),
        d._setSettings(l),
        d
    }
    ,"PUBLIC").setMultipleInstances(!0)),
    br(Ov, Vv, e),
    br(Ov, Vv, "esm2017")
}
)();
const aM = {
    apiKey: "AIzaSyBmti6Fzdh97bxAJbU5XO4DAZE1k8Y3B2E",
    authDomain: "doctor-finder-2a4c6.firebaseapp.com",
    projectId: "doctor-finder-2a4c6",
    storageBucket: "doctor-finder-2a4c6.firebasestorage.app",
    messagingSenderId: "277476491962",
    appId: "1:277476491962:web:aa082716189eb4e07ab883",
    measurementId: "G-H6E1E311G4"
}
  , C0 = OT(aM)
  , xo = _w(C0)
  , A_ = QD(C0)
  , lM = new ki
  , Yi = "" + new URL("9706583-lGG6yIvU.png",import.meta.url).href;
function uM({setPage: r}) {
    const [e,t] = dt.useState("")
      , [s,o] = dt.useState("")
      , [l,f] = dt.useState("")
      , [d,v] = dt.useState(!1)
      , [y,T] = dt.useState(null)
      , [A,I] = dt.useState("");
    dt.useEffect( () => {
        const ne = aI(xo, se => {
            T(se),
            se && r("profile")
        }
        );
        return () => ne()
    }
    , [r]);
    const V = () => {
        t(""),
        o(""),
        f(""),
        I("")
    }
      , q = async () => {
        if (I(""),
        s !== l) {
            I("Passwords do not match.");
            return
        }
        try {
            const se = (await iI(xo, e, s)).user;
            await S_(v_(A_, "users", se.uid), {
                email: se.email,
                createdAt: new Date,
                name: se.displayName
            }),
            r("profile")
        } catch (ne) {
            I(ne.message)
        }
    }
      , G = async () => {
        I("");
        try {
            await rI(xo, e, s),
            r("profile")
        } catch (ne) {
            ne.code === "auth/user-not-found" ? I("No account found with this email.") : ne.code === "auth/wrong-password" ? I("Incorrect password.") : I(ne.message)
        }
    }
      , J = async () => {
        I("");
        try {
            const se = (await bI(xo, lM)).user
              , le = v_(A_, "users", se.uid);
            await S_(le, {
                email: se.email,
                googleAccount: !0,
                createdAt: new Date
            }, {
                merge: !0
            }),
            r("profile")
        } catch (ne) {
            I(ne.message)
        }
    }
    ;
    return b.jsxs("div", {
        className: "loginContainer",
        children: [b.jsx("h1", {
            children: "Doctor Finder"
        }), A && b.jsx("p", {
            className: "error",
            children: A
        }), y ? b.jsxs("div", {
            children: [b.jsxs("h2", {
                children: ["Welcome, ", y.email]
            }), b.jsx("button", {
                onClick: () => {
                    xo.signOut(),
                    V()
                }
                ,
                children: "Sign Out"
            })]
        }) : d ? b.jsxs("div", {
            children: [b.jsx("h2", {
                children: "Register"
            }), b.jsxs("div", {
                className: "inputRow",
                children: [b.jsx("p", {
                    children: "Email:"
                }), b.jsx("input", {
                    type: "email",
                    value: e,
                    onChange: ne => t(ne.target.value)
                })]
            }), b.jsxs("div", {
                className: "inputRow",
                children: [b.jsx("p", {
                    children: "Password:"
                }), b.jsx("input", {
                    type: "password",
                    value: s,
                    onChange: ne => o(ne.target.value)
                })]
            }), b.jsxs("div", {
                className: "inputRow",
                children: [b.jsx("p", {
                    children: "Confirm Password:"
                }), b.jsx("input", {
                    type: "password",
                    value: l,
                    onChange: ne => f(ne.target.value)
                })]
            }), b.jsx("button", {
                onClick: q,
                children: "Register"
            }), b.jsxs("p", {
                children: ["Already have an account?", " ", b.jsx("button", {
                    onClick: () => {
                        v(!1),
                        V()
                    }
                    ,
                    children: "Sign in"
                })]
            }), b.jsx("button", {
                onClick: () => r("home"),
                children: "Back"
            })]
        }) : b.jsxs("div", {
            children: [b.jsx("img", {
                id: "icon",
                src: Yi,
                alt: "user icon"
            }), b.jsx("h2", {
                children: "Log In"
            }), b.jsxs("div", {
                className: "inputRow",
                children: [b.jsx("p", {
                    children: "Email:"
                }), b.jsx("input", {
                    type: "email",
                    value: e,
                    onChange: ne => t(ne.target.value)
                })]
            }), b.jsxs("div", {
                className: "inputRow",
                children: [b.jsx("p", {
                    children: "Password:"
                }), b.jsx("input", {
                    type: "password",
                    value: s,
                    onChange: ne => o(ne.target.value)
                })]
            }), b.jsx("button", {
                onClick: G,
                children: "Sign In"
            }), b.jsx("button", {
                onClick: J,
                children: "Sign in with Google"
            }), b.jsxs("p", {
                children: ["New here?", " ", b.jsx("button", {
                    onClick: () => {
                        v(!0),
                        V()
                    }
                    ,
                    children: "Register"
                })]
            }), b.jsx("button", {
                onClick: () => r("home"),
                children: "Back"
            })]
        })]
    })
}
function cM({setPage: r}) {
    const [e,t] = dt.useState(!1)
      , s = () => {
        t(!e)
    }
    ;
    return b.jsxs(b.Fragment, {
        children: [b.jsx("img", {
            src: Yi,
            className: "profile-icon",
            alt: "Profile"
        }), b.jsxs("div", {
            id: "newnavbar",
            children: [b.jsx("button", {
                onClick: s,
                children: "☰"
            }), b.jsxs("div", {
                className: `sliding-panel ${e ? "visible" : ""}`,
                children: [b.jsx("button", {
                    className: "close-panel",
                    onClick: s,
                    children: "✖"
                }), b.jsxs("ul", {
                    children: [b.jsx("li", {
                        onClick: () => r("profile"),
                        children: "Home"
                    }), b.jsx("li", {
                        onClick: () => r("dmlist"),
                        children: "DmList"
                    }), b.jsx("li", {
                        onClick: () => r("drlist"),
                        children: "DrList"
                    }), b.jsx("li", {
                        onClick: () => r("chatbox"),
                        children: "Chat"
                    }), b.jsx("li", {
                        onClick: () => r("settings"),
                        children: "Settings"
                    })]
                })]
            })]
        }), b.jsx("br", {}), b.jsx("br", {}), b.jsx("br", {}), b.jsx("br", {}), b.jsx("br", {}), b.jsx("div", {
            style: {
                marginTop: "-4em"
            },
            children: b.jsx("h2", {
                children: "Dr.Finder"
            })
        }), b.jsx("div", {
            children: b.jsxs("h1", {
                style: {
                    fontSize: "40px"
                },
                children: ["Welcome, ", b.jsx("br", {}), " Name"]
            })
        }), b.jsx("div", {
            children: b.jsx("img", {
                src: Yi,
                width: "200px",
                height: "200px",
                style: {
                    borderRadius: "50%"
                },
                alt: "Profile"
            })
        }), b.jsxs("div", {
            id: "profile-buttons",
            children: [b.jsx("button", {
                onClick: () => r("dmlist"),
                style: {
                    fontSize: "30px",
                    padding: "20px 80px",
                    borderRadius: "12px",
                    cursor: "pointer",
                    backgroundColor: "#2196F3",
                    color: "white",
                    border: "none",
                    boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)",
                    transition: "transform 0.2s, background-color 0.2s"
                },
                onMouseOver: o => o.target.style.backgroundColor = "#2881C6",
                onMouseOut: o => o.target.style.backgroundColor = "#2196F3",
                children: "DmList"
            }), b.jsx("br", {}), b.jsx("br", {}), b.jsx("button", {
                onClick: () => r("drlist"),
                style: {
                    fontSize: "30px",
                    padding: "20px 80px",
                    borderRadius: "12px",
                    cursor: "pointer",
                    backgroundColor: "#2196F3",
                    color: "white",
                    border: "none",
                    boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)",
                    transition: "transform 0.2s, background-color 0.2s"
                },
                onMouseOver: o => o.target.style.backgroundColor = "#2881C6",
                onMouseOut: o => o.target.style.backgroundColor = "#2196F3",
                children: "DrList"
            }), b.jsx("br", {}), b.jsx("br", {}), b.jsx("button", {
                onClick: () => r("chatbox"),
                style: {
                    fontSize: "30px",
                    padding: "20px 80px",
                    borderRadius: "12px",
                    cursor: "pointer",
                    backgroundColor: "#2196F3",
                    color: "white",
                    border: "none",
                    boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)",
                    transition: "transform 0.2s, background-color 0.2s"
                },
                onMouseOver: o => o.target.style.backgroundColor = "#2881C6",
                onMouseOut: o => o.target.style.backgroundColor = "#2196F3",
                children: "AI Chat"
            }), b.jsx("br", {}), b.jsx("br", {}), b.jsx("button", {
                onClick: () => r("settings"),
                style: {
                    fontSize: "30px",
                    padding: "20px 80px",
                    borderRadius: "12px",
                    cursor: "pointer",
                    backgroundColor: "#2196F3",
                    color: "white",
                    border: "none",
                    boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)",
                    transition: "transform 0.2s, background-color 0.2s"
                },
                onMouseOver: o => o.target.style.backgroundColor = "#2881C6",
                onMouseOut: o => o.target.style.backgroundColor = "#2196F3",
                children: "Settings"
            })]
        })]
    })
}
function fM({setPage: r}) {
    const [e,t] = dt.useState(!1)
      , s = () => {
        t(!e)
    }
      , o = ({name: l, message: f}) => b.jsxs("div", {
        style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "flex-start",
            backgroundColor: "rgb(117, 192, 142)",
            width: "100%",
            height: "90px",
            padding: "10px 20px",
            boxSizing: "border-box",
            marginTop: "15px",
            borderRadius: "15px",
            boxShadow: "0 4px 8px rgba(0, 0, 0, 0.1)",
            transition: "transform 0.2s, box-shadow 0.2s"
        },
        onMouseOver: d => {
            d.currentTarget.style.transform = "scale(1.02)",
            d.currentTarget.style.boxShadow = "0 6px 12px rgba(0, 0, 0, 0.2)"
        }
        ,
        onMouseOut: d => {
            d.currentTarget.style.transform = "scale(1)",
            d.currentTarget.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.1)"
        }
        ,
        onClick: () => r("chatwithdoctor"),
        children: [b.jsx("img", {
            src: Yi,
            width: "60px",
            height: "60px",
            style: {
                borderRadius: "50%",
                border: "2px solid white"
            },
            alt: "Profile"
        }), b.jsxs("div", {
            style: {
                display: "flex",
                flexDirection: "column",
                justifyContent: "center",
                flex: 1,
                textAlign: "left"
            },
            children: [b.jsx("p", {
                style: {
                    marginRight: "2.7em",
                    marginBottom: "0",
                    fontSize: "18px",
                    fontWeight: "bold",
                    color: "#333"
                },
                children: l
            }), b.jsx("p", {
                style: {
                    marginRight: "2.7em",
                    fontSize: "14px",
                    color: "#555"
                },
                children: f
            })]
        })]
    });
    return b.jsx(b.Fragment, {
        children: b.jsxs("div", {
            id: "container44",
            children: [b.jsx("img", {
                src: Yi,
                className: "profile-icon",
                alt: "Profile"
            }), b.jsx("h2", {
                style: {
                    fontSize: "large",
                    textAlign: "center",
                    marginTop: "1.5em"
                },
                children: "Dr.Finder"
            }), b.jsxs("div", {
                style: {
                    marginTop: "1em",
                    padding: "20px"
                },
                children: [b.jsx(o, {
                    name: "Dr.Ren (MD)",
                    message: "If you are sick visit me."
                }), b.jsx(o, {
                    name: "Dr.Smith (MD)",
                    message: "Appointment is on March 6th."
                }), b.jsx(o, {
                    name: "Dr.Joey (MD)",
                    message: "Could you give me some advice?"
                }), b.jsx(o, {
                    name: "Dr.Sally (MD)",
                    message: "When should I take the drugs?"
                }), b.jsx(o, {
                    name: "Dr.Fickle (MD)",
                    message: "When are you available?"
                }), b.jsx(o, {
                    name: "Dr.Zilly (MD)",
                    message: "Should I take it before a meal?"
                }), b.jsx(o, {
                    name: "Dr.Wok (MD)",
                    message: "I am super sick!"
                }), b.jsx(o, {
                    name: "Dr.Wong (MD)",
                    message: "Let me use my magic to cure you."
                }), b.jsx(o, {
                    name: "Dr.Ronaldo (MD)",
                    message: "Siuuuuu."
                }), b.jsx(o, {
                    name: "Dr.Hare (MD)",
                    message: "So this will be your project due tomorrow."
                }), b.jsx(o, {
                    name: "Dr.Keenan (MD)",
                    message: "Do you like math?"
                }), b.jsx(o, {
                    name: "Dr.Hollow (MD)",
                    message: "I really love pumpkins."
                }), b.jsx(o, {
                    name: "Dr.Chicken (MD)",
                    message: "Any questions?"
                }), b.jsx(o, {
                    name: "Dr.Jockey (MD)",
                    message: "So How did it go?"
                }), b.jsx(o, {
                    name: "Dr.Nye (MD)",
                    message: "Sorry, I will be a little late"
                }), b.jsx(o, {
                    name: "Dr.Bill (MD)",
                    message: "No, No, No."
                }), b.jsx(o, {
                    name: "Dr.Nelson (MD)",
                    message: "Come over."
                }), b.jsx(o, {
                    name: "Dr.Kim (MD)",
                    message: "Wanna hangout?"
                }), b.jsx(o, {
                    name: "Dr.Apple (MD)",
                    message: "Yes, yes, yes."
                })]
            }), b.jsxs("div", {
                id: "newnavbar",
                children: [b.jsx("button", {
                    onClick: s,
                    children: "☰"
                }), b.jsxs("div", {
                    className: `sliding-panel ${e ? "visible" : ""}`,
                    children: [b.jsx("button", {
                        className: "close-panel",
                        onClick: s,
                        children: "✖"
                    }), b.jsxs("ul", {
                        children: [b.jsx("li", {
                            onClick: () => r("profile"),
                            children: "Home"
                        }), b.jsx("li", {
                            onClick: () => r("dmlist"),
                            children: "DmList"
                        }), b.jsx("li", {
                            onClick: () => r("drlist"),
                            children: "DrList"
                        }), b.jsx("li", {
                            onClick: () => r("chatbox"),
                            children: "AI Chat"
                        }), b.jsx("li", {
                            onClick: () => r("settings"),
                            children: "Settings"
                        })]
                    })]
                })]
            })]
        })
    })
}
function hM({setPage: r}) {
    const [e,t] = dt.useState(!1)
      , s = () => {
        t(!e)
    }
      , o = ({name: l, specialty: f}) => b.jsxs("div", {
        style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "flex-start",
            backgroundColor: "rgb(127, 154, 228)",
            width: "100%",
            height: "90px",
            padding: "10px 20px",
            boxSizing: "border-box",
            marginTop: "15px",
            borderRadius: "15px",
            boxShadow: "0 4px 8px rgba(0, 0, 0, 0.1)",
            transition: "transform 0.2s, box-shadow 0.2s"
        },
        onMouseOver: d => {
            d.currentTarget.style.transform = "scale(1.02)",
            d.currentTarget.style.boxShadow = "0 6px 12px rgba(0, 0, 0, 0.2)"
        }
        ,
        onMouseOut: d => {
            d.currentTarget.style.transform = "scale(1)",
            d.currentTarget.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.1)"
        }
        ,
        children: [b.jsxs("div", {
            style: {
                display: "flex",
                alignItems: "center",
                flex: 1,
                content: "center"
            },
            children: [b.jsx("img", {
                src: Yi,
                width: "60px",
                height: "60px",
                style: {
                    borderRadius: "50%"
                },
                alt: "Profile"
            }), b.jsxs("div", {
                style: {
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "center",
                    flex: 1,
                    textAlign: "left"
                },
                children: [b.jsx("p", {
                    style: {
                        marginLeft: "7em",
                        marginBottom: "0",
                        fontSize: "18px",
                        fontWeight: "bold",
                        color: "#333",
                        textAlign: "center"
                    },
                    children: l
                }), b.jsx("p", {
                    style: {
                        marginLeft: "8.5em",
                        fontSize: "14px",
                        color: "#555"
                    },
                    children: f
                })]
            })]
        }), b.jsx("button", {
            onClick: () => r("chatwithdoctor"),
            style: {
                fontSize: "16px",
                padding: "10px 20px",
                borderRadius: "8px",
                cursor: "pointer",
                backgroundColor: "#4CAF50",
                color: "white",
                border: "none",
                boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)",
                transition: "transform 0.2s, background-color 0.2s"
            },
            onMouseOver: d => d.target.style.backgroundColor = "#45a049",
            onMouseOut: d => d.target.style.backgroundColor = "#4CAF50",
            children: "Start New Chat 📧"
        })]
    });
    return b.jsxs(b.Fragment, {
        children: [b.jsxs("div", {
            id: "container33",
            children: [b.jsx("img", {
                src: Yi,
                className: "profile-icon",
                alt: "Profile"
            }), b.jsx("h1", {
                style: {
                    fontSize: "large",
                    textAlign: "center",
                    marginTop: "1.5em"
                },
                children: "Dr.Finder"
            }), b.jsxs("div", {
                style: {
                    marginTop: "1em",
                    padding: "20px"
                },
                children: [b.jsx(o, {
                    name: "Dr.Ren (MD)",
                    specialty: "Pediatrist"
                }), b.jsx(o, {
                    name: "Dr.Smith (MD)",
                    specialty: "Anaesthesiologist"
                }), b.jsx(o, {
                    name: "Dr.Joey (MD)",
                    specialty: "Oncologist"
                }), b.jsx(o, {
                    name: "Dr.Sally (MD)",
                    specialty: "Gastroenterologist"
                }), b.jsx(o, {
                    name: "Dr.Fickle (MD)",
                    specialty: "Neurologist"
                }), b.jsx(o, {
                    name: "Dr.Zilly (MD)",
                    specialty: "Cardiologist"
                }), b.jsx(o, {
                    name: "Dr.Wok (MD)",
                    specialty: "Geriatrician"
                }), b.jsx(o, {
                    name: "Dr.Wong (MD)",
                    specialty: "Oncologist"
                }), b.jsx(o, {
                    name: "Dr.Ronaldo (MD)",
                    specialty: "Physicist"
                }), b.jsx(o, {
                    name: "Dr.Hare (MD)",
                    specialty: "Computerist"
                }), b.jsx(o, {
                    name: "Dr.Keenan (MD)",
                    specialty: "Mathist"
                })]
            })]
        }), b.jsxs("div", {
            id: "newnavbar",
            children: [b.jsx("button", {
                onClick: s,
                children: "☰"
            }), b.jsxs("div", {
                className: `sliding-panel ${e ? "visible" : ""}`,
                children: [b.jsx("button", {
                    className: "close-panel",
                    onClick: s,
                    children: "✖"
                }), b.jsxs("ul", {
                    children: [b.jsx("li", {
                        onClick: () => r("profile"),
                        children: "Home"
                    }), b.jsx("li", {
                        onClick: () => r("dmlist"),
                        children: "DmList"
                    }), b.jsx("li", {
                        onClick: () => r("drlist"),
                        children: "DrList"
                    }), b.jsx("li", {
                        onClick: () => r("chatbox"),
                        children: "Chat"
                    }), b.jsx("li", {
                        onClick: () => r("settings"),
                        children: "Settings"
                    })]
                })]
            })]
        })]
    })
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let dM, pM;
function mM() {
    return {
        geminiUrl: dM,
        vertexUrl: pM
    }
}
function gM(r, e, t) {
    var s, o, l;
    if (!(!((s = r.httpOptions) === null || s === void 0) && s.baseUrl)) {
        const f = mM();
        return r.vertexai ? (o = f.vertexUrl) !== null && o !== void 0 ? o : e : (l = f.geminiUrl) !== null && l !== void 0 ? l : t
    }
    return r.httpOptions.baseUrl
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Ol {
}
function Se(r, e) {
    const t = /\{([^}]+)\}/g;
    return r.replace(t, (s, o) => {
        if (Object.prototype.hasOwnProperty.call(e, o)) {
            const l = e[o];
            return l != null ? String(l) : ""
        } else
            throw new Error(`Key '${o}' not found in valueMap.`)
    }
    )
}
function m(r, e, t) {
    for (let l = 0; l < e.length - 1; l++) {
        const f = e[l];
        if (f.endsWith("[]")) {
            const d = f.slice(0, -2);
            if (!(d in r))
                if (Array.isArray(t))
                    r[d] = Array.from({
                        length: t.length
                    }, () => ({}));
                else
                    throw new Error(`Value must be a list given an array path ${f}`);
            if (Array.isArray(r[d])) {
                const v = r[d];
                if (Array.isArray(t))
                    for (let y = 0; y < v.length; y++) {
                        const T = v[y];
                        m(T, e.slice(l + 1), t[y])
                    }
                else
                    for (const y of v)
                        m(y, e.slice(l + 1), t)
            }
            return
        } else if (f.endsWith("[0]")) {
            const d = f.slice(0, -3);
            d in r || (r[d] = [{}]);
            const v = r[d];
            m(v[0], e.slice(l + 1), t);
            return
        }
        (!r[f] || typeof r[f] != "object") && (r[f] = {}),
        r = r[f]
    }
    const s = e[e.length - 1]
      , o = r[s];
    if (o !== void 0) {
        if (!t || typeof t == "object" && Object.keys(t).length === 0 || t === o)
            return;
        if (typeof o == "object" && typeof t == "object" && o !== null && t !== null)
            Object.assign(o, t);
        else
            throw new Error(`Cannot set value for an existing key. Key: ${s}`)
    } else
        r[s] = t
}
function p(r, e) {
    try {
        if (e.length === 1 && e[0] === "_self")
            return r;
        for (let t = 0; t < e.length; t++) {
            if (typeof r != "object" || r === null)
                return;
            const s = e[t];
            if (s.endsWith("[]")) {
                const o = s.slice(0, -2);
                if (o in r) {
                    const l = r[o];
                    return Array.isArray(l) ? l.map(f => p(f, e.slice(t + 1))) : void 0
                } else
                    return
            } else
                r = r[s]
        }
        return r
    } catch (t) {
        if (t instanceof TypeError)
            return;
        throw t
    }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function ut(r, e) {
    if (!e || typeof e != "string")
        throw new Error("model is required and must be a string");
    if (r.isVertexAI()) {
        if (e.startsWith("publishers/") || e.startsWith("projects/") || e.startsWith("models/"))
            return e;
        if (e.indexOf("/") >= 0) {
            const t = e.split("/", 2);
            return `publishers/${t[0]}/models/${t[1]}`
        } else
            return `publishers/google/models/${e}`
    } else
        return e.startsWith("models/") || e.startsWith("tunedModels/") ? e : `models/${e}`
}
function R0(r, e) {
    const t = ut(r, e);
    return t ? t.startsWith("publishers/") && r.isVertexAI() ? `projects/${r.getProject()}/locations/${r.getLocation()}/${t}` : t.startsWith("models/") && r.isVertexAI() ? `projects/${r.getProject()}/locations/${r.getLocation()}/publishers/google/${t}` : t : ""
}
function I0(r, e) {
    return Array.isArray(e) ? e.map(t => Gc(r, t)) : [Gc(r, e)]
}
function Gc(r, e) {
    if (typeof e == "object" && e !== null)
        return e;
    throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof e}`)
}
function yM(r, e) {
    const t = Gc(r, e);
    if (t.mimeType && t.mimeType.startsWith("image/"))
        return t;
    throw new Error(`Unsupported mime type: ${t.mimeType}`)
}
function vM(r, e) {
    const t = Gc(r, e);
    if (t.mimeType && t.mimeType.startsWith("audio/"))
        return t;
    throw new Error(`Unsupported mime type: ${t.mimeType}`)
}
function C_(r, e) {
    if (e == null)
        throw new Error("PartUnion is required");
    if (typeof e == "object")
        return e;
    if (typeof e == "string")
        return {
            text: e
        };
    throw new Error(`Unsupported part type: ${typeof e}`)
}
function w0(r, e) {
    if (e == null || Array.isArray(e) && e.length === 0)
        throw new Error("PartListUnion is required");
    return Array.isArray(e) ? e.map(t => C_(r, t)) : [C_(r, e)]
}
function Qd(r) {
    return r != null && typeof r == "object" && "parts"in r && Array.isArray(r.parts)
}
function R_(r) {
    return r != null && typeof r == "object" && "functionCall"in r
}
function I_(r) {
    return r != null && typeof r == "object" && "functionResponse"in r
}
function on(r, e) {
    if (e == null)
        throw new Error("ContentUnion is required");
    return Qd(e) ? e : {
        role: "user",
        parts: w0(r, e)
    }
}
function b0(r, e) {
    if (!e)
        return [];
    if (r.isVertexAI() && Array.isArray(e))
        return e.flatMap(t => {
            const s = on(r, t);
            return s.parts && s.parts.length > 0 && s.parts[0].text !== void 0 ? [s.parts[0].text] : []
        }
        );
    if (r.isVertexAI()) {
        const t = on(r, e);
        return t.parts && t.parts.length > 0 && t.parts[0].text !== void 0 ? [t.parts[0].text] : []
    }
    return Array.isArray(e) ? e.map(t => on(r, t)) : [on(r, e)]
}
function Ur(r, e) {
    if (e == null || Array.isArray(e) && e.length === 0)
        throw new Error("contents are required");
    if (!Array.isArray(e)) {
        if (R_(e) || I_(e))
            throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");
        return [on(r, e)]
    }
    const t = []
      , s = []
      , o = Qd(e[0]);
    for (const l of e) {
        const f = Qd(l);
        if (f != o)
            throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");
        if (f)
            t.push(l);
        else {
            if (R_(l) || I_(l))
                throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");
            s.push(l)
        }
    }
    return o || t.push({
        role: "user",
        parts: w0(r, s)
    }),
    t
}
function D0(r, e) {
    return e
}
function M0(r, e) {
    if (typeof e == "object")
        return e;
    if (typeof e == "string")
        return {
            voiceConfig: {
                prebuiltVoiceConfig: {
                    voiceName: e
                }
            }
        };
    throw new Error(`Unsupported speechConfig type: ${typeof e}`)
}
function of(r, e) {
    return e
}
function af(r, e) {
    if (!Array.isArray(e))
        throw new Error("tool is required and must be an array of Tools");
    return e
}
function _M(r, e, t, s=1) {
    const o = !e.startsWith(`${t}/`) && e.split("/").length === s;
    return r.isVertexAI() ? e.startsWith("projects/") ? e : e.startsWith("locations/") ? `projects/${r.getProject()}/${e}` : e.startsWith(`${t}/`) ? `projects/${r.getProject()}/locations/${r.getLocation()}/${e}` : o ? `projects/${r.getProject()}/locations/${r.getLocation()}/${t}/${e}` : e : o ? `${t}/${e}` : e
}
function kr(r, e) {
    if (typeof e != "string")
        throw new Error("name must be a string");
    return _M(r, e, "cachedContents")
}
function N0(r, e) {
    switch (e) {
    case "STATE_UNSPECIFIED":
        return "JOB_STATE_UNSPECIFIED";
    case "CREATING":
        return "JOB_STATE_RUNNING";
    case "ACTIVE":
        return "JOB_STATE_SUCCEEDED";
    case "FAILED":
        return "JOB_STATE_FAILED";
    default:
        return e
    }
}
function Lr(r, e) {
    if (typeof e != "string")
        throw new Error("fromImageBytes must be a string");
    return e
}
function x0(r, e) {
    if (typeof e != "string")
        throw new Error("fromName must be a string");
    return e.startsWith("files/") ? e.split("files/")[1] : e
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function TM(r, e) {
    const t = {};
    if (p(e, ["videoMetadata"]) !== void 0)
        throw new Error("videoMetadata parameter is not supported in Gemini API.");
    const s = p(e, ["thought"]);
    s != null && m(t, ["thought"], s);
    const o = p(e, ["codeExecutionResult"]);
    o != null && m(t, ["codeExecutionResult"], o);
    const l = p(e, ["executableCode"]);
    l != null && m(t, ["executableCode"], l);
    const f = p(e, ["fileData"]);
    f != null && m(t, ["fileData"], f);
    const d = p(e, ["functionCall"]);
    d != null && m(t, ["functionCall"], d);
    const v = p(e, ["functionResponse"]);
    v != null && m(t, ["functionResponse"], v);
    const y = p(e, ["inlineData"]);
    y != null && m(t, ["inlineData"], y);
    const T = p(e, ["text"]);
    return T != null && m(t, ["text"], T),
    t
}
function w_(r, e) {
    const t = {}
      , s = p(e, ["parts"]);
    if (s != null) {
        let l = s;
        Array.isArray(l) && (l = l.map(f => TM(r, f))),
        m(t, ["parts"], l)
    }
    const o = p(e, ["role"]);
    return o != null && m(t, ["role"], o),
    t
}
function EM() {
    return {}
}
function SM(r, e) {
    const t = {}
      , s = p(e, ["mode"]);
    s != null && m(t, ["mode"], s);
    const o = p(e, ["dynamicThreshold"]);
    return o != null && m(t, ["dynamicThreshold"], o),
    t
}
function AM(r, e) {
    const t = {}
      , s = p(e, ["dynamicRetrievalConfig"]);
    return s != null && m(t, ["dynamicRetrievalConfig"], SM(r, s)),
    t
}
function CM(r, e) {
    const t = {};
    if (p(e, ["retrieval"]) !== void 0)
        throw new Error("retrieval parameter is not supported in Gemini API.");
    p(e, ["googleSearch"]) != null && m(t, ["googleSearch"], EM());
    const o = p(e, ["googleSearchRetrieval"]);
    o != null && m(t, ["googleSearchRetrieval"], AM(r, o));
    const l = p(e, ["codeExecution"]);
    l != null && m(t, ["codeExecution"], l);
    const f = p(e, ["functionDeclarations"]);
    return f != null && m(t, ["functionDeclarations"], f),
    t
}
function RM(r, e) {
    const t = {}
      , s = p(e, ["mode"]);
    s != null && m(t, ["mode"], s);
    const o = p(e, ["allowedFunctionNames"]);
    return o != null && m(t, ["allowedFunctionNames"], o),
    t
}
function IM(r, e) {
    const t = {}
      , s = p(e, ["functionCallingConfig"]);
    return s != null && m(t, ["functionCallingConfig"], RM(r, s)),
    t
}
function wM(r, e, t) {
    const s = {}
      , o = p(e, ["ttl"]);
    t !== void 0 && o != null && m(t, ["ttl"], o);
    const l = p(e, ["expireTime"]);
    t !== void 0 && l != null && m(t, ["expireTime"], l);
    const f = p(e, ["displayName"]);
    t !== void 0 && f != null && m(t, ["displayName"], f);
    const d = p(e, ["contents"]);
    if (t !== void 0 && d != null) {
        let A = Ur(r, d);
        Array.isArray(A) && (A = A.map(I => w_(r, I))),
        m(t, ["contents"], A)
    }
    const v = p(e, ["systemInstruction"]);
    t !== void 0 && v != null && m(t, ["systemInstruction"], w_(r, on(r, v)));
    const y = p(e, ["tools"]);
    if (t !== void 0 && y != null) {
        let A = y;
        Array.isArray(A) && (A = A.map(I => CM(r, I))),
        m(t, ["tools"], A)
    }
    const T = p(e, ["toolConfig"]);
    return t !== void 0 && T != null && m(t, ["toolConfig"], IM(r, T)),
    s
}
function bM(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["model"], R0(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], wM(r, o, t)),
    t
}
function DM(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["_url", "name"], kr(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], o),
    t
}
function MM(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["_url", "name"], kr(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], o),
    t
}
function NM(r, e, t) {
    const s = {}
      , o = p(e, ["ttl"]);
    t !== void 0 && o != null && m(t, ["ttl"], o);
    const l = p(e, ["expireTime"]);
    return t !== void 0 && l != null && m(t, ["expireTime"], l),
    s
}
function xM(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["_url", "name"], kr(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], NM(r, o, t)),
    t
}
function PM(r, e, t) {
    const s = {}
      , o = p(e, ["pageSize"]);
    t !== void 0 && o != null && m(t, ["_query", "pageSize"], o);
    const l = p(e, ["pageToken"]);
    return t !== void 0 && l != null && m(t, ["_query", "pageToken"], l),
    s
}
function OM(r, e) {
    const t = {}
      , s = p(e, ["config"]);
    return s != null && m(t, ["config"], PM(r, s, t)),
    t
}
function VM(r, e) {
    const t = {}
      , s = p(e, ["videoMetadata"]);
    s != null && m(t, ["videoMetadata"], s);
    const o = p(e, ["thought"]);
    o != null && m(t, ["thought"], o);
    const l = p(e, ["codeExecutionResult"]);
    l != null && m(t, ["codeExecutionResult"], l);
    const f = p(e, ["executableCode"]);
    f != null && m(t, ["executableCode"], f);
    const d = p(e, ["fileData"]);
    d != null && m(t, ["fileData"], d);
    const v = p(e, ["functionCall"]);
    v != null && m(t, ["functionCall"], v);
    const y = p(e, ["functionResponse"]);
    y != null && m(t, ["functionResponse"], y);
    const T = p(e, ["inlineData"]);
    T != null && m(t, ["inlineData"], T);
    const A = p(e, ["text"]);
    return A != null && m(t, ["text"], A),
    t
}
function b_(r, e) {
    const t = {}
      , s = p(e, ["parts"]);
    if (s != null) {
        let l = s;
        Array.isArray(l) && (l = l.map(f => VM(r, f))),
        m(t, ["parts"], l)
    }
    const o = p(e, ["role"]);
    return o != null && m(t, ["role"], o),
    t
}
function UM() {
    return {}
}
function kM(r, e) {
    const t = {}
      , s = p(e, ["mode"]);
    s != null && m(t, ["mode"], s);
    const o = p(e, ["dynamicThreshold"]);
    return o != null && m(t, ["dynamicThreshold"], o),
    t
}
function LM(r, e) {
    const t = {}
      , s = p(e, ["dynamicRetrievalConfig"]);
    return s != null && m(t, ["dynamicRetrievalConfig"], kM(r, s)),
    t
}
function BM(r, e) {
    const t = {}
      , s = p(e, ["retrieval"]);
    s != null && m(t, ["retrieval"], s),
    p(e, ["googleSearch"]) != null && m(t, ["googleSearch"], UM());
    const l = p(e, ["googleSearchRetrieval"]);
    l != null && m(t, ["googleSearchRetrieval"], LM(r, l));
    const f = p(e, ["codeExecution"]);
    f != null && m(t, ["codeExecution"], f);
    const d = p(e, ["functionDeclarations"]);
    return d != null && m(t, ["functionDeclarations"], d),
    t
}
function qM(r, e) {
    const t = {}
      , s = p(e, ["mode"]);
    s != null && m(t, ["mode"], s);
    const o = p(e, ["allowedFunctionNames"]);
    return o != null && m(t, ["allowedFunctionNames"], o),
    t
}
function zM(r, e) {
    const t = {}
      , s = p(e, ["functionCallingConfig"]);
    return s != null && m(t, ["functionCallingConfig"], qM(r, s)),
    t
}
function FM(r, e, t) {
    const s = {}
      , o = p(e, ["ttl"]);
    t !== void 0 && o != null && m(t, ["ttl"], o);
    const l = p(e, ["expireTime"]);
    t !== void 0 && l != null && m(t, ["expireTime"], l);
    const f = p(e, ["displayName"]);
    t !== void 0 && f != null && m(t, ["displayName"], f);
    const d = p(e, ["contents"]);
    if (t !== void 0 && d != null) {
        let A = Ur(r, d);
        Array.isArray(A) && (A = A.map(I => b_(r, I))),
        m(t, ["contents"], A)
    }
    const v = p(e, ["systemInstruction"]);
    t !== void 0 && v != null && m(t, ["systemInstruction"], b_(r, on(r, v)));
    const y = p(e, ["tools"]);
    if (t !== void 0 && y != null) {
        let A = y;
        Array.isArray(A) && (A = A.map(I => BM(r, I))),
        m(t, ["tools"], A)
    }
    const T = p(e, ["toolConfig"]);
    return t !== void 0 && T != null && m(t, ["toolConfig"], zM(r, T)),
    s
}
function HM(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["model"], R0(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], FM(r, o, t)),
    t
}
function GM(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["_url", "name"], kr(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], o),
    t
}
function YM(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["_url", "name"], kr(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], o),
    t
}
function KM(r, e, t) {
    const s = {}
      , o = p(e, ["ttl"]);
    t !== void 0 && o != null && m(t, ["ttl"], o);
    const l = p(e, ["expireTime"]);
    return t !== void 0 && l != null && m(t, ["expireTime"], l),
    s
}
function QM(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["_url", "name"], kr(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], KM(r, o, t)),
    t
}
function XM(r, e, t) {
    const s = {}
      , o = p(e, ["pageSize"]);
    t !== void 0 && o != null && m(t, ["_query", "pageSize"], o);
    const l = p(e, ["pageToken"]);
    return t !== void 0 && l != null && m(t, ["_query", "pageToken"], l),
    s
}
function $M(r, e) {
    const t = {}
      , s = p(e, ["config"]);
    return s != null && m(t, ["config"], XM(r, s, t)),
    t
}
function Sc(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["name"], s);
    const o = p(e, ["displayName"]);
    o != null && m(t, ["displayName"], o);
    const l = p(e, ["model"]);
    l != null && m(t, ["model"], l);
    const f = p(e, ["createTime"]);
    f != null && m(t, ["createTime"], f);
    const d = p(e, ["updateTime"]);
    d != null && m(t, ["updateTime"], d);
    const v = p(e, ["expireTime"]);
    v != null && m(t, ["expireTime"], v);
    const y = p(e, ["usageMetadata"]);
    return y != null && m(t, ["usageMetadata"], y),
    t
}
function JM() {
    return {}
}
function jM(r, e) {
    const t = {}
      , s = p(e, ["nextPageToken"]);
    s != null && m(t, ["nextPageToken"], s);
    const o = p(e, ["cachedContents"]);
    if (o != null) {
        let l = o;
        Array.isArray(l) && (l = l.map(f => Sc(r, f))),
        m(t, ["cachedContents"], l)
    }
    return t
}
function Ac(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["name"], s);
    const o = p(e, ["displayName"]);
    o != null && m(t, ["displayName"], o);
    const l = p(e, ["model"]);
    l != null && m(t, ["model"], l);
    const f = p(e, ["createTime"]);
    f != null && m(t, ["createTime"], f);
    const d = p(e, ["updateTime"]);
    d != null && m(t, ["updateTime"], d);
    const v = p(e, ["expireTime"]);
    v != null && m(t, ["expireTime"], v);
    const y = p(e, ["usageMetadata"]);
    return y != null && m(t, ["usageMetadata"], y),
    t
}
function WM() {
    return {}
}
function ZM(r, e) {
    const t = {}
      , s = p(e, ["nextPageToken"]);
    s != null && m(t, ["nextPageToken"], s);
    const o = p(e, ["cachedContents"]);
    if (o != null) {
        let l = o;
        Array.isArray(l) && (l = l.map(f => Ac(r, f))),
        m(t, ["cachedContents"], l)
    }
    return t
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var Sl;
(function(r) {
    r.PAGED_ITEM_BATCH_JOBS = "batchJobs",
    r.PAGED_ITEM_MODELS = "models",
    r.PAGED_ITEM_TUNING_JOBS = "tuningJobs",
    r.PAGED_ITEM_FILES = "files",
    r.PAGED_ITEM_CACHED_CONTENTS = "cachedContents"
}
)(Sl || (Sl = {}));
class kp {
    constructor(e, t, s, o) {
        this.pageInternal = [],
        this.paramsInternal = {},
        this.requestInternal = t,
        this.init(e, s, o)
    }
    init(e, t, s) {
        var o, l;
        this.nameInternal = e,
        this.pageInternal = t[this.nameInternal] || [],
        this.idxInternal = 0;
        let f = {
            config: {}
        };
        s ? typeof s == "object" ? f = Object.assign({}, s) : f = s : f = {
            config: {}
        },
        f.config && (f.config.pageToken = t.nextPageToken),
        this.paramsInternal = f,
        this.pageInternalSize = (l = (o = f.config) === null || o === void 0 ? void 0 : o.pageSize) !== null && l !== void 0 ? l : this.pageInternal.length
    }
    initNextPage(e) {
        this.init(this.nameInternal, e, this.paramsInternal)
    }
    get page() {
        return this.pageInternal
    }
    get name() {
        return this.nameInternal
    }
    get pageSize() {
        return this.pageInternalSize
    }
    get params() {
        return this.paramsInternal
    }
    get pageLength() {
        return this.pageInternal.length
    }
    getItem(e) {
        return this.pageInternal[e]
    }
    [Symbol.asyncIterator]() {
        return {
            next: async () => {
                if (this.idxInternal >= this.pageLength)
                    if (this.hasNextPage())
                        await this.nextPage();
                    else
                        return {
                            value: void 0,
                            done: !0
                        };
                const e = this.getItem(this.idxInternal);
                return this.idxInternal += 1,
                {
                    value: e,
                    done: !1
                }
            }
            ,
            return: async () => ({
                value: void 0,
                done: !0
            })
        }
    }
    async nextPage() {
        if (!this.hasNextPage())
            throw new Error("No more pages to fetch.");
        const e = await this.requestInternal(this.params);
        return this.initNextPage(e),
        this.page
    }
    hasNextPage() {
        var e;
        return ((e = this.params.config) === null || e === void 0 ? void 0 : e.pageToken) !== void 0
    }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var D_;
(function(r) {
    r.OUTCOME_UNSPECIFIED = "OUTCOME_UNSPECIFIED",
    r.OUTCOME_OK = "OUTCOME_OK",
    r.OUTCOME_FAILED = "OUTCOME_FAILED",
    r.OUTCOME_DEADLINE_EXCEEDED = "OUTCOME_DEADLINE_EXCEEDED"
}
)(D_ || (D_ = {}));
var M_;
(function(r) {
    r.LANGUAGE_UNSPECIFIED = "LANGUAGE_UNSPECIFIED",
    r.PYTHON = "PYTHON"
}
)(M_ || (M_ = {}));
var N_;
(function(r) {
    r.HARM_CATEGORY_UNSPECIFIED = "HARM_CATEGORY_UNSPECIFIED",
    r.HARM_CATEGORY_HATE_SPEECH = "HARM_CATEGORY_HATE_SPEECH",
    r.HARM_CATEGORY_DANGEROUS_CONTENT = "HARM_CATEGORY_DANGEROUS_CONTENT",
    r.HARM_CATEGORY_HARASSMENT = "HARM_CATEGORY_HARASSMENT",
    r.HARM_CATEGORY_SEXUALLY_EXPLICIT = "HARM_CATEGORY_SEXUALLY_EXPLICIT",
    r.HARM_CATEGORY_CIVIC_INTEGRITY = "HARM_CATEGORY_CIVIC_INTEGRITY"
}
)(N_ || (N_ = {}));
var x_;
(function(r) {
    r.HARM_BLOCK_METHOD_UNSPECIFIED = "HARM_BLOCK_METHOD_UNSPECIFIED",
    r.SEVERITY = "SEVERITY",
    r.PROBABILITY = "PROBABILITY"
}
)(x_ || (x_ = {}));
var P_;
(function(r) {
    r.HARM_BLOCK_THRESHOLD_UNSPECIFIED = "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
    r.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE",
    r.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE",
    r.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH",
    r.BLOCK_NONE = "BLOCK_NONE",
    r.OFF = "OFF"
}
)(P_ || (P_ = {}));
var O_;
(function(r) {
    r.MODE_UNSPECIFIED = "MODE_UNSPECIFIED",
    r.MODE_DYNAMIC = "MODE_DYNAMIC"
}
)(O_ || (O_ = {}));
var V_;
(function(r) {
    r.TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED",
    r.STRING = "STRING",
    r.NUMBER = "NUMBER",
    r.INTEGER = "INTEGER",
    r.BOOLEAN = "BOOLEAN",
    r.ARRAY = "ARRAY",
    r.OBJECT = "OBJECT"
}
)(V_ || (V_ = {}));
var U_;
(function(r) {
    r.FINISH_REASON_UNSPECIFIED = "FINISH_REASON_UNSPECIFIED",
    r.STOP = "STOP",
    r.MAX_TOKENS = "MAX_TOKENS",
    r.SAFETY = "SAFETY",
    r.RECITATION = "RECITATION",
    r.LANGUAGE = "LANGUAGE",
    r.OTHER = "OTHER",
    r.BLOCKLIST = "BLOCKLIST",
    r.PROHIBITED_CONTENT = "PROHIBITED_CONTENT",
    r.SPII = "SPII",
    r.MALFORMED_FUNCTION_CALL = "MALFORMED_FUNCTION_CALL",
    r.IMAGE_SAFETY = "IMAGE_SAFETY"
}
)(U_ || (U_ = {}));
var k_;
(function(r) {
    r.HARM_PROBABILITY_UNSPECIFIED = "HARM_PROBABILITY_UNSPECIFIED",
    r.NEGLIGIBLE = "NEGLIGIBLE",
    r.LOW = "LOW",
    r.MEDIUM = "MEDIUM",
    r.HIGH = "HIGH"
}
)(k_ || (k_ = {}));
var L_;
(function(r) {
    r.HARM_SEVERITY_UNSPECIFIED = "HARM_SEVERITY_UNSPECIFIED",
    r.HARM_SEVERITY_NEGLIGIBLE = "HARM_SEVERITY_NEGLIGIBLE",
    r.HARM_SEVERITY_LOW = "HARM_SEVERITY_LOW",
    r.HARM_SEVERITY_MEDIUM = "HARM_SEVERITY_MEDIUM",
    r.HARM_SEVERITY_HIGH = "HARM_SEVERITY_HIGH"
}
)(L_ || (L_ = {}));
var B_;
(function(r) {
    r.BLOCKED_REASON_UNSPECIFIED = "BLOCKED_REASON_UNSPECIFIED",
    r.SAFETY = "SAFETY",
    r.OTHER = "OTHER",
    r.BLOCKLIST = "BLOCKLIST",
    r.PROHIBITED_CONTENT = "PROHIBITED_CONTENT"
}
)(B_ || (B_ = {}));
var q_;
(function(r) {
    r.TRAFFIC_TYPE_UNSPECIFIED = "TRAFFIC_TYPE_UNSPECIFIED",
    r.ON_DEMAND = "ON_DEMAND",
    r.PROVISIONED_THROUGHPUT = "PROVISIONED_THROUGHPUT"
}
)(q_ || (q_ = {}));
var Yc;
(function(r) {
    r.MODALITY_UNSPECIFIED = "MODALITY_UNSPECIFIED",
    r.TEXT = "TEXT",
    r.IMAGE = "IMAGE",
    r.AUDIO = "AUDIO"
}
)(Yc || (Yc = {}));
var z_;
(function(r) {
    r.MEDIA_RESOLUTION_UNSPECIFIED = "MEDIA_RESOLUTION_UNSPECIFIED",
    r.MEDIA_RESOLUTION_LOW = "MEDIA_RESOLUTION_LOW",
    r.MEDIA_RESOLUTION_MEDIUM = "MEDIA_RESOLUTION_MEDIUM",
    r.MEDIA_RESOLUTION_HIGH = "MEDIA_RESOLUTION_HIGH"
}
)(z_ || (z_ = {}));
var Xd;
(function(r) {
    r.JOB_STATE_UNSPECIFIED = "JOB_STATE_UNSPECIFIED",
    r.JOB_STATE_QUEUED = "JOB_STATE_QUEUED",
    r.JOB_STATE_PENDING = "JOB_STATE_PENDING",
    r.JOB_STATE_RUNNING = "JOB_STATE_RUNNING",
    r.JOB_STATE_SUCCEEDED = "JOB_STATE_SUCCEEDED",
    r.JOB_STATE_FAILED = "JOB_STATE_FAILED",
    r.JOB_STATE_CANCELLING = "JOB_STATE_CANCELLING",
    r.JOB_STATE_CANCELLED = "JOB_STATE_CANCELLED",
    r.JOB_STATE_PAUSED = "JOB_STATE_PAUSED",
    r.JOB_STATE_EXPIRED = "JOB_STATE_EXPIRED",
    r.JOB_STATE_UPDATING = "JOB_STATE_UPDATING",
    r.JOB_STATE_PARTIALLY_SUCCEEDED = "JOB_STATE_PARTIALLY_SUCCEEDED"
}
)(Xd || (Xd = {}));
var F_;
(function(r) {
    r.ADAPTER_SIZE_UNSPECIFIED = "ADAPTER_SIZE_UNSPECIFIED",
    r.ADAPTER_SIZE_ONE = "ADAPTER_SIZE_ONE",
    r.ADAPTER_SIZE_TWO = "ADAPTER_SIZE_TWO",
    r.ADAPTER_SIZE_FOUR = "ADAPTER_SIZE_FOUR",
    r.ADAPTER_SIZE_EIGHT = "ADAPTER_SIZE_EIGHT",
    r.ADAPTER_SIZE_SIXTEEN = "ADAPTER_SIZE_SIXTEEN",
    r.ADAPTER_SIZE_THIRTY_TWO = "ADAPTER_SIZE_THIRTY_TWO"
}
)(F_ || (F_ = {}));
var H_;
(function(r) {
    r.FEATURE_SELECTION_PREFERENCE_UNSPECIFIED = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED",
    r.PRIORITIZE_QUALITY = "PRIORITIZE_QUALITY",
    r.BALANCED = "BALANCED",
    r.PRIORITIZE_COST = "PRIORITIZE_COST"
}
)(H_ || (H_ = {}));
var G_;
(function(r) {
    r.MODE_UNSPECIFIED = "MODE_UNSPECIFIED",
    r.MODE_DYNAMIC = "MODE_DYNAMIC"
}
)(G_ || (G_ = {}));
var Y_;
(function(r) {
    r.MODE_UNSPECIFIED = "MODE_UNSPECIFIED",
    r.AUTO = "AUTO",
    r.ANY = "ANY",
    r.NONE = "NONE"
}
)(Y_ || (Y_ = {}));
var K_;
(function(r) {
    r.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE",
    r.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE",
    r.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH",
    r.BLOCK_NONE = "BLOCK_NONE"
}
)(K_ || (K_ = {}));
var Q_;
(function(r) {
    r.DONT_ALLOW = "DONT_ALLOW",
    r.ALLOW_ADULT = "ALLOW_ADULT",
    r.ALLOW_ALL = "ALLOW_ALL"
}
)(Q_ || (Q_ = {}));
var X_;
(function(r) {
    r.auto = "auto",
    r.en = "en",
    r.ja = "ja",
    r.ko = "ko",
    r.hi = "hi"
}
)(X_ || (X_ = {}));
var $_;
(function(r) {
    r.STATE_UNSPECIFIED = "STATE_UNSPECIFIED",
    r.PROCESSING = "PROCESSING",
    r.ACTIVE = "ACTIVE",
    r.FAILED = "FAILED"
}
)($_ || ($_ = {}));
var J_;
(function(r) {
    r.SOURCE_UNSPECIFIED = "SOURCE_UNSPECIFIED",
    r.UPLOADED = "UPLOADED",
    r.GENERATED = "GENERATED"
}
)(J_ || (J_ = {}));
var j_;
(function(r) {
    r.MASK_MODE_DEFAULT = "MASK_MODE_DEFAULT",
    r.MASK_MODE_USER_PROVIDED = "MASK_MODE_USER_PROVIDED",
    r.MASK_MODE_BACKGROUND = "MASK_MODE_BACKGROUND",
    r.MASK_MODE_FOREGROUND = "MASK_MODE_FOREGROUND",
    r.MASK_MODE_SEMANTIC = "MASK_MODE_SEMANTIC"
}
)(j_ || (j_ = {}));
var W_;
(function(r) {
    r.CONTROL_TYPE_DEFAULT = "CONTROL_TYPE_DEFAULT",
    r.CONTROL_TYPE_CANNY = "CONTROL_TYPE_CANNY",
    r.CONTROL_TYPE_SCRIBBLE = "CONTROL_TYPE_SCRIBBLE",
    r.CONTROL_TYPE_FACE_MESH = "CONTROL_TYPE_FACE_MESH"
}
)(W_ || (W_ = {}));
var Z_;
(function(r) {
    r.SUBJECT_TYPE_DEFAULT = "SUBJECT_TYPE_DEFAULT",
    r.SUBJECT_TYPE_PERSON = "SUBJECT_TYPE_PERSON",
    r.SUBJECT_TYPE_ANIMAL = "SUBJECT_TYPE_ANIMAL",
    r.SUBJECT_TYPE_PRODUCT = "SUBJECT_TYPE_PRODUCT"
}
)(Z_ || (Z_ = {}));
var eT;
(function(r) {
    r.MODALITY_UNSPECIFIED = "MODALITY_UNSPECIFIED",
    r.TEXT = "TEXT",
    r.IMAGE = "IMAGE",
    r.VIDEO = "VIDEO",
    r.AUDIO = "AUDIO",
    r.DOCUMENT = "DOCUMENT"
}
)(eT || (eT = {}));
var tT;
(function(r) {
    r.START_SENSITIVITY_UNSPECIFIED = "START_SENSITIVITY_UNSPECIFIED",
    r.START_SENSITIVITY_HIGH = "START_SENSITIVITY_HIGH",
    r.START_SENSITIVITY_LOW = "START_SENSITIVITY_LOW"
}
)(tT || (tT = {}));
var nT;
(function(r) {
    r.END_SENSITIVITY_UNSPECIFIED = "END_SENSITIVITY_UNSPECIFIED",
    r.END_SENSITIVITY_HIGH = "END_SENSITIVITY_HIGH",
    r.END_SENSITIVITY_LOW = "END_SENSITIVITY_LOW"
}
)(nT || (nT = {}));
var iT;
(function(r) {
    r.ACTIVITY_HANDLING_UNSPECIFIED = "ACTIVITY_HANDLING_UNSPECIFIED",
    r.START_OF_ACTIVITY_INTERRUPTS = "START_OF_ACTIVITY_INTERRUPTS",
    r.NO_INTERRUPTION = "NO_INTERRUPTION"
}
)(iT || (iT = {}));
var rT;
(function(r) {
    r.TURN_COVERAGE_UNSPECIFIED = "TURN_COVERAGE_UNSPECIFIED",
    r.TURN_INCLUDES_ONLY_ACTIVITY = "TURN_INCLUDES_ONLY_ACTIVITY",
    r.TURN_INCLUDES_ALL_INPUT = "TURN_INCLUDES_ALL_INPUT"
}
)(rT || (rT = {}));
class fc {
    get text() {
        var e, t, s, o, l, f, d, v;
        if (((o = (s = (t = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || t === void 0 ? void 0 : t.content) === null || s === void 0 ? void 0 : s.parts) === null || o === void 0 ? void 0 : o.length) === 0)
            return;
        this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning text from the first one.");
        let y = ""
          , T = !1;
        const A = [];
        for (const I of (v = (d = (f = (l = this.candidates) === null || l === void 0 ? void 0 : l[0]) === null || f === void 0 ? void 0 : f.content) === null || d === void 0 ? void 0 : d.parts) !== null && v !== void 0 ? v : []) {
            for (const [V,q] of Object.entries(I))
                V !== "text" && V !== "thought" && (q !== null || q !== void 0) && A.push(V);
            if (typeof I.text == "string") {
                if (typeof I.thought == "boolean" && I.thought)
                    continue;
                T = !0,
                y += I.text
            }
        }
        return A.length > 0 && console.warn(`there are non-text parts ${A} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`),
        T ? y : void 0
    }
    get data() {
        var e, t, s, o, l, f, d, v;
        if (((o = (s = (t = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || t === void 0 ? void 0 : t.content) === null || s === void 0 ? void 0 : s.parts) === null || o === void 0 ? void 0 : o.length) === 0)
            return;
        this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning data from the first one.");
        let y = "";
        const T = [];
        for (const A of (v = (d = (f = (l = this.candidates) === null || l === void 0 ? void 0 : l[0]) === null || f === void 0 ? void 0 : f.content) === null || d === void 0 ? void 0 : d.parts) !== null && v !== void 0 ? v : []) {
            for (const [I,V] of Object.entries(A))
                I !== "inlineData" && (V !== null || V !== void 0) && T.push(I);
            A.inlineData && typeof A.inlineData.data == "string" && (y += atob(A.inlineData.data))
        }
        return T.length > 0 && console.warn(`there are non-data parts ${T} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`),
        y.length > 0 ? btoa(y) : void 0
    }
    get functionCalls() {
        var e, t, s, o, l, f, d, v;
        if (((o = (s = (t = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || t === void 0 ? void 0 : t.content) === null || s === void 0 ? void 0 : s.parts) === null || o === void 0 ? void 0 : o.length) === 0)
            return;
        this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning function calls from the first one.");
        const y = (v = (d = (f = (l = this.candidates) === null || l === void 0 ? void 0 : l[0]) === null || f === void 0 ? void 0 : f.content) === null || d === void 0 ? void 0 : d.parts) === null || v === void 0 ? void 0 : v.filter(T => T.functionCall).map(T => T.functionCall).filter(T => T !== void 0);
        if ((y == null ? void 0 : y.length) !== 0)
            return y
    }
    get executableCode() {
        var e, t, s, o, l, f, d, v, y;
        if (((o = (s = (t = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || t === void 0 ? void 0 : t.content) === null || s === void 0 ? void 0 : s.parts) === null || o === void 0 ? void 0 : o.length) === 0)
            return;
        this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning executable code from the first one.");
        const T = (v = (d = (f = (l = this.candidates) === null || l === void 0 ? void 0 : l[0]) === null || f === void 0 ? void 0 : f.content) === null || d === void 0 ? void 0 : d.parts) === null || v === void 0 ? void 0 : v.filter(A => A.executableCode).map(A => A.executableCode).filter(A => A !== void 0);
        if ((T == null ? void 0 : T.length) !== 0)
            return (y = T == null ? void 0 : T[0]) === null || y === void 0 ? void 0 : y.code
    }
    get codeExecutionResult() {
        var e, t, s, o, l, f, d, v, y;
        if (((o = (s = (t = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || t === void 0 ? void 0 : t.content) === null || s === void 0 ? void 0 : s.parts) === null || o === void 0 ? void 0 : o.length) === 0)
            return;
        this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning code execution result from the first one.");
        const T = (v = (d = (f = (l = this.candidates) === null || l === void 0 ? void 0 : l[0]) === null || f === void 0 ? void 0 : f.content) === null || d === void 0 ? void 0 : d.parts) === null || v === void 0 ? void 0 : v.filter(A => A.codeExecutionResult).map(A => A.codeExecutionResult).filter(A => A !== void 0);
        if ((T == null ? void 0 : T.length) !== 0)
            return (y = T == null ? void 0 : T[0]) === null || y === void 0 ? void 0 : y.output
    }
}
class sT {
}
class oT {
}
class aT {
}
class lT {
}
class e1 {
}
class uT {
}
class cT {
}
class fT {
}
class t1 {
}
class $d {
    constructor(e) {
        const t = {};
        for (const s of e.headers.entries())
            t[s[0]] = s[1];
        this.headers = t,
        this.responseInternal = e
    }
    json() {
        return this.responseInternal.json()
    }
}
class n1 {
}
class i1 {
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class r1 extends Ol {
    constructor(e) {
        super(),
        this.apiClient = e,
        this.list = async (t={}) => new kp(Sl.PAGED_ITEM_CACHED_CONTENTS,s => this.listInternal(s),await this.listInternal(t),t)
    }
    async create(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = HM(this.apiClient, e);
            return d = Se("cachedContents", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "POST",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(T => T.json()),
            f.then(T => Ac(this.apiClient, T))
        } else {
            const y = bM(this.apiClient, e);
            return d = Se("cachedContents", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "POST",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }).then(T => T.json()),
            f.then(T => Sc(this.apiClient, T))
        }
    }
    async get(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = GM(this.apiClient, e);
            return d = Se("{name}", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "GET",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(T => T.json()),
            f.then(T => Ac(this.apiClient, T))
        } else {
            const y = DM(this.apiClient, e);
            return d = Se("{name}", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "GET",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }).then(T => T.json()),
            f.then(T => Sc(this.apiClient, T))
        }
    }
    async delete(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = YM(this.apiClient, e);
            return d = Se("{name}", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "DELETE",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(T => T.json()),
            f.then( () => {
                const T = WM()
                  , A = new cT;
                return Object.assign(A, T),
                A
            }
            )
        } else {
            const y = MM(this.apiClient, e);
            return d = Se("{name}", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "DELETE",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }).then(T => T.json()),
            f.then( () => {
                const T = JM()
                  , A = new cT;
                return Object.assign(A, T),
                A
            }
            )
        }
    }
    async update(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = QM(this.apiClient, e);
            return d = Se("{name}", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "PATCH",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(T => T.json()),
            f.then(T => Ac(this.apiClient, T))
        } else {
            const y = xM(this.apiClient, e);
            return d = Se("{name}", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "PATCH",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }).then(T => T.json()),
            f.then(T => Sc(this.apiClient, T))
        }
    }
    async listInternal(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = $M(this.apiClient, e);
            return d = Se("cachedContents", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "GET",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(T => T.json()),
            f.then(T => {
                const A = ZM(this.apiClient, T)
                  , I = new fT;
                return Object.assign(I, A),
                I
            }
            )
        } else {
            const y = OM(this.apiClient, e);
            return d = Se("cachedContents", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "GET",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }).then(T => T.json()),
            f.then(T => {
                const A = jM(this.apiClient, T)
                  , I = new fT;
                return Object.assign(I, A),
                I
            }
            )
        }
    }
}
function hT(r) {
    var e = typeof Symbol == "function" && Symbol.iterator
      , t = e && r[e]
      , s = 0;
    if (t)
        return t.call(r);
    if (r && typeof r.length == "number")
        return {
            next: function() {
                return r && s >= r.length && (r = void 0),
                {
                    value: r && r[s++],
                    done: !r
                }
            }
        };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function Xt(r) {
    return this instanceof Xt ? (this.v = r,
    this) : new Xt(r)
}
function Kc(r, e, t) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var s = t.apply(r, e || []), o, l = [];
    return o = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype),
    d("next"),
    d("throw"),
    d("return", f),
    o[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    o;
    function f(V) {
        return function(q) {
            return Promise.resolve(q).then(V, A)
        }
    }
    function d(V, q) {
        s[V] && (o[V] = function(G) {
            return new Promise(function(J, ne) {
                l.push([V, G, J, ne]) > 1 || v(V, G)
            }
            )
        }
        ,
        q && (o[V] = q(o[V])))
    }
    function v(V, q) {
        try {
            y(s[V](q))
        } catch (G) {
            I(l[0][3], G)
        }
    }
    function y(V) {
        V.value instanceof Xt ? Promise.resolve(V.value.v).then(T, A) : I(l[0][2], V)
    }
    function T(V) {
        v("next", V)
    }
    function A(V) {
        v("throw", V)
    }
    function I(V, q) {
        V(q),
        l.shift(),
        l.length && v(l[0][0], l[0][1])
    }
}
function Jd(r) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = r[Symbol.asyncIterator], t;
    return e ? e.call(r) : (r = typeof hT == "function" ? hT(r) : r[Symbol.iterator](),
    t = {},
    s("next"),
    s("throw"),
    s("return"),
    t[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    t);
    function s(l) {
        t[l] = r[l] && function(f) {
            return new Promise(function(d, v) {
                f = r[l](f),
                o(d, v, f.done, f.value)
            }
            )
        }
    }
    function o(l, f, d, v) {
        Promise.resolve(v).then(function(y) {
            l({
                value: y,
                done: d
            })
        }, f)
    }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function s1(r) {
    var e;
    if (r.candidates == null || r.candidates.length === 0)
        return !1;
    const t = (e = r.candidates[0]) === null || e === void 0 ? void 0 : e.content;
    return t === void 0 ? !1 : P0(t)
}
function P0(r) {
    if (r.parts === void 0 || r.parts.length === 0)
        return !1;
    for (const e of r.parts)
        if (e === void 0 || Object.keys(e).length === 0 || e.text !== void 0 && e.text === "")
            return !1;
    return !0
}
function o1(r) {
    if (r.length !== 0) {
        if (r[0].role !== "user")
            throw new Error("History must start with a user turn.");
        for (const e of r)
            if (e.role !== "user" && e.role !== "model")
                throw new Error(`Role must be user or model, but got ${e.role}.`)
    }
}
function a1(r) {
    if (r === void 0 || r.length === 0)
        return [];
    const e = []
      , t = r.length;
    let s = 0
      , o = r[0];
    for (; s < t; )
        if (r[s].role === "user")
            o = r[s],
            s++;
        else {
            const l = [];
            let f = !0;
            for (; s < t && r[s].role === "model"; )
                l.push(r[s]),
                f && !P0(r[s]) && (f = !1),
                s++;
            f && (e.push(o),
            e.push(...l))
        }
    return e
}
class l1 {
    constructor(e, t) {
        this.modelsModule = e,
        this.apiClient = t
    }
    create(e) {
        return new u1(this.apiClient,this.modelsModule,e.model,e.config,e.history)
    }
}
class u1 {
    constructor(e, t, s, o={}, l=[]) {
        this.apiClient = e,
        this.modelsModule = t,
        this.model = s,
        this.config = o,
        this.history = l,
        this.sendPromise = Promise.resolve(),
        o1(l)
    }
    async sendMessage(e) {
        var t;
        await this.sendPromise;
        const s = on(this.apiClient, e.message)
          , o = this.modelsModule.generateContent({
            model: this.model,
            contents: this.getHistory(!0).concat(s),
            config: (t = e.config) !== null && t !== void 0 ? t : this.config
        });
        return this.sendPromise = (async () => {
            var l, f;
            const v = (f = (l = (await o).candidates) === null || l === void 0 ? void 0 : l[0]) === null || f === void 0 ? void 0 : f.content
              , y = v ? [v] : [];
            this.recordHistory(s, y)
        }
        )(),
        await this.sendPromise,
        o
    }
    async sendMessageStream(e) {
        var t;
        await this.sendPromise;
        const s = on(this.apiClient, e.message)
          , o = this.modelsModule.generateContentStream({
            model: this.model,
            contents: this.getHistory(!0).concat(s),
            config: (t = e.config) !== null && t !== void 0 ? t : this.config
        });
        this.sendPromise = o.then( () => {}
        ).catch( () => {}
        );
        const l = await o;
        return this.processStreamResponse(l, s)
    }
    getHistory(e=!1) {
        return e ? a1(this.history) : this.history
    }
    processStreamResponse(e, t) {
        var s, o;
        return Kc(this, arguments, function*() {
            var f, d, v, y;
            const T = [];
            try {
                for (var A = !0, I = Jd(e), V; V = yield Xt(I.next()),
                f = V.done,
                !f; A = !0) {
                    y = V.value,
                    A = !1;
                    const q = y;
                    if (s1(q)) {
                        const G = (o = (s = q.candidates) === null || s === void 0 ? void 0 : s[0]) === null || o === void 0 ? void 0 : o.content;
                        G !== void 0 && T.push(G)
                    }
                    yield yield Xt(q)
                }
            } catch (q) {
                d = {
                    error: q
                }
            } finally {
                try {
                    !A && !f && (v = I.return) && (yield Xt(v.call(I)))
                } finally {
                    if (d)
                        throw d.error
                }
            }
            this.recordHistory(t, T)
        })
    }
    recordHistory(e, t) {
        let s = [];
        t.length > 0 && t.every(o => o.role === "model") ? s = t : s.push({
            role: "model",
            parts: []
        }),
        this.history.push(e),
        this.history.push(...s)
    }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function c1(r, e, t) {
    const s = {}
      , o = p(e, ["pageSize"]);
    t !== void 0 && o != null && m(t, ["_query", "pageSize"], o);
    const l = p(e, ["pageToken"]);
    return t !== void 0 && l != null && m(t, ["_query", "pageToken"], l),
    s
}
function f1(r, e) {
    const t = {}
      , s = p(e, ["config"]);
    return s != null && m(t, ["config"], c1(r, s, t)),
    t
}
function h1(r, e) {
    const t = {}
      , s = p(e, ["details"]);
    s != null && m(t, ["details"], s);
    const o = p(e, ["message"]);
    o != null && m(t, ["message"], o);
    const l = p(e, ["code"]);
    return l != null && m(t, ["code"], l),
    t
}
function d1(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["name"], s);
    const o = p(e, ["displayName"]);
    o != null && m(t, ["displayName"], o);
    const l = p(e, ["mimeType"]);
    l != null && m(t, ["mimeType"], l);
    const f = p(e, ["sizeBytes"]);
    f != null && m(t, ["sizeBytes"], f);
    const d = p(e, ["createTime"]);
    d != null && m(t, ["createTime"], d);
    const v = p(e, ["expirationTime"]);
    v != null && m(t, ["expirationTime"], v);
    const y = p(e, ["updateTime"]);
    y != null && m(t, ["updateTime"], y);
    const T = p(e, ["sha256Hash"]);
    T != null && m(t, ["sha256Hash"], T);
    const A = p(e, ["uri"]);
    A != null && m(t, ["uri"], A);
    const I = p(e, ["downloadUri"]);
    I != null && m(t, ["downloadUri"], I);
    const V = p(e, ["state"]);
    V != null && m(t, ["state"], V);
    const q = p(e, ["source"]);
    q != null && m(t, ["source"], q);
    const G = p(e, ["videoMetadata"]);
    G != null && m(t, ["videoMetadata"], G);
    const J = p(e, ["error"]);
    return J != null && m(t, ["error"], h1(r, J)),
    t
}
function p1(r, e) {
    const t = {}
      , s = p(e, ["file"]);
    s != null && m(t, ["file"], d1(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], o),
    t
}
function m1(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["_url", "file"], x0(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], o),
    t
}
function g1(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["_url", "file"], x0(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], o),
    t
}
function y1(r, e) {
    const t = {}
      , s = p(e, ["details"]);
    s != null && m(t, ["details"], s);
    const o = p(e, ["message"]);
    o != null && m(t, ["message"], o);
    const l = p(e, ["code"]);
    return l != null && m(t, ["code"], l),
    t
}
function jd(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["name"], s);
    const o = p(e, ["displayName"]);
    o != null && m(t, ["displayName"], o);
    const l = p(e, ["mimeType"]);
    l != null && m(t, ["mimeType"], l);
    const f = p(e, ["sizeBytes"]);
    f != null && m(t, ["sizeBytes"], f);
    const d = p(e, ["createTime"]);
    d != null && m(t, ["createTime"], d);
    const v = p(e, ["expirationTime"]);
    v != null && m(t, ["expirationTime"], v);
    const y = p(e, ["updateTime"]);
    y != null && m(t, ["updateTime"], y);
    const T = p(e, ["sha256Hash"]);
    T != null && m(t, ["sha256Hash"], T);
    const A = p(e, ["uri"]);
    A != null && m(t, ["uri"], A);
    const I = p(e, ["downloadUri"]);
    I != null && m(t, ["downloadUri"], I);
    const V = p(e, ["state"]);
    V != null && m(t, ["state"], V);
    const q = p(e, ["source"]);
    q != null && m(t, ["source"], q);
    const G = p(e, ["videoMetadata"]);
    G != null && m(t, ["videoMetadata"], G);
    const J = p(e, ["error"]);
    return J != null && m(t, ["error"], y1(r, J)),
    t
}
function v1(r, e) {
    const t = {}
      , s = p(e, ["nextPageToken"]);
    s != null && m(t, ["nextPageToken"], s);
    const o = p(e, ["files"]);
    if (o != null) {
        let l = o;
        Array.isArray(l) && (l = l.map(f => jd(r, f))),
        m(t, ["files"], l)
    }
    return t
}
function _1() {
    return {}
}
function T1() {
    return {}
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class E1 extends Ol {
    constructor(e) {
        super(),
        this.apiClient = e,
        this.list = async (t={}) => new kp(Sl.PAGED_ITEM_FILES,s => this.listInternal(s),await this.listInternal(t),t)
    }
    async upload(e) {
        if (this.apiClient.isVertexAI())
            throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");
        return this.apiClient.uploadFile(e.file, e.config).then(t => jd(this.apiClient, t))
    }
    async listInternal(e) {
        var t, s;
        let o, l = "", f = {};
        if (this.apiClient.isVertexAI())
            throw new Error("This method is only supported by the Gemini Developer API.");
        {
            const d = f1(this.apiClient, e);
            return l = Se("files", d._url),
            f = d._query,
            delete d.config,
            delete d._url,
            delete d._query,
            o = this.apiClient.request({
                path: l,
                queryParams: f,
                body: JSON.stringify(d),
                httpMethod: "GET",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(v => v.json()),
            o.then(v => {
                const y = v1(this.apiClient, v)
                  , T = new t1;
                return Object.assign(T, y),
                T
            }
            )
        }
    }
    async createInternal(e) {
        var t, s;
        let o, l = "", f = {};
        if (this.apiClient.isVertexAI())
            throw new Error("This method is only supported by the Gemini Developer API.");
        {
            const d = p1(this.apiClient, e);
            return l = Se("upload/v1beta/files", d._url),
            f = d._query,
            delete d.config,
            delete d._url,
            delete d._query,
            o = this.apiClient.request({
                path: l,
                queryParams: f,
                body: JSON.stringify(d),
                httpMethod: "POST",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(v => v.json()),
            o.then( () => {
                const v = _1()
                  , y = new n1;
                return Object.assign(y, v),
                y
            }
            )
        }
    }
    async get(e) {
        var t, s;
        let o, l = "", f = {};
        if (this.apiClient.isVertexAI())
            throw new Error("This method is only supported by the Gemini Developer API.");
        {
            const d = m1(this.apiClient, e);
            return l = Se("files/{file}", d._url),
            f = d._query,
            delete d.config,
            delete d._url,
            delete d._query,
            o = this.apiClient.request({
                path: l,
                queryParams: f,
                body: JSON.stringify(d),
                httpMethod: "GET",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(v => v.json()),
            o.then(v => jd(this.apiClient, v))
        }
    }
    async delete(e) {
        var t, s;
        let o, l = "", f = {};
        if (this.apiClient.isVertexAI())
            throw new Error("This method is only supported by the Gemini Developer API.");
        {
            const d = g1(this.apiClient, e);
            return l = Se("files/{file}", d._url),
            f = d._query,
            delete d.config,
            delete d._url,
            delete d._query,
            o = this.apiClient.request({
                path: l,
                queryParams: f,
                body: JSON.stringify(d),
                httpMethod: "DELETE",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(v => v.json()),
            o.then( () => {
                const v = T1()
                  , y = new i1;
                return Object.assign(y, v),
                y
            }
            )
        }
    }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function S1(r, e) {
    const t = {};
    if (p(e, ["videoMetadata"]) !== void 0)
        throw new Error("videoMetadata parameter is not supported in Gemini API.");
    const s = p(e, ["thought"]);
    s != null && m(t, ["thought"], s);
    const o = p(e, ["codeExecutionResult"]);
    o != null && m(t, ["codeExecutionResult"], o);
    const l = p(e, ["executableCode"]);
    l != null && m(t, ["executableCode"], l);
    const f = p(e, ["fileData"]);
    f != null && m(t, ["fileData"], f);
    const d = p(e, ["functionCall"]);
    d != null && m(t, ["functionCall"], d);
    const v = p(e, ["functionResponse"]);
    v != null && m(t, ["functionResponse"], v);
    const y = p(e, ["inlineData"]);
    y != null && m(t, ["inlineData"], y);
    const T = p(e, ["text"]);
    return T != null && m(t, ["text"], T),
    t
}
function A1(r, e) {
    const t = {}
      , s = p(e, ["videoMetadata"]);
    s != null && m(t, ["videoMetadata"], s);
    const o = p(e, ["thought"]);
    o != null && m(t, ["thought"], o);
    const l = p(e, ["codeExecutionResult"]);
    l != null && m(t, ["codeExecutionResult"], l);
    const f = p(e, ["executableCode"]);
    f != null && m(t, ["executableCode"], f);
    const d = p(e, ["fileData"]);
    d != null && m(t, ["fileData"], d);
    const v = p(e, ["functionCall"]);
    v != null && m(t, ["functionCall"], v);
    const y = p(e, ["functionResponse"]);
    y != null && m(t, ["functionResponse"], y);
    const T = p(e, ["inlineData"]);
    T != null && m(t, ["inlineData"], T);
    const A = p(e, ["text"]);
    return A != null && m(t, ["text"], A),
    t
}
function C1(r, e) {
    const t = {}
      , s = p(e, ["parts"]);
    if (s != null) {
        let l = s;
        Array.isArray(l) && (l = l.map(f => S1(r, f))),
        m(t, ["parts"], l)
    }
    const o = p(e, ["role"]);
    return o != null && m(t, ["role"], o),
    t
}
function R1(r, e) {
    const t = {}
      , s = p(e, ["parts"]);
    if (s != null) {
        let l = s;
        Array.isArray(l) && (l = l.map(f => A1(r, f))),
        m(t, ["parts"], l)
    }
    const o = p(e, ["role"]);
    return o != null && m(t, ["role"], o),
    t
}
function I1() {
    return {}
}
function w1() {
    return {}
}
function b1(r, e) {
    const t = {}
      , s = p(e, ["mode"]);
    s != null && m(t, ["mode"], s);
    const o = p(e, ["dynamicThreshold"]);
    return o != null && m(t, ["dynamicThreshold"], o),
    t
}
function D1(r, e) {
    const t = {}
      , s = p(e, ["mode"]);
    s != null && m(t, ["mode"], s);
    const o = p(e, ["dynamicThreshold"]);
    return o != null && m(t, ["dynamicThreshold"], o),
    t
}
function M1(r, e) {
    const t = {}
      , s = p(e, ["dynamicRetrievalConfig"]);
    return s != null && m(t, ["dynamicRetrievalConfig"], b1(r, s)),
    t
}
function N1(r, e) {
    const t = {}
      , s = p(e, ["dynamicRetrievalConfig"]);
    return s != null && m(t, ["dynamicRetrievalConfig"], D1(r, s)),
    t
}
function x1(r, e) {
    const t = {};
    if (p(e, ["retrieval"]) !== void 0)
        throw new Error("retrieval parameter is not supported in Gemini API.");
    p(e, ["googleSearch"]) != null && m(t, ["googleSearch"], I1());
    const o = p(e, ["googleSearchRetrieval"]);
    o != null && m(t, ["googleSearchRetrieval"], M1(r, o));
    const l = p(e, ["codeExecution"]);
    l != null && m(t, ["codeExecution"], l);
    const f = p(e, ["functionDeclarations"]);
    return f != null && m(t, ["functionDeclarations"], f),
    t
}
function P1(r, e) {
    const t = {}
      , s = p(e, ["retrieval"]);
    s != null && m(t, ["retrieval"], s),
    p(e, ["googleSearch"]) != null && m(t, ["googleSearch"], w1());
    const l = p(e, ["googleSearchRetrieval"]);
    l != null && m(t, ["googleSearchRetrieval"], N1(r, l));
    const f = p(e, ["codeExecution"]);
    f != null && m(t, ["codeExecution"], f);
    const d = p(e, ["functionDeclarations"]);
    return d != null && m(t, ["functionDeclarations"], d),
    t
}
function O1(r, e) {
    const t = {}
      , s = p(e, ["handle"]);
    if (s != null && m(t, ["handle"], s),
    p(e, ["transparent"]) !== void 0)
        throw new Error("transparent parameter is not supported in Gemini API.");
    return t
}
function V1(r, e) {
    const t = {}
      , s = p(e, ["handle"]);
    s != null && m(t, ["handle"], s);
    const o = p(e, ["transparent"]);
    return o != null && m(t, ["transparent"], o),
    t
}
function U1() {
    return {}
}
function dT() {
    return {}
}
function k1(r, e) {
    const t = {}
      , s = p(e, ["disabled"]);
    s != null && m(t, ["disabled"], s);
    const o = p(e, ["startOfSpeechSensitivity"]);
    o != null && m(t, ["startOfSpeechSensitivity"], o);
    const l = p(e, ["endOfSpeechSensitivity"]);
    l != null && m(t, ["endOfSpeechSensitivity"], l);
    const f = p(e, ["prefixPaddingMs"]);
    f != null && m(t, ["prefixPaddingMs"], f);
    const d = p(e, ["silenceDurationMs"]);
    return d != null && m(t, ["silenceDurationMs"], d),
    t
}
function L1(r, e) {
    const t = {}
      , s = p(e, ["disabled"]);
    s != null && m(t, ["disabled"], s);
    const o = p(e, ["startOfSpeechSensitivity"]);
    o != null && m(t, ["startOfSpeechSensitivity"], o);
    const l = p(e, ["endOfSpeechSensitivity"]);
    l != null && m(t, ["endOfSpeechSensitivity"], l);
    const f = p(e, ["prefixPaddingMs"]);
    f != null && m(t, ["prefixPaddingMs"], f);
    const d = p(e, ["silenceDurationMs"]);
    return d != null && m(t, ["silenceDurationMs"], d),
    t
}
function B1(r, e) {
    const t = {}
      , s = p(e, ["automaticActivityDetection"]);
    s != null && m(t, ["automaticActivityDetection"], k1(r, s));
    const o = p(e, ["activityHandling"]);
    o != null && m(t, ["activityHandling"], o);
    const l = p(e, ["turnCoverage"]);
    return l != null && m(t, ["turnCoverage"], l),
    t
}
function q1(r, e) {
    const t = {}
      , s = p(e, ["automaticActivityDetection"]);
    s != null && m(t, ["automaticActivityDetection"], L1(r, s));
    const o = p(e, ["activityHandling"]);
    o != null && m(t, ["activityHandling"], o);
    const l = p(e, ["turnCoverage"]);
    return l != null && m(t, ["turnCoverage"], l),
    t
}
function z1(r, e) {
    const t = {}
      , s = p(e, ["targetTokens"]);
    return s != null && m(t, ["targetTokens"], s),
    t
}
function F1(r, e) {
    const t = {}
      , s = p(e, ["targetTokens"]);
    return s != null && m(t, ["targetTokens"], s),
    t
}
function H1(r, e) {
    const t = {}
      , s = p(e, ["triggerTokens"]);
    s != null && m(t, ["triggerTokens"], s);
    const o = p(e, ["slidingWindow"]);
    return o != null && m(t, ["slidingWindow"], z1(r, o)),
    t
}
function G1(r, e) {
    const t = {}
      , s = p(e, ["triggerTokens"]);
    s != null && m(t, ["triggerTokens"], s);
    const o = p(e, ["slidingWindow"]);
    return o != null && m(t, ["slidingWindow"], F1(r, o)),
    t
}
function Y1(r, e, t) {
    const s = {}
      , o = p(e, ["generationConfig"]);
    t !== void 0 && o != null && m(t, ["setup", "generationConfig"], o);
    const l = p(e, ["responseModalities"]);
    t !== void 0 && l != null && m(t, ["setup", "generationConfig", "responseModalities"], l);
    const f = p(e, ["temperature"]);
    t !== void 0 && f != null && m(t, ["setup", "generationConfig", "temperature"], f);
    const d = p(e, ["topP"]);
    t !== void 0 && d != null && m(t, ["setup", "generationConfig", "topP"], d);
    const v = p(e, ["topK"]);
    t !== void 0 && v != null && m(t, ["setup", "generationConfig", "topK"], v);
    const y = p(e, ["maxOutputTokens"]);
    t !== void 0 && y != null && m(t, ["setup", "generationConfig", "maxOutputTokens"], y);
    const T = p(e, ["mediaResolution"]);
    t !== void 0 && T != null && m(t, ["setup", "generationConfig", "mediaResolution"], T);
    const A = p(e, ["seed"]);
    t !== void 0 && A != null && m(t, ["setup", "generationConfig", "seed"], A);
    const I = p(e, ["speechConfig"]);
    t !== void 0 && I != null && m(t, ["setup", "generationConfig", "speechConfig"], I);
    const V = p(e, ["systemInstruction"]);
    t !== void 0 && V != null && m(t, ["setup", "systemInstruction"], C1(r, on(r, V)));
    const q = p(e, ["tools"]);
    if (t !== void 0 && q != null) {
        let le = af(r, q);
        Array.isArray(le) && (le = le.map(ue => x1(r, of(r, ue)))),
        m(t, ["setup", "tools"], le)
    }
    const G = p(e, ["sessionResumption"]);
    if (t !== void 0 && G != null && m(t, ["setup", "sessionResumption"], O1(r, G)),
    p(e, ["inputAudioTranscription"]) !== void 0)
        throw new Error("inputAudioTranscription parameter is not supported in Gemini API.");
    const J = p(e, ["outputAudioTranscription"]);
    t !== void 0 && J != null && m(t, ["setup", "outputAudioTranscription"], U1());
    const ne = p(e, ["realtimeInputConfig"]);
    t !== void 0 && ne != null && m(t, ["setup", "realtimeInputConfig"], B1(r, ne));
    const se = p(e, ["contextWindowCompression"]);
    return t !== void 0 && se != null && m(t, ["setup", "contextWindowCompression"], H1(r, se)),
    s
}
function K1(r, e, t) {
    const s = {}
      , o = p(e, ["generationConfig"]);
    t !== void 0 && o != null && m(t, ["setup", "generationConfig"], o);
    const l = p(e, ["responseModalities"]);
    t !== void 0 && l != null && m(t, ["setup", "generationConfig", "responseModalities"], l);
    const f = p(e, ["temperature"]);
    t !== void 0 && f != null && m(t, ["setup", "generationConfig", "temperature"], f);
    const d = p(e, ["topP"]);
    t !== void 0 && d != null && m(t, ["setup", "generationConfig", "topP"], d);
    const v = p(e, ["topK"]);
    t !== void 0 && v != null && m(t, ["setup", "generationConfig", "topK"], v);
    const y = p(e, ["maxOutputTokens"]);
    t !== void 0 && y != null && m(t, ["setup", "generationConfig", "maxOutputTokens"], y);
    const T = p(e, ["mediaResolution"]);
    t !== void 0 && T != null && m(t, ["setup", "generationConfig", "mediaResolution"], T);
    const A = p(e, ["seed"]);
    t !== void 0 && A != null && m(t, ["setup", "generationConfig", "seed"], A);
    const I = p(e, ["speechConfig"]);
    t !== void 0 && I != null && m(t, ["setup", "generationConfig", "speechConfig"], I);
    const V = p(e, ["systemInstruction"]);
    t !== void 0 && V != null && m(t, ["setup", "systemInstruction"], R1(r, on(r, V)));
    const q = p(e, ["tools"]);
    if (t !== void 0 && q != null) {
        let ue = af(r, q);
        Array.isArray(ue) && (ue = ue.map(fe => P1(r, of(r, fe)))),
        m(t, ["setup", "tools"], ue)
    }
    const G = p(e, ["sessionResumption"]);
    t !== void 0 && G != null && m(t, ["setup", "sessionResumption"], V1(r, G));
    const J = p(e, ["inputAudioTranscription"]);
    t !== void 0 && J != null && m(t, ["setup", "inputAudioTranscription"], dT());
    const ne = p(e, ["outputAudioTranscription"]);
    t !== void 0 && ne != null && m(t, ["setup", "outputAudioTranscription"], dT());
    const se = p(e, ["realtimeInputConfig"]);
    t !== void 0 && se != null && m(t, ["setup", "realtimeInputConfig"], q1(r, se));
    const le = p(e, ["contextWindowCompression"]);
    return t !== void 0 && le != null && m(t, ["setup", "contextWindowCompression"], G1(r, le)),
    s
}
function Q1(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["setup", "model"], ut(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], Y1(r, o, t)),
    t
}
function X1(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["setup", "model"], ut(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], K1(r, o, t)),
    t
}
function $1() {
    return {}
}
function J1() {
    return {}
}
function j1() {
    return {}
}
function W1() {
    return {}
}
function Z1(r, e) {
    const t = {}
      , s = p(e, ["media"]);
    s != null && m(t, ["mediaChunks"], I0(r, s));
    const o = p(e, ["audio"]);
    o != null && m(t, ["audio"], vM(r, o));
    const l = p(e, ["audioStreamEnd"]);
    l != null && m(t, ["audioStreamEnd"], l);
    const f = p(e, ["video"]);
    f != null && m(t, ["video"], yM(r, f));
    const d = p(e, ["text"]);
    return d != null && m(t, ["text"], d),
    p(e, ["activityStart"]) != null && m(t, ["activityStart"], $1()),
    p(e, ["activityEnd"]) != null && m(t, ["activityEnd"], j1()),
    t
}
function eN(r, e) {
    const t = {}
      , s = p(e, ["media"]);
    if (s != null && m(t, ["mediaChunks"], I0(r, s)),
    p(e, ["audio"]) !== void 0)
        throw new Error("audio parameter is not supported in Vertex AI.");
    const o = p(e, ["audioStreamEnd"]);
    if (o != null && m(t, ["audioStreamEnd"], o),
    p(e, ["video"]) !== void 0)
        throw new Error("video parameter is not supported in Vertex AI.");
    if (p(e, ["text"]) !== void 0)
        throw new Error("text parameter is not supported in Vertex AI.");
    return p(e, ["activityStart"]) != null && m(t, ["activityStart"], J1()),
    p(e, ["activityEnd"]) != null && m(t, ["activityEnd"], W1()),
    t
}
function tN() {
    return {}
}
function nN() {
    return {}
}
function iN(r, e) {
    const t = {}
      , s = p(e, ["thought"]);
    s != null && m(t, ["thought"], s);
    const o = p(e, ["codeExecutionResult"]);
    o != null && m(t, ["codeExecutionResult"], o);
    const l = p(e, ["executableCode"]);
    l != null && m(t, ["executableCode"], l);
    const f = p(e, ["fileData"]);
    f != null && m(t, ["fileData"], f);
    const d = p(e, ["functionCall"]);
    d != null && m(t, ["functionCall"], d);
    const v = p(e, ["functionResponse"]);
    v != null && m(t, ["functionResponse"], v);
    const y = p(e, ["inlineData"]);
    y != null && m(t, ["inlineData"], y);
    const T = p(e, ["text"]);
    return T != null && m(t, ["text"], T),
    t
}
function rN(r, e) {
    const t = {}
      , s = p(e, ["videoMetadata"]);
    s != null && m(t, ["videoMetadata"], s);
    const o = p(e, ["thought"]);
    o != null && m(t, ["thought"], o);
    const l = p(e, ["codeExecutionResult"]);
    l != null && m(t, ["codeExecutionResult"], l);
    const f = p(e, ["executableCode"]);
    f != null && m(t, ["executableCode"], f);
    const d = p(e, ["fileData"]);
    d != null && m(t, ["fileData"], d);
    const v = p(e, ["functionCall"]);
    v != null && m(t, ["functionCall"], v);
    const y = p(e, ["functionResponse"]);
    y != null && m(t, ["functionResponse"], y);
    const T = p(e, ["inlineData"]);
    T != null && m(t, ["inlineData"], T);
    const A = p(e, ["text"]);
    return A != null && m(t, ["text"], A),
    t
}
function sN(r, e) {
    const t = {}
      , s = p(e, ["parts"]);
    if (s != null) {
        let l = s;
        Array.isArray(l) && (l = l.map(f => iN(r, f))),
        m(t, ["parts"], l)
    }
    const o = p(e, ["role"]);
    return o != null && m(t, ["role"], o),
    t
}
function oN(r, e) {
    const t = {}
      , s = p(e, ["parts"]);
    if (s != null) {
        let l = s;
        Array.isArray(l) && (l = l.map(f => rN(r, f))),
        m(t, ["parts"], l)
    }
    const o = p(e, ["role"]);
    return o != null && m(t, ["role"], o),
    t
}
function pT(r, e) {
    const t = {}
      , s = p(e, ["text"]);
    s != null && m(t, ["text"], s);
    const o = p(e, ["finished"]);
    return o != null && m(t, ["finished"], o),
    t
}
function mT(r, e) {
    const t = {}
      , s = p(e, ["text"]);
    s != null && m(t, ["text"], s);
    const o = p(e, ["finished"]);
    return o != null && m(t, ["finished"], o),
    t
}
function aN(r, e) {
    const t = {}
      , s = p(e, ["modelTurn"]);
    s != null && m(t, ["modelTurn"], sN(r, s));
    const o = p(e, ["turnComplete"]);
    o != null && m(t, ["turnComplete"], o);
    const l = p(e, ["interrupted"]);
    l != null && m(t, ["interrupted"], l);
    const f = p(e, ["groundingMetadata"]);
    f != null && m(t, ["groundingMetadata"], f);
    const d = p(e, ["generationComplete"]);
    d != null && m(t, ["generationComplete"], d);
    const v = p(e, ["inputTranscription"]);
    v != null && m(t, ["inputTranscription"], pT(r, v));
    const y = p(e, ["outputTranscription"]);
    return y != null && m(t, ["outputTranscription"], pT(r, y)),
    t
}
function lN(r, e) {
    const t = {}
      , s = p(e, ["modelTurn"]);
    s != null && m(t, ["modelTurn"], oN(r, s));
    const o = p(e, ["turnComplete"]);
    o != null && m(t, ["turnComplete"], o);
    const l = p(e, ["interrupted"]);
    l != null && m(t, ["interrupted"], l);
    const f = p(e, ["groundingMetadata"]);
    f != null && m(t, ["groundingMetadata"], f);
    const d = p(e, ["generationComplete"]);
    d != null && m(t, ["generationComplete"], d);
    const v = p(e, ["inputTranscription"]);
    v != null && m(t, ["inputTranscription"], mT(r, v));
    const y = p(e, ["outputTranscription"]);
    return y != null && m(t, ["outputTranscription"], mT(r, y)),
    t
}
function uN(r, e) {
    const t = {}
      , s = p(e, ["id"]);
    s != null && m(t, ["id"], s);
    const o = p(e, ["args"]);
    o != null && m(t, ["args"], o);
    const l = p(e, ["name"]);
    return l != null && m(t, ["name"], l),
    t
}
function cN(r, e) {
    const t = {}
      , s = p(e, ["args"]);
    s != null && m(t, ["args"], s);
    const o = p(e, ["name"]);
    return o != null && m(t, ["name"], o),
    t
}
function fN(r, e) {
    const t = {}
      , s = p(e, ["functionCalls"]);
    if (s != null) {
        let o = s;
        Array.isArray(o) && (o = o.map(l => uN(r, l))),
        m(t, ["functionCalls"], o)
    }
    return t
}
function hN(r, e) {
    const t = {}
      , s = p(e, ["functionCalls"]);
    if (s != null) {
        let o = s;
        Array.isArray(o) && (o = o.map(l => cN(r, l))),
        m(t, ["functionCalls"], o)
    }
    return t
}
function dN(r, e) {
    const t = {}
      , s = p(e, ["ids"]);
    return s != null && m(t, ["ids"], s),
    t
}
function pN(r, e) {
    const t = {}
      , s = p(e, ["ids"]);
    return s != null && m(t, ["ids"], s),
    t
}
function hc(r, e) {
    const t = {}
      , s = p(e, ["modality"]);
    s != null && m(t, ["modality"], s);
    const o = p(e, ["tokenCount"]);
    return o != null && m(t, ["tokenCount"], o),
    t
}
function dc(r, e) {
    const t = {}
      , s = p(e, ["modality"]);
    s != null && m(t, ["modality"], s);
    const o = p(e, ["tokenCount"]);
    return o != null && m(t, ["tokenCount"], o),
    t
}
function mN(r, e) {
    const t = {}
      , s = p(e, ["promptTokenCount"]);
    s != null && m(t, ["promptTokenCount"], s);
    const o = p(e, ["cachedContentTokenCount"]);
    o != null && m(t, ["cachedContentTokenCount"], o);
    const l = p(e, ["responseTokenCount"]);
    l != null && m(t, ["responseTokenCount"], l);
    const f = p(e, ["toolUsePromptTokenCount"]);
    f != null && m(t, ["toolUsePromptTokenCount"], f);
    const d = p(e, ["thoughtsTokenCount"]);
    d != null && m(t, ["thoughtsTokenCount"], d);
    const v = p(e, ["totalTokenCount"]);
    v != null && m(t, ["totalTokenCount"], v);
    const y = p(e, ["promptTokensDetails"]);
    if (y != null) {
        let V = y;
        Array.isArray(V) && (V = V.map(q => hc(r, q))),
        m(t, ["promptTokensDetails"], V)
    }
    const T = p(e, ["cacheTokensDetails"]);
    if (T != null) {
        let V = T;
        Array.isArray(V) && (V = V.map(q => hc(r, q))),
        m(t, ["cacheTokensDetails"], V)
    }
    const A = p(e, ["responseTokensDetails"]);
    if (A != null) {
        let V = A;
        Array.isArray(V) && (V = V.map(q => hc(r, q))),
        m(t, ["responseTokensDetails"], V)
    }
    const I = p(e, ["toolUsePromptTokensDetails"]);
    if (I != null) {
        let V = I;
        Array.isArray(V) && (V = V.map(q => hc(r, q))),
        m(t, ["toolUsePromptTokensDetails"], V)
    }
    return t
}
function gN(r, e) {
    const t = {}
      , s = p(e, ["promptTokenCount"]);
    s != null && m(t, ["promptTokenCount"], s);
    const o = p(e, ["cachedContentTokenCount"]);
    o != null && m(t, ["cachedContentTokenCount"], o);
    const l = p(e, ["candidatesTokenCount"]);
    l != null && m(t, ["responseTokenCount"], l);
    const f = p(e, ["toolUsePromptTokenCount"]);
    f != null && m(t, ["toolUsePromptTokenCount"], f);
    const d = p(e, ["thoughtsTokenCount"]);
    d != null && m(t, ["thoughtsTokenCount"], d);
    const v = p(e, ["totalTokenCount"]);
    v != null && m(t, ["totalTokenCount"], v);
    const y = p(e, ["promptTokensDetails"]);
    if (y != null) {
        let q = y;
        Array.isArray(q) && (q = q.map(G => dc(r, G))),
        m(t, ["promptTokensDetails"], q)
    }
    const T = p(e, ["cacheTokensDetails"]);
    if (T != null) {
        let q = T;
        Array.isArray(q) && (q = q.map(G => dc(r, G))),
        m(t, ["cacheTokensDetails"], q)
    }
    const A = p(e, ["candidatesTokensDetails"]);
    if (A != null) {
        let q = A;
        Array.isArray(q) && (q = q.map(G => dc(r, G))),
        m(t, ["responseTokensDetails"], q)
    }
    const I = p(e, ["toolUsePromptTokensDetails"]);
    if (I != null) {
        let q = I;
        Array.isArray(q) && (q = q.map(G => dc(r, G))),
        m(t, ["toolUsePromptTokensDetails"], q)
    }
    const V = p(e, ["trafficType"]);
    return V != null && m(t, ["trafficType"], V),
    t
}
function yN(r, e) {
    const t = {}
      , s = p(e, ["timeLeft"]);
    return s != null && m(t, ["timeLeft"], s),
    t
}
function vN(r, e) {
    const t = {}
      , s = p(e, ["timeLeft"]);
    return s != null && m(t, ["timeLeft"], s),
    t
}
function _N(r, e) {
    const t = {}
      , s = p(e, ["newHandle"]);
    s != null && m(t, ["newHandle"], s);
    const o = p(e, ["resumable"]);
    o != null && m(t, ["resumable"], o);
    const l = p(e, ["lastConsumedClientMessageIndex"]);
    return l != null && m(t, ["lastConsumedClientMessageIndex"], l),
    t
}
function TN(r, e) {
    const t = {}
      , s = p(e, ["newHandle"]);
    s != null && m(t, ["newHandle"], s);
    const o = p(e, ["resumable"]);
    o != null && m(t, ["resumable"], o);
    const l = p(e, ["lastConsumedClientMessageIndex"]);
    return l != null && m(t, ["lastConsumedClientMessageIndex"], l),
    t
}
function EN(r, e) {
    const t = {};
    p(e, ["setupComplete"]) != null && m(t, ["setupComplete"], tN());
    const o = p(e, ["serverContent"]);
    o != null && m(t, ["serverContent"], aN(r, o));
    const l = p(e, ["toolCall"]);
    l != null && m(t, ["toolCall"], fN(r, l));
    const f = p(e, ["toolCallCancellation"]);
    f != null && m(t, ["toolCallCancellation"], dN(r, f));
    const d = p(e, ["usageMetadata"]);
    d != null && m(t, ["usageMetadata"], mN(r, d));
    const v = p(e, ["goAway"]);
    v != null && m(t, ["goAway"], yN(r, v));
    const y = p(e, ["sessionResumptionUpdate"]);
    return y != null && m(t, ["sessionResumptionUpdate"], _N(r, y)),
    t
}
function SN(r, e) {
    const t = {};
    p(e, ["setupComplete"]) != null && m(t, ["setupComplete"], nN());
    const o = p(e, ["serverContent"]);
    o != null && m(t, ["serverContent"], lN(r, o));
    const l = p(e, ["toolCall"]);
    l != null && m(t, ["toolCall"], hN(r, l));
    const f = p(e, ["toolCallCancellation"]);
    f != null && m(t, ["toolCallCancellation"], pN(r, f));
    const d = p(e, ["usageMetadata"]);
    d != null && m(t, ["usageMetadata"], gN(r, d));
    const v = p(e, ["goAway"]);
    v != null && m(t, ["goAway"], vN(r, v));
    const y = p(e, ["sessionResumptionUpdate"]);
    return y != null && m(t, ["sessionResumptionUpdate"], TN(r, y)),
    t
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function AN(r, e) {
    const t = {};
    if (p(e, ["videoMetadata"]) !== void 0)
        throw new Error("videoMetadata parameter is not supported in Gemini API.");
    const s = p(e, ["thought"]);
    s != null && m(t, ["thought"], s);
    const o = p(e, ["codeExecutionResult"]);
    o != null && m(t, ["codeExecutionResult"], o);
    const l = p(e, ["executableCode"]);
    l != null && m(t, ["executableCode"], l);
    const f = p(e, ["fileData"]);
    f != null && m(t, ["fileData"], f);
    const d = p(e, ["functionCall"]);
    d != null && m(t, ["functionCall"], d);
    const v = p(e, ["functionResponse"]);
    v != null && m(t, ["functionResponse"], v);
    const y = p(e, ["inlineData"]);
    y != null && m(t, ["inlineData"], y);
    const T = p(e, ["text"]);
    return T != null && m(t, ["text"], T),
    t
}
function lf(r, e) {
    const t = {}
      , s = p(e, ["parts"]);
    if (s != null) {
        let l = s;
        Array.isArray(l) && (l = l.map(f => AN(r, f))),
        m(t, ["parts"], l)
    }
    const o = p(e, ["role"]);
    return o != null && m(t, ["role"], o),
    t
}
function CN(r, e) {
    const t = {};
    if (p(e, ["method"]) !== void 0)
        throw new Error("method parameter is not supported in Gemini API.");
    const s = p(e, ["category"]);
    s != null && m(t, ["category"], s);
    const o = p(e, ["threshold"]);
    return o != null && m(t, ["threshold"], o),
    t
}
function RN() {
    return {}
}
function IN(r, e) {
    const t = {}
      , s = p(e, ["mode"]);
    s != null && m(t, ["mode"], s);
    const o = p(e, ["dynamicThreshold"]);
    return o != null && m(t, ["dynamicThreshold"], o),
    t
}
function wN(r, e) {
    const t = {}
      , s = p(e, ["dynamicRetrievalConfig"]);
    return s != null && m(t, ["dynamicRetrievalConfig"], IN(r, s)),
    t
}
function bN(r, e) {
    const t = {};
    if (p(e, ["retrieval"]) !== void 0)
        throw new Error("retrieval parameter is not supported in Gemini API.");
    p(e, ["googleSearch"]) != null && m(t, ["googleSearch"], RN());
    const o = p(e, ["googleSearchRetrieval"]);
    o != null && m(t, ["googleSearchRetrieval"], wN(r, o));
    const l = p(e, ["codeExecution"]);
    l != null && m(t, ["codeExecution"], l);
    const f = p(e, ["functionDeclarations"]);
    return f != null && m(t, ["functionDeclarations"], f),
    t
}
function DN(r, e) {
    const t = {}
      , s = p(e, ["mode"]);
    s != null && m(t, ["mode"], s);
    const o = p(e, ["allowedFunctionNames"]);
    return o != null && m(t, ["allowedFunctionNames"], o),
    t
}
function MN(r, e) {
    const t = {}
      , s = p(e, ["functionCallingConfig"]);
    return s != null && m(t, ["functionCallingConfig"], DN(r, s)),
    t
}
function NN(r, e) {
    const t = {}
      , s = p(e, ["voiceName"]);
    return s != null && m(t, ["voiceName"], s),
    t
}
function xN(r, e) {
    const t = {}
      , s = p(e, ["prebuiltVoiceConfig"]);
    return s != null && m(t, ["prebuiltVoiceConfig"], NN(r, s)),
    t
}
function PN(r, e) {
    const t = {}
      , s = p(e, ["voiceConfig"]);
    s != null && m(t, ["voiceConfig"], xN(r, s));
    const o = p(e, ["languageCode"]);
    return o != null && m(t, ["languageCode"], o),
    t
}
function ON(r, e) {
    const t = {}
      , s = p(e, ["includeThoughts"]);
    s != null && m(t, ["includeThoughts"], s);
    const o = p(e, ["thinkingBudget"]);
    return o != null && m(t, ["thinkingBudget"], o),
    t
}
function VN(r, e, t) {
    const s = {}
      , o = p(e, ["systemInstruction"]);
    t !== void 0 && o != null && m(t, ["systemInstruction"], lf(r, on(r, o)));
    const l = p(e, ["temperature"]);
    l != null && m(s, ["temperature"], l);
    const f = p(e, ["topP"]);
    f != null && m(s, ["topP"], f);
    const d = p(e, ["topK"]);
    d != null && m(s, ["topK"], d);
    const v = p(e, ["candidateCount"]);
    v != null && m(s, ["candidateCount"], v);
    const y = p(e, ["maxOutputTokens"]);
    y != null && m(s, ["maxOutputTokens"], y);
    const T = p(e, ["stopSequences"]);
    T != null && m(s, ["stopSequences"], T);
    const A = p(e, ["responseLogprobs"]);
    A != null && m(s, ["responseLogprobs"], A);
    const I = p(e, ["logprobs"]);
    I != null && m(s, ["logprobs"], I);
    const V = p(e, ["presencePenalty"]);
    V != null && m(s, ["presencePenalty"], V);
    const q = p(e, ["frequencyPenalty"]);
    q != null && m(s, ["frequencyPenalty"], q);
    const G = p(e, ["seed"]);
    G != null && m(s, ["seed"], G);
    const J = p(e, ["responseMimeType"]);
    J != null && m(s, ["responseMimeType"], J);
    const ne = p(e, ["responseSchema"]);
    if (ne != null && m(s, ["responseSchema"], D0(r, ne)),
    p(e, ["routingConfig"]) !== void 0)
        throw new Error("routingConfig parameter is not supported in Gemini API.");
    if (p(e, ["modelSelectionConfig"]) !== void 0)
        throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
    const se = p(e, ["safetySettings"]);
    if (t !== void 0 && se != null) {
        let P = se;
        Array.isArray(P) && (P = P.map(k => CN(r, k))),
        m(t, ["safetySettings"], P)
    }
    const le = p(e, ["tools"]);
    if (t !== void 0 && le != null) {
        let P = af(r, le);
        Array.isArray(P) && (P = P.map(k => bN(r, of(r, k)))),
        m(t, ["tools"], P)
    }
    const ue = p(e, ["toolConfig"]);
    if (t !== void 0 && ue != null && m(t, ["toolConfig"], MN(r, ue)),
    p(e, ["labels"]) !== void 0)
        throw new Error("labels parameter is not supported in Gemini API.");
    const fe = p(e, ["cachedContent"]);
    t !== void 0 && fe != null && m(t, ["cachedContent"], kr(r, fe));
    const Ie = p(e, ["responseModalities"]);
    Ie != null && m(s, ["responseModalities"], Ie);
    const U = p(e, ["mediaResolution"]);
    U != null && m(s, ["mediaResolution"], U);
    const w = p(e, ["speechConfig"]);
    if (w != null && m(s, ["speechConfig"], PN(r, M0(r, w))),
    p(e, ["audioTimestamp"]) !== void 0)
        throw new Error("audioTimestamp parameter is not supported in Gemini API.");
    const M = p(e, ["thinkingConfig"]);
    return M != null && m(s, ["thinkingConfig"], ON(r, M)),
    s
}
function gT(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "model"], ut(r, s));
    const o = p(e, ["contents"]);
    if (o != null) {
        let f = Ur(r, o);
        Array.isArray(f) && (f = f.map(d => lf(r, d))),
        m(t, ["contents"], f)
    }
    const l = p(e, ["config"]);
    return l != null && m(t, ["generationConfig"], VN(r, l, t)),
    t
}
function UN(r, e, t) {
    const s = {}
      , o = p(e, ["taskType"]);
    t !== void 0 && o != null && m(t, ["requests[]", "taskType"], o);
    const l = p(e, ["title"]);
    t !== void 0 && l != null && m(t, ["requests[]", "title"], l);
    const f = p(e, ["outputDimensionality"]);
    if (t !== void 0 && f != null && m(t, ["requests[]", "outputDimensionality"], f),
    p(e, ["mimeType"]) !== void 0)
        throw new Error("mimeType parameter is not supported in Gemini API.");
    if (p(e, ["autoTruncate"]) !== void 0)
        throw new Error("autoTruncate parameter is not supported in Gemini API.");
    return s
}
function kN(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "model"], ut(r, s));
    const o = p(e, ["contents"]);
    o != null && m(t, ["requests[]", "content"], b0(r, o));
    const l = p(e, ["config"]);
    l != null && m(t, ["config"], UN(r, l, t));
    const f = p(e, ["model"]);
    return f !== void 0 && m(t, ["requests[]", "model"], ut(r, f)),
    t
}
function LN(r, e, t) {
    const s = {};
    if (p(e, ["outputGcsUri"]) !== void 0)
        throw new Error("outputGcsUri parameter is not supported in Gemini API.");
    if (p(e, ["negativePrompt"]) !== void 0)
        throw new Error("negativePrompt parameter is not supported in Gemini API.");
    const o = p(e, ["numberOfImages"]);
    t !== void 0 && o != null && m(t, ["parameters", "sampleCount"], o);
    const l = p(e, ["aspectRatio"]);
    t !== void 0 && l != null && m(t, ["parameters", "aspectRatio"], l);
    const f = p(e, ["guidanceScale"]);
    if (t !== void 0 && f != null && m(t, ["parameters", "guidanceScale"], f),
    p(e, ["seed"]) !== void 0)
        throw new Error("seed parameter is not supported in Gemini API.");
    const d = p(e, ["safetyFilterLevel"]);
    t !== void 0 && d != null && m(t, ["parameters", "safetySetting"], d);
    const v = p(e, ["personGeneration"]);
    t !== void 0 && v != null && m(t, ["parameters", "personGeneration"], v);
    const y = p(e, ["includeSafetyAttributes"]);
    t !== void 0 && y != null && m(t, ["parameters", "includeSafetyAttributes"], y);
    const T = p(e, ["includeRaiReason"]);
    t !== void 0 && T != null && m(t, ["parameters", "includeRaiReason"], T);
    const A = p(e, ["language"]);
    t !== void 0 && A != null && m(t, ["parameters", "language"], A);
    const I = p(e, ["outputMimeType"]);
    t !== void 0 && I != null && m(t, ["parameters", "outputOptions", "mimeType"], I);
    const V = p(e, ["outputCompressionQuality"]);
    if (t !== void 0 && V != null && m(t, ["parameters", "outputOptions", "compressionQuality"], V),
    p(e, ["addWatermark"]) !== void 0)
        throw new Error("addWatermark parameter is not supported in Gemini API.");
    if (p(e, ["enhancePrompt"]) !== void 0)
        throw new Error("enhancePrompt parameter is not supported in Gemini API.");
    return s
}
function BN(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "model"], ut(r, s));
    const o = p(e, ["prompt"]);
    o != null && m(t, ["instances[0]", "prompt"], o);
    const l = p(e, ["config"]);
    return l != null && m(t, ["config"], LN(r, l, t)),
    t
}
function qN(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "name"], ut(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], o),
    t
}
function zN(r, e, t) {
    const s = {}
      , o = p(e, ["displayName"]);
    t !== void 0 && o != null && m(t, ["displayName"], o);
    const l = p(e, ["description"]);
    return t !== void 0 && l != null && m(t, ["description"], l),
    s
}
function FN(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "name"], ut(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], zN(r, o, t)),
    t
}
function HN(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "name"], ut(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], o),
    t
}
function GN(r, e) {
    const t = {};
    if (p(e, ["systemInstruction"]) !== void 0)
        throw new Error("systemInstruction parameter is not supported in Gemini API.");
    if (p(e, ["tools"]) !== void 0)
        throw new Error("tools parameter is not supported in Gemini API.");
    if (p(e, ["generationConfig"]) !== void 0)
        throw new Error("generationConfig parameter is not supported in Gemini API.");
    return t
}
function YN(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "model"], ut(r, s));
    const o = p(e, ["contents"]);
    if (o != null) {
        let f = Ur(r, o);
        Array.isArray(f) && (f = f.map(d => lf(r, d))),
        m(t, ["contents"], f)
    }
    const l = p(e, ["config"]);
    return l != null && m(t, ["config"], GN(r, l)),
    t
}
function KN(r, e) {
    const t = {};
    if (p(e, ["gcsUri"]) !== void 0)
        throw new Error("gcsUri parameter is not supported in Gemini API.");
    const s = p(e, ["imageBytes"]);
    s != null && m(t, ["bytesBase64Encoded"], Lr(r, s));
    const o = p(e, ["mimeType"]);
    return o != null && m(t, ["mimeType"], o),
    t
}
function QN(r, e, t) {
    const s = {}
      , o = p(e, ["numberOfVideos"]);
    if (t !== void 0 && o != null && m(t, ["parameters", "sampleCount"], o),
    p(e, ["outputGcsUri"]) !== void 0)
        throw new Error("outputGcsUri parameter is not supported in Gemini API.");
    if (p(e, ["fps"]) !== void 0)
        throw new Error("fps parameter is not supported in Gemini API.");
    const l = p(e, ["durationSeconds"]);
    if (t !== void 0 && l != null && m(t, ["parameters", "durationSeconds"], l),
    p(e, ["seed"]) !== void 0)
        throw new Error("seed parameter is not supported in Gemini API.");
    const f = p(e, ["aspectRatio"]);
    if (t !== void 0 && f != null && m(t, ["parameters", "aspectRatio"], f),
    p(e, ["resolution"]) !== void 0)
        throw new Error("resolution parameter is not supported in Gemini API.");
    const d = p(e, ["personGeneration"]);
    if (t !== void 0 && d != null && m(t, ["parameters", "personGeneration"], d),
    p(e, ["pubsubTopic"]) !== void 0)
        throw new Error("pubsubTopic parameter is not supported in Gemini API.");
    const v = p(e, ["negativePrompt"]);
    if (t !== void 0 && v != null && m(t, ["parameters", "negativePrompt"], v),
    p(e, ["enhancePrompt"]) !== void 0)
        throw new Error("enhancePrompt parameter is not supported in Gemini API.");
    return s
}
function XN(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "model"], ut(r, s));
    const o = p(e, ["prompt"]);
    o != null && m(t, ["instances[0]", "prompt"], o);
    const l = p(e, ["image"]);
    l != null && m(t, ["instances[0]", "image"], KN(r, l));
    const f = p(e, ["config"]);
    return f != null && m(t, ["config"], QN(r, f, t)),
    t
}
function $N(r, e) {
    const t = {}
      , s = p(e, ["videoMetadata"]);
    s != null && m(t, ["videoMetadata"], s);
    const o = p(e, ["thought"]);
    o != null && m(t, ["thought"], o);
    const l = p(e, ["codeExecutionResult"]);
    l != null && m(t, ["codeExecutionResult"], l);
    const f = p(e, ["executableCode"]);
    f != null && m(t, ["executableCode"], f);
    const d = p(e, ["fileData"]);
    d != null && m(t, ["fileData"], d);
    const v = p(e, ["functionCall"]);
    v != null && m(t, ["functionCall"], v);
    const y = p(e, ["functionResponse"]);
    y != null && m(t, ["functionResponse"], y);
    const T = p(e, ["inlineData"]);
    T != null && m(t, ["inlineData"], T);
    const A = p(e, ["text"]);
    return A != null && m(t, ["text"], A),
    t
}
function Qo(r, e) {
    const t = {}
      , s = p(e, ["parts"]);
    if (s != null) {
        let l = s;
        Array.isArray(l) && (l = l.map(f => $N(r, f))),
        m(t, ["parts"], l)
    }
    const o = p(e, ["role"]);
    return o != null && m(t, ["role"], o),
    t
}
function JN(r, e) {
    const t = {}
      , s = p(e, ["featureSelectionPreference"]);
    return s != null && m(t, ["featureSelectionPreference"], s),
    t
}
function jN(r, e) {
    const t = {}
      , s = p(e, ["method"]);
    s != null && m(t, ["method"], s);
    const o = p(e, ["category"]);
    o != null && m(t, ["category"], o);
    const l = p(e, ["threshold"]);
    return l != null && m(t, ["threshold"], l),
    t
}
function WN() {
    return {}
}
function ZN(r, e) {
    const t = {}
      , s = p(e, ["mode"]);
    s != null && m(t, ["mode"], s);
    const o = p(e, ["dynamicThreshold"]);
    return o != null && m(t, ["dynamicThreshold"], o),
    t
}
function ex(r, e) {
    const t = {}
      , s = p(e, ["dynamicRetrievalConfig"]);
    return s != null && m(t, ["dynamicRetrievalConfig"], ZN(r, s)),
    t
}
function O0(r, e) {
    const t = {}
      , s = p(e, ["retrieval"]);
    s != null && m(t, ["retrieval"], s),
    p(e, ["googleSearch"]) != null && m(t, ["googleSearch"], WN());
    const l = p(e, ["googleSearchRetrieval"]);
    l != null && m(t, ["googleSearchRetrieval"], ex(r, l));
    const f = p(e, ["codeExecution"]);
    f != null && m(t, ["codeExecution"], f);
    const d = p(e, ["functionDeclarations"]);
    return d != null && m(t, ["functionDeclarations"], d),
    t
}
function tx(r, e) {
    const t = {}
      , s = p(e, ["mode"]);
    s != null && m(t, ["mode"], s);
    const o = p(e, ["allowedFunctionNames"]);
    return o != null && m(t, ["allowedFunctionNames"], o),
    t
}
function nx(r, e) {
    const t = {}
      , s = p(e, ["functionCallingConfig"]);
    return s != null && m(t, ["functionCallingConfig"], tx(r, s)),
    t
}
function ix(r, e) {
    const t = {}
      , s = p(e, ["voiceName"]);
    return s != null && m(t, ["voiceName"], s),
    t
}
function rx(r, e) {
    const t = {}
      , s = p(e, ["prebuiltVoiceConfig"]);
    return s != null && m(t, ["prebuiltVoiceConfig"], ix(r, s)),
    t
}
function sx(r, e) {
    const t = {}
      , s = p(e, ["voiceConfig"]);
    s != null && m(t, ["voiceConfig"], rx(r, s));
    const o = p(e, ["languageCode"]);
    return o != null && m(t, ["languageCode"], o),
    t
}
function ox(r, e) {
    const t = {}
      , s = p(e, ["includeThoughts"]);
    s != null && m(t, ["includeThoughts"], s);
    const o = p(e, ["thinkingBudget"]);
    return o != null && m(t, ["thinkingBudget"], o),
    t
}
function ax(r, e, t) {
    const s = {}
      , o = p(e, ["systemInstruction"]);
    t !== void 0 && o != null && m(t, ["systemInstruction"], Qo(r, on(r, o)));
    const l = p(e, ["temperature"]);
    l != null && m(s, ["temperature"], l);
    const f = p(e, ["topP"]);
    f != null && m(s, ["topP"], f);
    const d = p(e, ["topK"]);
    d != null && m(s, ["topK"], d);
    const v = p(e, ["candidateCount"]);
    v != null && m(s, ["candidateCount"], v);
    const y = p(e, ["maxOutputTokens"]);
    y != null && m(s, ["maxOutputTokens"], y);
    const T = p(e, ["stopSequences"]);
    T != null && m(s, ["stopSequences"], T);
    const A = p(e, ["responseLogprobs"]);
    A != null && m(s, ["responseLogprobs"], A);
    const I = p(e, ["logprobs"]);
    I != null && m(s, ["logprobs"], I);
    const V = p(e, ["presencePenalty"]);
    V != null && m(s, ["presencePenalty"], V);
    const q = p(e, ["frequencyPenalty"]);
    q != null && m(s, ["frequencyPenalty"], q);
    const G = p(e, ["seed"]);
    G != null && m(s, ["seed"], G);
    const J = p(e, ["responseMimeType"]);
    J != null && m(s, ["responseMimeType"], J);
    const ne = p(e, ["responseSchema"]);
    ne != null && m(s, ["responseSchema"], D0(r, ne));
    const se = p(e, ["routingConfig"]);
    se != null && m(s, ["routingConfig"], se);
    const le = p(e, ["modelSelectionConfig"]);
    le != null && m(s, ["modelConfig"], JN(r, le));
    const ue = p(e, ["safetySettings"]);
    if (t !== void 0 && ue != null) {
        let $e = ue;
        Array.isArray($e) && ($e = $e.map(je => jN(r, je))),
        m(t, ["safetySettings"], $e)
    }
    const fe = p(e, ["tools"]);
    if (t !== void 0 && fe != null) {
        let $e = af(r, fe);
        Array.isArray($e) && ($e = $e.map(je => O0(r, of(r, je)))),
        m(t, ["tools"], $e)
    }
    const Ie = p(e, ["toolConfig"]);
    t !== void 0 && Ie != null && m(t, ["toolConfig"], nx(r, Ie));
    const U = p(e, ["labels"]);
    t !== void 0 && U != null && m(t, ["labels"], U);
    const w = p(e, ["cachedContent"]);
    t !== void 0 && w != null && m(t, ["cachedContent"], kr(r, w));
    const M = p(e, ["responseModalities"]);
    M != null && m(s, ["responseModalities"], M);
    const P = p(e, ["mediaResolution"]);
    P != null && m(s, ["mediaResolution"], P);
    const k = p(e, ["speechConfig"]);
    k != null && m(s, ["speechConfig"], sx(r, M0(r, k)));
    const B = p(e, ["audioTimestamp"]);
    B != null && m(s, ["audioTimestamp"], B);
    const N = p(e, ["thinkingConfig"]);
    return N != null && m(s, ["thinkingConfig"], ox(r, N)),
    s
}
function yT(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "model"], ut(r, s));
    const o = p(e, ["contents"]);
    if (o != null) {
        let f = Ur(r, o);
        Array.isArray(f) && (f = f.map(d => Qo(r, d))),
        m(t, ["contents"], f)
    }
    const l = p(e, ["config"]);
    return l != null && m(t, ["generationConfig"], ax(r, l, t)),
    t
}
function lx(r, e, t) {
    const s = {}
      , o = p(e, ["taskType"]);
    t !== void 0 && o != null && m(t, ["instances[]", "task_type"], o);
    const l = p(e, ["title"]);
    t !== void 0 && l != null && m(t, ["instances[]", "title"], l);
    const f = p(e, ["outputDimensionality"]);
    t !== void 0 && f != null && m(t, ["parameters", "outputDimensionality"], f);
    const d = p(e, ["mimeType"]);
    t !== void 0 && d != null && m(t, ["instances[]", "mimeType"], d);
    const v = p(e, ["autoTruncate"]);
    return t !== void 0 && v != null && m(t, ["parameters", "autoTruncate"], v),
    s
}
function ux(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "model"], ut(r, s));
    const o = p(e, ["contents"]);
    o != null && m(t, ["instances[]", "content"], b0(r, o));
    const l = p(e, ["config"]);
    return l != null && m(t, ["config"], lx(r, l, t)),
    t
}
function cx(r, e, t) {
    const s = {}
      , o = p(e, ["outputGcsUri"]);
    t !== void 0 && o != null && m(t, ["parameters", "storageUri"], o);
    const l = p(e, ["negativePrompt"]);
    t !== void 0 && l != null && m(t, ["parameters", "negativePrompt"], l);
    const f = p(e, ["numberOfImages"]);
    t !== void 0 && f != null && m(t, ["parameters", "sampleCount"], f);
    const d = p(e, ["aspectRatio"]);
    t !== void 0 && d != null && m(t, ["parameters", "aspectRatio"], d);
    const v = p(e, ["guidanceScale"]);
    t !== void 0 && v != null && m(t, ["parameters", "guidanceScale"], v);
    const y = p(e, ["seed"]);
    t !== void 0 && y != null && m(t, ["parameters", "seed"], y);
    const T = p(e, ["safetyFilterLevel"]);
    t !== void 0 && T != null && m(t, ["parameters", "safetySetting"], T);
    const A = p(e, ["personGeneration"]);
    t !== void 0 && A != null && m(t, ["parameters", "personGeneration"], A);
    const I = p(e, ["includeSafetyAttributes"]);
    t !== void 0 && I != null && m(t, ["parameters", "includeSafetyAttributes"], I);
    const V = p(e, ["includeRaiReason"]);
    t !== void 0 && V != null && m(t, ["parameters", "includeRaiReason"], V);
    const q = p(e, ["language"]);
    t !== void 0 && q != null && m(t, ["parameters", "language"], q);
    const G = p(e, ["outputMimeType"]);
    t !== void 0 && G != null && m(t, ["parameters", "outputOptions", "mimeType"], G);
    const J = p(e, ["outputCompressionQuality"]);
    t !== void 0 && J != null && m(t, ["parameters", "outputOptions", "compressionQuality"], J);
    const ne = p(e, ["addWatermark"]);
    t !== void 0 && ne != null && m(t, ["parameters", "addWatermark"], ne);
    const se = p(e, ["enhancePrompt"]);
    return t !== void 0 && se != null && m(t, ["parameters", "enhancePrompt"], se),
    s
}
function fx(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "model"], ut(r, s));
    const o = p(e, ["prompt"]);
    o != null && m(t, ["instances[0]", "prompt"], o);
    const l = p(e, ["config"]);
    return l != null && m(t, ["config"], cx(r, l, t)),
    t
}
function hx(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "name"], ut(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], o),
    t
}
function dx(r, e, t) {
    const s = {}
      , o = p(e, ["displayName"]);
    t !== void 0 && o != null && m(t, ["displayName"], o);
    const l = p(e, ["description"]);
    return t !== void 0 && l != null && m(t, ["description"], l),
    s
}
function px(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "model"], ut(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], dx(r, o, t)),
    t
}
function mx(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "name"], ut(r, s));
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], o),
    t
}
function gx(r, e, t) {
    const s = {}
      , o = p(e, ["systemInstruction"]);
    t !== void 0 && o != null && m(t, ["systemInstruction"], Qo(r, on(r, o)));
    const l = p(e, ["tools"]);
    if (t !== void 0 && l != null) {
        let d = l;
        Array.isArray(d) && (d = d.map(v => O0(r, v))),
        m(t, ["tools"], d)
    }
    const f = p(e, ["generationConfig"]);
    return t !== void 0 && f != null && m(t, ["generationConfig"], f),
    s
}
function yx(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "model"], ut(r, s));
    const o = p(e, ["contents"]);
    if (o != null) {
        let f = Ur(r, o);
        Array.isArray(f) && (f = f.map(d => Qo(r, d))),
        m(t, ["contents"], f)
    }
    const l = p(e, ["config"]);
    return l != null && m(t, ["config"], gx(r, l, t)),
    t
}
function vx(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "model"], ut(r, s));
    const o = p(e, ["contents"]);
    if (o != null) {
        let f = Ur(r, o);
        Array.isArray(f) && (f = f.map(d => Qo(r, d))),
        m(t, ["contents"], f)
    }
    const l = p(e, ["config"]);
    return l != null && m(t, ["config"], l),
    t
}
function _x(r, e) {
    const t = {}
      , s = p(e, ["gcsUri"]);
    s != null && m(t, ["gcsUri"], s);
    const o = p(e, ["imageBytes"]);
    o != null && m(t, ["bytesBase64Encoded"], Lr(r, o));
    const l = p(e, ["mimeType"]);
    return l != null && m(t, ["mimeType"], l),
    t
}
function Tx(r, e, t) {
    const s = {}
      , o = p(e, ["numberOfVideos"]);
    t !== void 0 && o != null && m(t, ["parameters", "sampleCount"], o);
    const l = p(e, ["outputGcsUri"]);
    t !== void 0 && l != null && m(t, ["parameters", "storageUri"], l);
    const f = p(e, ["fps"]);
    t !== void 0 && f != null && m(t, ["parameters", "fps"], f);
    const d = p(e, ["durationSeconds"]);
    t !== void 0 && d != null && m(t, ["parameters", "durationSeconds"], d);
    const v = p(e, ["seed"]);
    t !== void 0 && v != null && m(t, ["parameters", "seed"], v);
    const y = p(e, ["aspectRatio"]);
    t !== void 0 && y != null && m(t, ["parameters", "aspectRatio"], y);
    const T = p(e, ["resolution"]);
    t !== void 0 && T != null && m(t, ["parameters", "resolution"], T);
    const A = p(e, ["personGeneration"]);
    t !== void 0 && A != null && m(t, ["parameters", "personGeneration"], A);
    const I = p(e, ["pubsubTopic"]);
    t !== void 0 && I != null && m(t, ["parameters", "pubsubTopic"], I);
    const V = p(e, ["negativePrompt"]);
    t !== void 0 && V != null && m(t, ["parameters", "negativePrompt"], V);
    const q = p(e, ["enhancePrompt"]);
    return t !== void 0 && q != null && m(t, ["parameters", "enhancePrompt"], q),
    s
}
function Ex(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["_url", "model"], ut(r, s));
    const o = p(e, ["prompt"]);
    o != null && m(t, ["instances[0]", "prompt"], o);
    const l = p(e, ["image"]);
    l != null && m(t, ["instances[0]", "image"], _x(r, l));
    const f = p(e, ["config"]);
    return f != null && m(t, ["config"], Tx(r, f, t)),
    t
}
function Sx(r, e) {
    const t = {}
      , s = p(e, ["thought"]);
    s != null && m(t, ["thought"], s);
    const o = p(e, ["codeExecutionResult"]);
    o != null && m(t, ["codeExecutionResult"], o);
    const l = p(e, ["executableCode"]);
    l != null && m(t, ["executableCode"], l);
    const f = p(e, ["fileData"]);
    f != null && m(t, ["fileData"], f);
    const d = p(e, ["functionCall"]);
    d != null && m(t, ["functionCall"], d);
    const v = p(e, ["functionResponse"]);
    v != null && m(t, ["functionResponse"], v);
    const y = p(e, ["inlineData"]);
    y != null && m(t, ["inlineData"], y);
    const T = p(e, ["text"]);
    return T != null && m(t, ["text"], T),
    t
}
function Ax(r, e) {
    const t = {}
      , s = p(e, ["parts"]);
    if (s != null) {
        let l = s;
        Array.isArray(l) && (l = l.map(f => Sx(r, f))),
        m(t, ["parts"], l)
    }
    const o = p(e, ["role"]);
    return o != null && m(t, ["role"], o),
    t
}
function Cx(r, e) {
    const t = {}
      , s = p(e, ["citationSources"]);
    return s != null && m(t, ["citations"], s),
    t
}
function Rx(r, e) {
    const t = {}
      , s = p(e, ["content"]);
    s != null && m(t, ["content"], Ax(r, s));
    const o = p(e, ["citationMetadata"]);
    o != null && m(t, ["citationMetadata"], Cx(r, o));
    const l = p(e, ["tokenCount"]);
    l != null && m(t, ["tokenCount"], l);
    const f = p(e, ["finishReason"]);
    f != null && m(t, ["finishReason"], f);
    const d = p(e, ["avgLogprobs"]);
    d != null && m(t, ["avgLogprobs"], d);
    const v = p(e, ["groundingMetadata"]);
    v != null && m(t, ["groundingMetadata"], v);
    const y = p(e, ["index"]);
    y != null && m(t, ["index"], y);
    const T = p(e, ["logprobsResult"]);
    T != null && m(t, ["logprobsResult"], T);
    const A = p(e, ["safetyRatings"]);
    return A != null && m(t, ["safetyRatings"], A),
    t
}
function vT(r, e) {
    const t = {}
      , s = p(e, ["candidates"]);
    if (s != null) {
        let d = s;
        Array.isArray(d) && (d = d.map(v => Rx(r, v))),
        m(t, ["candidates"], d)
    }
    const o = p(e, ["modelVersion"]);
    o != null && m(t, ["modelVersion"], o);
    const l = p(e, ["promptFeedback"]);
    l != null && m(t, ["promptFeedback"], l);
    const f = p(e, ["usageMetadata"]);
    return f != null && m(t, ["usageMetadata"], f),
    t
}
function Ix(r, e) {
    const t = {}
      , s = p(e, ["values"]);
    return s != null && m(t, ["values"], s),
    t
}
function wx() {
    return {}
}
function bx(r, e) {
    const t = {}
      , s = p(e, ["embeddings"]);
    if (s != null) {
        let l = s;
        Array.isArray(l) && (l = l.map(f => Ix(r, f))),
        m(t, ["embeddings"], l)
    }
    return p(e, ["metadata"]) != null && m(t, ["metadata"], wx()),
    t
}
function Dx(r, e) {
    const t = {}
      , s = p(e, ["bytesBase64Encoded"]);
    s != null && m(t, ["imageBytes"], Lr(r, s));
    const o = p(e, ["mimeType"]);
    return o != null && m(t, ["mimeType"], o),
    t
}
function V0(r, e) {
    const t = {}
      , s = p(e, ["safetyAttributes", "categories"]);
    s != null && m(t, ["categories"], s);
    const o = p(e, ["safetyAttributes", "scores"]);
    o != null && m(t, ["scores"], o);
    const l = p(e, ["contentType"]);
    return l != null && m(t, ["contentType"], l),
    t
}
function Mx(r, e) {
    const t = {}
      , s = p(e, ["_self"]);
    s != null && m(t, ["image"], Dx(r, s));
    const o = p(e, ["raiFilteredReason"]);
    o != null && m(t, ["raiFilteredReason"], o);
    const l = p(e, ["_self"]);
    return l != null && m(t, ["safetyAttributes"], V0(r, l)),
    t
}
function Nx(r, e) {
    const t = {}
      , s = p(e, ["predictions"]);
    if (s != null) {
        let l = s;
        Array.isArray(l) && (l = l.map(f => Mx(r, f))),
        m(t, ["generatedImages"], l)
    }
    const o = p(e, ["positivePromptSafetyAttributes"]);
    return o != null && m(t, ["positivePromptSafetyAttributes"], V0(r, o)),
    t
}
function xx(r, e) {
    const t = {}
      , s = p(e, ["baseModel"]);
    s != null && m(t, ["baseModel"], s);
    const o = p(e, ["createTime"]);
    o != null && m(t, ["createTime"], o);
    const l = p(e, ["updateTime"]);
    return l != null && m(t, ["updateTime"], l),
    t
}
function _T(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["name"], s);
    const o = p(e, ["displayName"]);
    o != null && m(t, ["displayName"], o);
    const l = p(e, ["description"]);
    l != null && m(t, ["description"], l);
    const f = p(e, ["version"]);
    f != null && m(t, ["version"], f);
    const d = p(e, ["_self"]);
    d != null && m(t, ["tunedModelInfo"], xx(r, d));
    const v = p(e, ["inputTokenLimit"]);
    v != null && m(t, ["inputTokenLimit"], v);
    const y = p(e, ["outputTokenLimit"]);
    y != null && m(t, ["outputTokenLimit"], y);
    const T = p(e, ["supportedGenerationMethods"]);
    return T != null && m(t, ["supportedActions"], T),
    t
}
function Px() {
    return {}
}
function Ox(r, e) {
    const t = {}
      , s = p(e, ["totalTokens"]);
    s != null && m(t, ["totalTokens"], s);
    const o = p(e, ["cachedContentTokenCount"]);
    return o != null && m(t, ["cachedContentTokenCount"], o),
    t
}
function Vx(r, e) {
    const t = {}
      , s = p(e, ["video", "uri"]);
    s != null && m(t, ["uri"], s);
    const o = p(e, ["video", "encodedVideo"]);
    o != null && m(t, ["videoBytes"], Lr(r, o));
    const l = p(e, ["encoding"]);
    return l != null && m(t, ["mimeType"], l),
    t
}
function Ux(r, e) {
    const t = {}
      , s = p(e, ["_self"]);
    return s != null && m(t, ["video"], Vx(r, s)),
    t
}
function kx(r, e) {
    const t = {}
      , s = p(e, ["generatedSamples"]);
    if (s != null) {
        let f = s;
        Array.isArray(f) && (f = f.map(d => Ux(r, d))),
        m(t, ["generatedVideos"], f)
    }
    const o = p(e, ["raiMediaFilteredCount"]);
    o != null && m(t, ["raiMediaFilteredCount"], o);
    const l = p(e, ["raiMediaFilteredReasons"]);
    return l != null && m(t, ["raiMediaFilteredReasons"], l),
    t
}
function Lx(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["name"], s);
    const o = p(e, ["metadata"]);
    o != null && m(t, ["metadata"], o);
    const l = p(e, ["done"]);
    l != null && m(t, ["done"], l);
    const f = p(e, ["error"]);
    f != null && m(t, ["error"], f);
    const d = p(e, ["response", "generateVideoResponse"]);
    return d != null && m(t, ["response"], kx(r, d)),
    t
}
function Bx(r, e) {
    const t = {}
      , s = p(e, ["videoMetadata"]);
    s != null && m(t, ["videoMetadata"], s);
    const o = p(e, ["thought"]);
    o != null && m(t, ["thought"], o);
    const l = p(e, ["codeExecutionResult"]);
    l != null && m(t, ["codeExecutionResult"], l);
    const f = p(e, ["executableCode"]);
    f != null && m(t, ["executableCode"], f);
    const d = p(e, ["fileData"]);
    d != null && m(t, ["fileData"], d);
    const v = p(e, ["functionCall"]);
    v != null && m(t, ["functionCall"], v);
    const y = p(e, ["functionResponse"]);
    y != null && m(t, ["functionResponse"], y);
    const T = p(e, ["inlineData"]);
    T != null && m(t, ["inlineData"], T);
    const A = p(e, ["text"]);
    return A != null && m(t, ["text"], A),
    t
}
function qx(r, e) {
    const t = {}
      , s = p(e, ["parts"]);
    if (s != null) {
        let l = s;
        Array.isArray(l) && (l = l.map(f => Bx(r, f))),
        m(t, ["parts"], l)
    }
    const o = p(e, ["role"]);
    return o != null && m(t, ["role"], o),
    t
}
function zx(r, e) {
    const t = {}
      , s = p(e, ["citations"]);
    return s != null && m(t, ["citations"], s),
    t
}
function Fx(r, e) {
    const t = {}
      , s = p(e, ["content"]);
    s != null && m(t, ["content"], qx(r, s));
    const o = p(e, ["citationMetadata"]);
    o != null && m(t, ["citationMetadata"], zx(r, o));
    const l = p(e, ["finishMessage"]);
    l != null && m(t, ["finishMessage"], l);
    const f = p(e, ["finishReason"]);
    f != null && m(t, ["finishReason"], f);
    const d = p(e, ["avgLogprobs"]);
    d != null && m(t, ["avgLogprobs"], d);
    const v = p(e, ["groundingMetadata"]);
    v != null && m(t, ["groundingMetadata"], v);
    const y = p(e, ["index"]);
    y != null && m(t, ["index"], y);
    const T = p(e, ["logprobsResult"]);
    T != null && m(t, ["logprobsResult"], T);
    const A = p(e, ["safetyRatings"]);
    return A != null && m(t, ["safetyRatings"], A),
    t
}
function TT(r, e) {
    const t = {}
      , s = p(e, ["candidates"]);
    if (s != null) {
        let y = s;
        Array.isArray(y) && (y = y.map(T => Fx(r, T))),
        m(t, ["candidates"], y)
    }
    const o = p(e, ["createTime"]);
    o != null && m(t, ["createTime"], o);
    const l = p(e, ["responseId"]);
    l != null && m(t, ["responseId"], l);
    const f = p(e, ["modelVersion"]);
    f != null && m(t, ["modelVersion"], f);
    const d = p(e, ["promptFeedback"]);
    d != null && m(t, ["promptFeedback"], d);
    const v = p(e, ["usageMetadata"]);
    return v != null && m(t, ["usageMetadata"], v),
    t
}
function Hx(r, e) {
    const t = {}
      , s = p(e, ["truncated"]);
    s != null && m(t, ["truncated"], s);
    const o = p(e, ["token_count"]);
    return o != null && m(t, ["tokenCount"], o),
    t
}
function Gx(r, e) {
    const t = {}
      , s = p(e, ["values"]);
    s != null && m(t, ["values"], s);
    const o = p(e, ["statistics"]);
    return o != null && m(t, ["statistics"], Hx(r, o)),
    t
}
function Yx(r, e) {
    const t = {}
      , s = p(e, ["billableCharacterCount"]);
    return s != null && m(t, ["billableCharacterCount"], s),
    t
}
function Kx(r, e) {
    const t = {}
      , s = p(e, ["predictions[]", "embeddings"]);
    if (s != null) {
        let l = s;
        Array.isArray(l) && (l = l.map(f => Gx(r, f))),
        m(t, ["embeddings"], l)
    }
    const o = p(e, ["metadata"]);
    return o != null && m(t, ["metadata"], Yx(r, o)),
    t
}
function Qx(r, e) {
    const t = {}
      , s = p(e, ["gcsUri"]);
    s != null && m(t, ["gcsUri"], s);
    const o = p(e, ["bytesBase64Encoded"]);
    o != null && m(t, ["imageBytes"], Lr(r, o));
    const l = p(e, ["mimeType"]);
    return l != null && m(t, ["mimeType"], l),
    t
}
function U0(r, e) {
    const t = {}
      , s = p(e, ["safetyAttributes", "categories"]);
    s != null && m(t, ["categories"], s);
    const o = p(e, ["safetyAttributes", "scores"]);
    o != null && m(t, ["scores"], o);
    const l = p(e, ["contentType"]);
    return l != null && m(t, ["contentType"], l),
    t
}
function Xx(r, e) {
    const t = {}
      , s = p(e, ["_self"]);
    s != null && m(t, ["image"], Qx(r, s));
    const o = p(e, ["raiFilteredReason"]);
    o != null && m(t, ["raiFilteredReason"], o);
    const l = p(e, ["_self"]);
    l != null && m(t, ["safetyAttributes"], U0(r, l));
    const f = p(e, ["prompt"]);
    return f != null && m(t, ["enhancedPrompt"], f),
    t
}
function $x(r, e) {
    const t = {}
      , s = p(e, ["predictions"]);
    if (s != null) {
        let l = s;
        Array.isArray(l) && (l = l.map(f => Xx(r, f))),
        m(t, ["generatedImages"], l)
    }
    const o = p(e, ["positivePromptSafetyAttributes"]);
    return o != null && m(t, ["positivePromptSafetyAttributes"], U0(r, o)),
    t
}
function Jx(r, e) {
    const t = {}
      , s = p(e, ["endpoint"]);
    s != null && m(t, ["name"], s);
    const o = p(e, ["deployedModelId"]);
    return o != null && m(t, ["deployedModelId"], o),
    t
}
function jx(r, e) {
    const t = {}
      , s = p(e, ["labels", "google-vertex-llm-tuning-base-model-id"]);
    s != null && m(t, ["baseModel"], s);
    const o = p(e, ["createTime"]);
    o != null && m(t, ["createTime"], o);
    const l = p(e, ["updateTime"]);
    return l != null && m(t, ["updateTime"], l),
    t
}
function ET(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["name"], s);
    const o = p(e, ["displayName"]);
    o != null && m(t, ["displayName"], o);
    const l = p(e, ["description"]);
    l != null && m(t, ["description"], l);
    const f = p(e, ["versionId"]);
    f != null && m(t, ["version"], f);
    const d = p(e, ["deployedModels"]);
    if (d != null) {
        let T = d;
        Array.isArray(T) && (T = T.map(A => Jx(r, A))),
        m(t, ["endpoints"], T)
    }
    const v = p(e, ["labels"]);
    v != null && m(t, ["labels"], v);
    const y = p(e, ["_self"]);
    return y != null && m(t, ["tunedModelInfo"], jx(r, y)),
    t
}
function Wx() {
    return {}
}
function Zx(r, e) {
    const t = {}
      , s = p(e, ["totalTokens"]);
    return s != null && m(t, ["totalTokens"], s),
    t
}
function eP(r, e) {
    const t = {}
      , s = p(e, ["tokensInfo"]);
    return s != null && m(t, ["tokensInfo"], s),
    t
}
function tP(r, e) {
    const t = {}
      , s = p(e, ["gcsUri"]);
    s != null && m(t, ["uri"], s);
    const o = p(e, ["bytesBase64Encoded"]);
    o != null && m(t, ["videoBytes"], Lr(r, o));
    const l = p(e, ["mimeType"]);
    return l != null && m(t, ["mimeType"], l),
    t
}
function nP(r, e) {
    const t = {}
      , s = p(e, ["_self"]);
    return s != null && m(t, ["video"], tP(r, s)),
    t
}
function iP(r, e) {
    const t = {}
      , s = p(e, ["videos"]);
    if (s != null) {
        let f = s;
        Array.isArray(f) && (f = f.map(d => nP(r, d))),
        m(t, ["generatedVideos"], f)
    }
    const o = p(e, ["raiMediaFilteredCount"]);
    o != null && m(t, ["raiMediaFilteredCount"], o);
    const l = p(e, ["raiMediaFilteredReasons"]);
    return l != null && m(t, ["raiMediaFilteredReasons"], l),
    t
}
function rP(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["name"], s);
    const o = p(e, ["metadata"]);
    o != null && m(t, ["metadata"], o);
    const l = p(e, ["done"]);
    l != null && m(t, ["done"], l);
    const f = p(e, ["error"]);
    f != null && m(t, ["error"], f);
    const d = p(e, ["response"]);
    return d != null && m(t, ["response"], iP(r, d)),
    t
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const sP = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";
async function oP(r, e, t) {
    let s, o;
    t.data instanceof Blob ? o = JSON.parse(await t.data.text()) : o = JSON.parse(t.data),
    r.isVertexAI() ? s = SN(r, o) : s = EN(r, o),
    e(s)
}
class aP {
    constructor(e, t, s) {
        this.apiClient = e,
        this.auth = t,
        this.webSocketFactory = s
    }
    async connect(e) {
        var t, s, o, l;
        const f = this.apiClient.getWebsocketBaseUrl()
          , d = this.apiClient.getApiVersion();
        let v;
        const y = fP(this.apiClient.getDefaultHeaders());
        if (this.apiClient.isVertexAI())
            v = `${f}/ws/google.cloud.aiplatform.${d}.LlmBidiService/BidiGenerateContent`,
            await this.auth.addAuthHeaders(y);
        else {
            const ue = this.apiClient.getApiKey();
            v = `${f}/ws/google.ai.generativelanguage.${d}.GenerativeService.BidiGenerateContent?key=${ue}`
        }
        let T = () => {}
        ;
        const A = new Promise(ue => {
            T = ue
        }
        )
          , I = e.callbacks
          , V = function() {
            var ue;
            (ue = I == null ? void 0 : I.onopen) === null || ue === void 0 || ue.call(I),
            T({})
        }
          , q = this.apiClient
          , G = {
            onopen: V,
            onmessage: ue => {
                oP(q, I.onmessage, ue)
            }
            ,
            onerror: (t = I == null ? void 0 : I.onerror) !== null && t !== void 0 ? t : function(ue) {}
            ,
            onclose: (s = I == null ? void 0 : I.onclose) !== null && s !== void 0 ? s : function(ue) {}
        }
          , J = this.webSocketFactory.create(v, cP(y), G);
        J.connect(),
        await A;
        let ne = ut(this.apiClient, e.model);
        if (this.apiClient.isVertexAI() && ne.startsWith("publishers/")) {
            const ue = this.apiClient.getProject()
              , fe = this.apiClient.getLocation();
            ne = `projects/${ue}/locations/${fe}/` + ne
        }
        let se = {};
        this.apiClient.isVertexAI() && ((o = e.config) === null || o === void 0 ? void 0 : o.responseModalities) === void 0 && (e.config === void 0 ? e.config = {
            responseModalities: [Yc.AUDIO]
        } : e.config.responseModalities = [Yc.AUDIO]),
        !((l = e.config) === null || l === void 0) && l.generationConfig && console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");
        const le = {
            model: ne,
            config: e.config,
            callbacks: e.callbacks
        };
        return this.apiClient.isVertexAI() ? se = X1(this.apiClient, le) : se = Q1(this.apiClient, le),
        delete se.config,
        J.send(JSON.stringify(se)),
        new uP(J,this.apiClient)
    }
}
const lP = {
    turnComplete: !0
};
class uP {
    constructor(e, t) {
        this.conn = e,
        this.apiClient = t
    }
    tLiveClientContent(e, t) {
        if (t.turns !== null && t.turns !== void 0) {
            let s = [];
            try {
                s = Ur(e, t.turns),
                e.isVertexAI() ? s = s.map(o => Qo(e, o)) : s = s.map(o => lf(e, o))
            } catch {
                throw new Error(`Failed to parse client content "turns", type: '${typeof t.turns}'`)
            }
            return {
                clientContent: {
                    turns: s,
                    turnComplete: t.turnComplete
                }
            }
        }
        return {
            clientContent: {
                turnComplete: t.turnComplete
            }
        }
    }
    tLiveClienttToolResponse(e, t) {
        let s = [];
        if (t.functionResponses == null)
            throw new Error("functionResponses is required.");
        if (Array.isArray(t.functionResponses) ? s = t.functionResponses : s = [t.functionResponses],
        s.length === 0)
            throw new Error("functionResponses is required.");
        for (const l of s) {
            if (typeof l != "object" || l === null || !("name"in l) || !("response"in l))
                throw new Error(`Could not parse function response, type '${typeof l}'.`);
            if (!e.isVertexAI() && !("id"in l))
                throw new Error(sP)
        }
        return {
            toolResponse: {
                functionResponses: s
            }
        }
    }
    sendClientContent(e) {
        e = Object.assign(Object.assign({}, lP), e);
        const t = this.tLiveClientContent(this.apiClient, e);
        this.conn.send(JSON.stringify(t))
    }
    sendRealtimeInput(e) {
        let t = {};
        this.apiClient.isVertexAI() ? t = {
            realtimeInput: eN(this.apiClient, e)
        } : t = {
            realtimeInput: Z1(this.apiClient, e)
        },
        this.conn.send(JSON.stringify(t))
    }
    sendToolResponse(e) {
        if (e.functionResponses == null)
            throw new Error("Tool response parameters are required.");
        const t = this.tLiveClienttToolResponse(this.apiClient, e);
        this.conn.send(JSON.stringify(t))
    }
    close() {
        this.conn.close()
    }
}
function cP(r) {
    const e = {};
    return r.forEach( (t, s) => {
        e[s] = t
    }
    ),
    e
}
function fP(r) {
    const e = new Headers;
    for (const [t,s] of Object.entries(r))
        e.append(t, s);
    return e
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class hP extends Ol {
    constructor(e) {
        super(),
        this.apiClient = e,
        this.generateContent = async t => await this.generateContentInternal(t),
        this.generateContentStream = async t => await this.generateContentStreamInternal(t),
        this.generateImages = async t => await this.generateImagesInternal(t).then(s => {
            var o;
            let l;
            const f = [];
            if (s != null && s.generatedImages)
                for (const v of s.generatedImages)
                    v && (v != null && v.safetyAttributes) && ((o = v == null ? void 0 : v.safetyAttributes) === null || o === void 0 ? void 0 : o.contentType) === "Positive Prompt" ? l = v == null ? void 0 : v.safetyAttributes : f.push(v);
            let d;
            return l ? d = {
                generatedImages: f,
                positivePromptSafetyAttributes: l
            } : d = {
                generatedImages: f
            },
            d
        }
        )
    }
    async generateContentInternal(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = yT(this.apiClient, e);
            return d = Se("{model}:generateContent", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "POST",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(T => T.json()),
            f.then(T => {
                const A = TT(this.apiClient, T)
                  , I = new fc;
                return Object.assign(I, A),
                I
            }
            )
        } else {
            const y = gT(this.apiClient, e);
            return d = Se("{model}:generateContent", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "POST",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }).then(T => T.json()),
            f.then(T => {
                const A = vT(this.apiClient, T)
                  , I = new fc;
                return Object.assign(I, A),
                I
            }
            )
        }
    }
    async generateContentStreamInternal(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = yT(this.apiClient, e);
            d = Se("{model}:streamGenerateContent?alt=sse", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query;
            const T = this.apiClient;
            return f = T.requestStream({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "POST",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }),
            f.then(function(A) {
                return Kc(this, arguments, function*() {
                    var I, V, q, G;
                    try {
                        for (var J = !0, ne = Jd(A), se; se = yield Xt(ne.next()),
                        I = se.done,
                        !I; J = !0) {
                            G = se.value,
                            J = !1;
                            const ue = TT(T, yield Xt(G.json()))
                              , fe = new fc;
                            Object.assign(fe, ue),
                            yield yield Xt(fe)
                        }
                    } catch (le) {
                        V = {
                            error: le
                        }
                    } finally {
                        try {
                            !J && !I && (q = ne.return) && (yield Xt(q.call(ne)))
                        } finally {
                            if (V)
                                throw V.error
                        }
                    }
                })
            })
        } else {
            const y = gT(this.apiClient, e);
            d = Se("{model}:streamGenerateContent?alt=sse", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query;
            const T = this.apiClient;
            return f = T.requestStream({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "POST",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }),
            f.then(function(A) {
                return Kc(this, arguments, function*() {
                    var I, V, q, G;
                    try {
                        for (var J = !0, ne = Jd(A), se; se = yield Xt(ne.next()),
                        I = se.done,
                        !I; J = !0) {
                            G = se.value,
                            J = !1;
                            const ue = vT(T, yield Xt(G.json()))
                              , fe = new fc;
                            Object.assign(fe, ue),
                            yield yield Xt(fe)
                        }
                    } catch (le) {
                        V = {
                            error: le
                        }
                    } finally {
                        try {
                            !J && !I && (q = ne.return) && (yield Xt(q.call(ne)))
                        } finally {
                            if (V)
                                throw V.error
                        }
                    }
                })
            })
        }
    }
    async embedContent(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = ux(this.apiClient, e);
            return d = Se("{model}:predict", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "POST",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(T => T.json()),
            f.then(T => {
                const A = Kx(this.apiClient, T)
                  , I = new sT;
                return Object.assign(I, A),
                I
            }
            )
        } else {
            const y = kN(this.apiClient, e);
            return d = Se("{model}:batchEmbedContents", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "POST",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }).then(T => T.json()),
            f.then(T => {
                const A = bx(this.apiClient, T)
                  , I = new sT;
                return Object.assign(I, A),
                I
            }
            )
        }
    }
    async generateImagesInternal(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = fx(this.apiClient, e);
            return d = Se("{model}:predict", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "POST",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(T => T.json()),
            f.then(T => {
                const A = $x(this.apiClient, T)
                  , I = new oT;
                return Object.assign(I, A),
                I
            }
            )
        } else {
            const y = BN(this.apiClient, e);
            return d = Se("{model}:predict", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "POST",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }).then(T => T.json()),
            f.then(T => {
                const A = Nx(this.apiClient, T)
                  , I = new oT;
                return Object.assign(I, A),
                I
            }
            )
        }
    }
    async get(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = hx(this.apiClient, e);
            return d = Se("{name}", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "GET",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(T => T.json()),
            f.then(T => ET(this.apiClient, T))
        } else {
            const y = qN(this.apiClient, e);
            return d = Se("{name}", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "GET",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }).then(T => T.json()),
            f.then(T => _T(this.apiClient, T))
        }
    }
    async update(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = px(this.apiClient, e);
            return d = Se("{model}", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "PATCH",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(T => T.json()),
            f.then(T => ET(this.apiClient, T))
        } else {
            const y = FN(this.apiClient, e);
            return d = Se("{name}", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "PATCH",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }).then(T => T.json()),
            f.then(T => _T(this.apiClient, T))
        }
    }
    async delete(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = mx(this.apiClient, e);
            return d = Se("{name}", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "DELETE",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(T => T.json()),
            f.then( () => {
                const T = Wx()
                  , A = new aT;
                return Object.assign(A, T),
                A
            }
            )
        } else {
            const y = HN(this.apiClient, e);
            return d = Se("{name}", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "DELETE",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }).then(T => T.json()),
            f.then( () => {
                const T = Px()
                  , A = new aT;
                return Object.assign(A, T),
                A
            }
            )
        }
    }
    async countTokens(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = yx(this.apiClient, e);
            return d = Se("{model}:countTokens", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "POST",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(T => T.json()),
            f.then(T => {
                const A = Zx(this.apiClient, T)
                  , I = new lT;
                return Object.assign(I, A),
                I
            }
            )
        } else {
            const y = YN(this.apiClient, e);
            return d = Se("{model}:countTokens", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "POST",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }).then(T => T.json()),
            f.then(T => {
                const A = Ox(this.apiClient, T)
                  , I = new lT;
                return Object.assign(I, A),
                I
            }
            )
        }
    }
    async computeTokens(e) {
        var t, s;
        let o, l = "", f = {};
        if (this.apiClient.isVertexAI()) {
            const d = vx(this.apiClient, e);
            return l = Se("{model}:computeTokens", d._url),
            f = d._query,
            delete d.config,
            delete d._url,
            delete d._query,
            o = this.apiClient.request({
                path: l,
                queryParams: f,
                body: JSON.stringify(d),
                httpMethod: "POST",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(v => v.json()),
            o.then(v => {
                const y = eP(this.apiClient, v)
                  , T = new e1;
                return Object.assign(T, y),
                T
            }
            )
        } else
            throw new Error("This method is only supported by the Vertex AI.")
    }
    async generateVideos(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = Ex(this.apiClient, e);
            return d = Se("{model}:predictLongRunning", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "POST",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(T => T.json()),
            f.then(T => rP(this.apiClient, T))
        } else {
            const y = XN(this.apiClient, e);
            return d = Se("{model}:predictLongRunning", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "POST",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }).then(T => T.json()),
            f.then(T => Lx(this.apiClient, T))
        }
    }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function dP(r, e) {
    const t = {}
      , s = p(e, ["operationName"]);
    s != null && m(t, ["_url", "operationName"], s);
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], o),
    t
}
function pP(r, e) {
    const t = {}
      , s = p(e, ["operationName"]);
    s != null && m(t, ["_url", "operationName"], s);
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], o),
    t
}
function mP(r, e) {
    const t = {}
      , s = p(e, ["operationName"]);
    s != null && m(t, ["operationName"], s);
    const o = p(e, ["resourceName"]);
    o != null && m(t, ["_url", "resourceName"], o);
    const l = p(e, ["config"]);
    return l != null && m(t, ["config"], l),
    t
}
function gP(r, e) {
    const t = {}
      , s = p(e, ["video", "uri"]);
    s != null && m(t, ["uri"], s);
    const o = p(e, ["video", "encodedVideo"]);
    o != null && m(t, ["videoBytes"], Lr(r, o));
    const l = p(e, ["encoding"]);
    return l != null && m(t, ["mimeType"], l),
    t
}
function yP(r, e) {
    const t = {}
      , s = p(e, ["_self"]);
    return s != null && m(t, ["video"], gP(r, s)),
    t
}
function vP(r, e) {
    const t = {}
      , s = p(e, ["generatedSamples"]);
    if (s != null) {
        let f = s;
        Array.isArray(f) && (f = f.map(d => yP(r, d))),
        m(t, ["generatedVideos"], f)
    }
    const o = p(e, ["raiMediaFilteredCount"]);
    o != null && m(t, ["raiMediaFilteredCount"], o);
    const l = p(e, ["raiMediaFilteredReasons"]);
    return l != null && m(t, ["raiMediaFilteredReasons"], l),
    t
}
function _P(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["name"], s);
    const o = p(e, ["metadata"]);
    o != null && m(t, ["metadata"], o);
    const l = p(e, ["done"]);
    l != null && m(t, ["done"], l);
    const f = p(e, ["error"]);
    f != null && m(t, ["error"], f);
    const d = p(e, ["response", "generateVideoResponse"]);
    return d != null && m(t, ["response"], vP(r, d)),
    t
}
function TP(r, e) {
    const t = {}
      , s = p(e, ["gcsUri"]);
    s != null && m(t, ["uri"], s);
    const o = p(e, ["bytesBase64Encoded"]);
    o != null && m(t, ["videoBytes"], Lr(r, o));
    const l = p(e, ["mimeType"]);
    return l != null && m(t, ["mimeType"], l),
    t
}
function EP(r, e) {
    const t = {}
      , s = p(e, ["_self"]);
    return s != null && m(t, ["video"], TP(r, s)),
    t
}
function SP(r, e) {
    const t = {}
      , s = p(e, ["videos"]);
    if (s != null) {
        let f = s;
        Array.isArray(f) && (f = f.map(d => EP(r, d))),
        m(t, ["generatedVideos"], f)
    }
    const o = p(e, ["raiMediaFilteredCount"]);
    o != null && m(t, ["raiMediaFilteredCount"], o);
    const l = p(e, ["raiMediaFilteredReasons"]);
    return l != null && m(t, ["raiMediaFilteredReasons"], l),
    t
}
function ST(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["name"], s);
    const o = p(e, ["metadata"]);
    o != null && m(t, ["metadata"], o);
    const l = p(e, ["done"]);
    l != null && m(t, ["done"], l);
    const f = p(e, ["error"]);
    f != null && m(t, ["error"], f);
    const d = p(e, ["response"]);
    return d != null && m(t, ["response"], SP(r, d)),
    t
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class AP extends Ol {
    constructor(e) {
        super(),
        this.apiClient = e
    }
    async getVideosOperation(e) {
        const t = e.operation
          , s = e.config;
        if (t.name === void 0 || t.name === "")
            throw new Error("Operation name is required.");
        if (this.apiClient.isVertexAI()) {
            const o = t.name.split("/operations/")[0];
            let l;
            return s && "httpOptions"in s && (l = s.httpOptions),
            this.fetchPredictVideosOperationInternal({
                operationName: t.name,
                resourceName: o,
                config: {
                    httpOptions: l
                }
            })
        } else
            return this.getVideosOperationInternal({
                operationName: t.name,
                config: s
            })
    }
    async getVideosOperationInternal(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = pP(this.apiClient, e);
            return d = Se("{operationName}", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "GET",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(T => T.json()),
            f.then(T => ST(this.apiClient, T))
        } else {
            const y = dP(this.apiClient, e);
            return d = Se("{operationName}", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "GET",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }).then(T => T.json()),
            f.then(T => _P(this.apiClient, T))
        }
    }
    async fetchPredictVideosOperationInternal(e) {
        var t, s;
        let o, l = "", f = {};
        if (this.apiClient.isVertexAI()) {
            const d = mP(this.apiClient, e);
            return l = Se("{resourceName}:fetchPredictOperation", d._url),
            f = d._query,
            delete d.config,
            delete d._url,
            delete d._query,
            o = this.apiClient.request({
                path: l,
                queryParams: f,
                body: JSON.stringify(d),
                httpMethod: "POST",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(v => v.json()),
            o.then(v => ST(this.apiClient, v))
        } else
            throw new Error("This method is only supported by the Vertex AI.")
    }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const CP = "Content-Type"
  , RP = "X-Server-Timeout"
  , IP = "User-Agent"
  , wP = "x-goog-api-client"
  , bP = "0.12.0"
  , DP = `google-genai-sdk/${bP}`
  , MP = "v1beta1"
  , NP = "v1beta"
  , AT = /^data: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
class k0 extends Error {
    constructor(e, t) {
        t ? super(e, {
            cause: t
        }) : super(e, {
            cause: new Error().stack
        }),
        this.message = e,
        this.name = "ClientError"
    }
}
class Wd extends Error {
    constructor(e, t) {
        t ? super(e, {
            cause: t
        }) : super(e, {
            cause: new Error().stack
        }),
        this.message = e,
        this.name = "ServerError"
    }
}
class xP {
    constructor(e) {
        var t, s;
        this.clientOptions = Object.assign(Object.assign({}, e), {
            project: e.project,
            location: e.location,
            apiKey: e.apiKey,
            vertexai: e.vertexai
        });
        const o = {};
        this.clientOptions.vertexai ? (o.apiVersion = (t = this.clientOptions.apiVersion) !== null && t !== void 0 ? t : MP,
        this.getProject() || this.getLocation() ? (o.baseUrl = `https://${this.clientOptions.location}-aiplatform.googleapis.com/`,
        this.clientOptions.apiKey = void 0) : (o.baseUrl = "https://aiplatform.googleapis.com/",
        this.clientOptions.project = void 0,
        this.clientOptions.location = void 0)) : (o.apiVersion = (s = this.clientOptions.apiVersion) !== null && s !== void 0 ? s : NP,
        o.baseUrl = "https://generativelanguage.googleapis.com/"),
        o.headers = this.getDefaultHeaders(),
        this.clientOptions.httpOptions = o,
        e.httpOptions && (this.clientOptions.httpOptions = this.patchHttpOptions(o, e.httpOptions))
    }
    isVertexAI() {
        var e;
        return (e = this.clientOptions.vertexai) !== null && e !== void 0 ? e : !1
    }
    getProject() {
        return this.clientOptions.project
    }
    getLocation() {
        return this.clientOptions.location
    }
    getApiVersion() {
        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0)
            return this.clientOptions.httpOptions.apiVersion;
        throw new Error("API version is not set.")
    }
    getBaseUrl() {
        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0)
            return this.clientOptions.httpOptions.baseUrl;
        throw new Error("Base URL is not set.")
    }
    getRequestUrl() {
        return this.getRequestUrlInternal(this.clientOptions.httpOptions)
    }
    getHeaders() {
        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0)
            return this.clientOptions.httpOptions.headers;
        throw new Error("Headers are not set.")
    }
    getRequestUrlInternal(e) {
        if (!e || e.baseUrl === void 0 || e.apiVersion === void 0)
            throw new Error("HTTP options are not correctly set.");
        const s = [e.baseUrl.endsWith("/") ? e.baseUrl.slice(0, -1) : e.baseUrl];
        return e.apiVersion && e.apiVersion !== "" && s.push(e.apiVersion),
        s.join("/")
    }
    getBaseResourcePath() {
        return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`
    }
    getApiKey() {
        return this.clientOptions.apiKey
    }
    getWebsocketBaseUrl() {
        const e = this.getBaseUrl()
          , t = new URL(e);
        return t.protocol = t.protocol == "http:" ? "ws" : "wss",
        t.toString()
    }
    setBaseUrl(e) {
        if (this.clientOptions.httpOptions)
            this.clientOptions.httpOptions.baseUrl = e;
        else
            throw new Error("HTTP options are not correctly set.")
    }
    constructUrl(e, t, s) {
        const o = [this.getRequestUrlInternal(t)];
        return s && o.push(this.getBaseResourcePath()),
        e !== "" && o.push(e),
        new URL(`${o.join("/")}`)
    }
    shouldPrependVertexProjectPath(e) {
        return !(this.clientOptions.apiKey || !this.clientOptions.vertexai || e.path.startsWith("projects/") || e.httpMethod === "GET" && e.path.startsWith("publishers/google/models"))
    }
    async request(e) {
        let t = this.clientOptions.httpOptions;
        e.httpOptions && (t = this.patchHttpOptions(this.clientOptions.httpOptions, e.httpOptions));
        const s = this.shouldPrependVertexProjectPath(e)
          , o = this.constructUrl(e.path, t, s);
        if (e.queryParams)
            for (const [f,d] of Object.entries(e.queryParams))
                o.searchParams.append(f, String(d));
        let l = {};
        if (e.httpMethod === "GET") {
            if (e.body && e.body !== "{}")
                throw new Error("Request body should be empty for GET request, but got non empty request body")
        } else
            l.body = e.body;
        return l = await this.includeExtraHttpOptionsToRequestInit(l, t, e.abortSignal),
        this.unaryApiCall(o, l, e.httpMethod)
    }
    patchHttpOptions(e, t) {
        const s = JSON.parse(JSON.stringify(e));
        for (const [o,l] of Object.entries(t))
            typeof l == "object" ? s[o] = Object.assign(Object.assign({}, s[o]), l) : l !== void 0 && (s[o] = l);
        return s
    }
    async requestStream(e) {
        let t = this.clientOptions.httpOptions;
        e.httpOptions && (t = this.patchHttpOptions(this.clientOptions.httpOptions, e.httpOptions));
        const s = this.shouldPrependVertexProjectPath(e)
          , o = this.constructUrl(e.path, t, s);
        (!o.searchParams.has("alt") || o.searchParams.get("alt") !== "sse") && o.searchParams.set("alt", "sse");
        let l = {};
        return l.body = e.body,
        l = await this.includeExtraHttpOptionsToRequestInit(l, t, e.abortSignal),
        this.streamApiCall(o, l, e.httpMethod)
    }
    async includeExtraHttpOptionsToRequestInit(e, t, s) {
        if (t && t.timeout || s) {
            const o = new AbortController
              , l = o.signal;
            t.timeout && (t == null ? void 0 : t.timeout) > 0 && setTimeout( () => o.abort(), t.timeout),
            s && s.addEventListener("abort", () => {
                o.abort()
            }
            ),
            e.signal = l
        }
        return e.headers = await this.getHeadersInternal(t),
        e
    }
    async unaryApiCall(e, t, s) {
        return this.apiCall(e.toString(), Object.assign(Object.assign({}, t), {
            method: s
        })).then(async o => (await CT(o),
        new $d(o))).catch(o => {
            throw o instanceof Error ? o : new Error(JSON.stringify(o))
        }
        )
    }
    async streamApiCall(e, t, s) {
        return this.apiCall(e.toString(), Object.assign(Object.assign({}, t), {
            method: s
        })).then(async o => (await CT(o),
        this.processStreamResponse(o))).catch(o => {
            throw o instanceof Error ? o : new Error(JSON.stringify(o))
        }
        )
    }
    processStreamResponse(e) {
        var t;
        return Kc(this, arguments, function*() {
            const o = (t = e == null ? void 0 : e.body) === null || t === void 0 ? void 0 : t.getReader()
              , l = new TextDecoder("utf-8");
            if (!o)
                throw new Error("Response body is empty");
            try {
                let f = "";
                for (; ; ) {
                    const {done: d, value: v} = yield Xt(o.read());
                    if (d) {
                        if (f.trim().length > 0)
                            throw new Error("Incomplete JSON segment at the end");
                        break
                    }
                    const y = l.decode(v);
                    try {
                        const A = JSON.parse(y);
                        if ("error"in A) {
                            const I = JSON.parse(JSON.stringify(A.error))
                              , V = I.status
                              , q = I.code
                              , G = `got status: ${V}. ${JSON.stringify(A)}`;
                            if (q >= 400 && q < 500)
                                throw new k0(G);
                            if (q >= 500 && q < 600)
                                throw new Wd(G)
                        }
                    } catch (A) {
                        const I = A;
                        if (I.name === "ClientError" || I.name === "ServerError")
                            throw A
                    }
                    f += y;
                    let T = f.match(AT);
                    for (; T; ) {
                        const A = T[1];
                        try {
                            const I = new Response(A,{
                                headers: e == null ? void 0 : e.headers,
                                status: e == null ? void 0 : e.status,
                                statusText: e == null ? void 0 : e.statusText
                            });
                            yield yield Xt(new $d(I)),
                            f = f.slice(T[0].length),
                            T = f.match(AT)
                        } catch (I) {
                            throw new Error(`exception parsing stream chunk ${A}. ${I}`)
                        }
                    }
                }
            } finally {
                o.releaseLock()
            }
        })
    }
    async apiCall(e, t) {
        return fetch(e, t).catch(s => {
            throw new Error(`exception ${s} sending request`)
        }
        )
    }
    getDefaultHeaders() {
        const e = {}
          , t = DP + " " + this.clientOptions.userAgentExtra;
        return e[IP] = t,
        e[wP] = t,
        e[CP] = "application/json",
        e
    }
    async getHeadersInternal(e) {
        const t = new Headers;
        if (e && e.headers) {
            for (const [s,o] of Object.entries(e.headers))
                t.append(s, o);
            e.timeout && e.timeout > 0 && t.append(RP, String(Math.ceil(e.timeout / 1e3)))
        }
        return await this.clientOptions.auth.addAuthHeaders(t),
        t
    }
    async uploadFile(e, t) {
        var s;
        const o = {};
        t != null && (o.mimeType = t.mimeType,
        o.name = t.name,
        o.displayName = t.displayName),
        o.name && !o.name.startsWith("files/") && (o.name = `files/${o.name}`);
        const l = this.clientOptions.uploader
          , f = await l.stat(e);
        o.sizeBytes = String(f.size);
        const d = (s = t == null ? void 0 : t.mimeType) !== null && s !== void 0 ? s : f.type;
        if (d === void 0 || d === "")
            throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
        o.mimeType = d;
        const v = await this.fetchUploadUrl(o, t);
        return l.upload(e, v, this)
    }
    async fetchUploadUrl(e, t) {
        var s;
        let o = {};
        t != null && t.httpOptions ? o = t.httpOptions : o = {
            apiVersion: "",
            headers: {
                "Content-Type": "application/json",
                "X-Goog-Upload-Protocol": "resumable",
                "X-Goog-Upload-Command": "start",
                "X-Goog-Upload-Header-Content-Length": `${e.sizeBytes}`,
                "X-Goog-Upload-Header-Content-Type": `${e.mimeType}`
            }
        };
        const l = {
            file: e
        }
          , f = await this.request({
            path: Se("upload/v1beta/files", l._url),
            body: JSON.stringify(l),
            httpMethod: "POST",
            httpOptions: o
        });
        if (!f || !(f != null && f.headers))
            throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");
        const d = (s = f == null ? void 0 : f.headers) === null || s === void 0 ? void 0 : s["x-goog-upload-url"];
        if (d === void 0)
            throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");
        return d
    }
}
async function CT(r) {
    var e;
    if (r === void 0)
        throw new Wd("response is undefined");
    if (!r.ok) {
        const t = r.status
          , s = r.statusText;
        let o;
        !((e = r.headers.get("content-type")) === null || e === void 0) && e.includes("application/json") ? o = await r.json() : o = {
            error: {
                message: await r.text(),
                code: r.status,
                status: r.statusText
            }
        };
        const l = `got status: ${t} ${s}. ${JSON.stringify(o)}`;
        throw t >= 400 && t < 500 ? new k0(l) : t >= 500 && t < 600 ? new Wd(l) : new Error(l)
    }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function PP(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["_url", "name"], s);
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], o),
    t
}
function OP(r, e, t) {
    const s = {}
      , o = p(e, ["pageSize"]);
    t !== void 0 && o != null && m(t, ["_query", "pageSize"], o);
    const l = p(e, ["pageToken"]);
    t !== void 0 && l != null && m(t, ["_query", "pageToken"], l);
    const f = p(e, ["filter"]);
    return t !== void 0 && f != null && m(t, ["_query", "filter"], f),
    s
}
function VP(r, e) {
    const t = {}
      , s = p(e, ["config"]);
    return s != null && m(t, ["config"], OP(r, s, t)),
    t
}
function UP(r, e) {
    const t = {}
      , s = p(e, ["textInput"]);
    s != null && m(t, ["textInput"], s);
    const o = p(e, ["output"]);
    return o != null && m(t, ["output"], o),
    t
}
function kP(r, e) {
    const t = {};
    if (p(e, ["gcsUri"]) !== void 0)
        throw new Error("gcsUri parameter is not supported in Gemini API.");
    const s = p(e, ["examples"]);
    if (s != null) {
        let o = s;
        Array.isArray(o) && (o = o.map(l => UP(r, l))),
        m(t, ["examples", "examples"], o)
    }
    return t
}
function LP(r, e, t) {
    const s = {};
    if (p(e, ["validationDataset"]) !== void 0)
        throw new Error("validationDataset parameter is not supported in Gemini API.");
    const o = p(e, ["tunedModelDisplayName"]);
    if (t !== void 0 && o != null && m(t, ["displayName"], o),
    p(e, ["description"]) !== void 0)
        throw new Error("description parameter is not supported in Gemini API.");
    const l = p(e, ["epochCount"]);
    t !== void 0 && l != null && m(t, ["tuningTask", "hyperparameters", "epochCount"], l);
    const f = p(e, ["learningRateMultiplier"]);
    if (f != null && m(s, ["tuningTask", "hyperparameters", "learningRateMultiplier"], f),
    p(e, ["adapterSize"]) !== void 0)
        throw new Error("adapterSize parameter is not supported in Gemini API.");
    const d = p(e, ["batchSize"]);
    t !== void 0 && d != null && m(t, ["tuningTask", "hyperparameters", "batchSize"], d);
    const v = p(e, ["learningRate"]);
    return t !== void 0 && v != null && m(t, ["tuningTask", "hyperparameters", "learningRate"], v),
    s
}
function BP(r, e) {
    const t = {}
      , s = p(e, ["baseModel"]);
    s != null && m(t, ["baseModel"], s);
    const o = p(e, ["trainingDataset"]);
    o != null && m(t, ["tuningTask", "trainingData"], kP(r, o));
    const l = p(e, ["config"]);
    return l != null && m(t, ["config"], LP(r, l, t)),
    t
}
function qP(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["_url", "name"], s);
    const o = p(e, ["config"]);
    return o != null && m(t, ["config"], o),
    t
}
function zP(r, e, t) {
    const s = {}
      , o = p(e, ["pageSize"]);
    t !== void 0 && o != null && m(t, ["_query", "pageSize"], o);
    const l = p(e, ["pageToken"]);
    t !== void 0 && l != null && m(t, ["_query", "pageToken"], l);
    const f = p(e, ["filter"]);
    return t !== void 0 && f != null && m(t, ["_query", "filter"], f),
    s
}
function FP(r, e) {
    const t = {}
      , s = p(e, ["config"]);
    return s != null && m(t, ["config"], zP(r, s, t)),
    t
}
function HP(r, e, t) {
    const s = {}
      , o = p(e, ["gcsUri"]);
    if (t !== void 0 && o != null && m(t, ["supervisedTuningSpec", "trainingDatasetUri"], o),
    p(e, ["examples"]) !== void 0)
        throw new Error("examples parameter is not supported in Vertex AI.");
    return s
}
function GP(r, e) {
    const t = {}
      , s = p(e, ["gcsUri"]);
    return s != null && m(t, ["validationDatasetUri"], s),
    t
}
function YP(r, e, t) {
    const s = {}
      , o = p(e, ["validationDataset"]);
    t !== void 0 && o != null && m(t, ["supervisedTuningSpec"], GP(r, o));
    const l = p(e, ["tunedModelDisplayName"]);
    t !== void 0 && l != null && m(t, ["tunedModelDisplayName"], l);
    const f = p(e, ["description"]);
    t !== void 0 && f != null && m(t, ["description"], f);
    const d = p(e, ["epochCount"]);
    t !== void 0 && d != null && m(t, ["supervisedTuningSpec", "hyperParameters", "epochCount"], d);
    const v = p(e, ["learningRateMultiplier"]);
    t !== void 0 && v != null && m(t, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], v);
    const y = p(e, ["adapterSize"]);
    if (t !== void 0 && y != null && m(t, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], y),
    p(e, ["batchSize"]) !== void 0)
        throw new Error("batchSize parameter is not supported in Vertex AI.");
    if (p(e, ["learningRate"]) !== void 0)
        throw new Error("learningRate parameter is not supported in Vertex AI.");
    return s
}
function KP(r, e) {
    const t = {}
      , s = p(e, ["baseModel"]);
    s != null && m(t, ["baseModel"], s);
    const o = p(e, ["trainingDataset"]);
    o != null && m(t, ["supervisedTuningSpec", "trainingDatasetUri"], HP(r, o, t));
    const l = p(e, ["config"]);
    return l != null && m(t, ["config"], YP(r, l, t)),
    t
}
function QP(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["model"], s);
    const o = p(e, ["name"]);
    return o != null && m(t, ["endpoint"], o),
    t
}
function L0(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["name"], s);
    const o = p(e, ["state"]);
    o != null && m(t, ["state"], N0(r, o));
    const l = p(e, ["createTime"]);
    l != null && m(t, ["createTime"], l);
    const f = p(e, ["tuningTask", "startTime"]);
    f != null && m(t, ["startTime"], f);
    const d = p(e, ["tuningTask", "completeTime"]);
    d != null && m(t, ["endTime"], d);
    const v = p(e, ["updateTime"]);
    v != null && m(t, ["updateTime"], v);
    const y = p(e, ["description"]);
    y != null && m(t, ["description"], y);
    const T = p(e, ["baseModel"]);
    T != null && m(t, ["baseModel"], T);
    const A = p(e, ["_self"]);
    A != null && m(t, ["tunedModel"], QP(r, A));
    const I = p(e, ["distillationSpec"]);
    I != null && m(t, ["distillationSpec"], I);
    const V = p(e, ["experiment"]);
    V != null && m(t, ["experiment"], V);
    const q = p(e, ["labels"]);
    q != null && m(t, ["labels"], q);
    const G = p(e, ["pipelineJob"]);
    G != null && m(t, ["pipelineJob"], G);
    const J = p(e, ["tunedModelDisplayName"]);
    return J != null && m(t, ["tunedModelDisplayName"], J),
    t
}
function XP(r, e) {
    const t = {}
      , s = p(e, ["nextPageToken"]);
    s != null && m(t, ["nextPageToken"], s);
    const o = p(e, ["tunedModels"]);
    if (o != null) {
        let l = o;
        Array.isArray(l) && (l = l.map(f => L0(r, f))),
        m(t, ["tuningJobs"], l)
    }
    return t
}
function $P(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["name"], s);
    const o = p(e, ["metadata"]);
    o != null && m(t, ["metadata"], o);
    const l = p(e, ["done"]);
    l != null && m(t, ["done"], l);
    const f = p(e, ["error"]);
    return f != null && m(t, ["error"], f),
    t
}
function JP(r, e) {
    const t = {}
      , s = p(e, ["model"]);
    s != null && m(t, ["model"], s);
    const o = p(e, ["endpoint"]);
    return o != null && m(t, ["endpoint"], o),
    t
}
function Zd(r, e) {
    const t = {}
      , s = p(e, ["name"]);
    s != null && m(t, ["name"], s);
    const o = p(e, ["state"]);
    o != null && m(t, ["state"], N0(r, o));
    const l = p(e, ["createTime"]);
    l != null && m(t, ["createTime"], l);
    const f = p(e, ["startTime"]);
    f != null && m(t, ["startTime"], f);
    const d = p(e, ["endTime"]);
    d != null && m(t, ["endTime"], d);
    const v = p(e, ["updateTime"]);
    v != null && m(t, ["updateTime"], v);
    const y = p(e, ["error"]);
    y != null && m(t, ["error"], y);
    const T = p(e, ["description"]);
    T != null && m(t, ["description"], T);
    const A = p(e, ["baseModel"]);
    A != null && m(t, ["baseModel"], A);
    const I = p(e, ["tunedModel"]);
    I != null && m(t, ["tunedModel"], JP(r, I));
    const V = p(e, ["supervisedTuningSpec"]);
    V != null && m(t, ["supervisedTuningSpec"], V);
    const q = p(e, ["tuningDataStats"]);
    q != null && m(t, ["tuningDataStats"], q);
    const G = p(e, ["encryptionSpec"]);
    G != null && m(t, ["encryptionSpec"], G);
    const J = p(e, ["partnerModelTuningSpec"]);
    J != null && m(t, ["partnerModelTuningSpec"], J);
    const ne = p(e, ["distillationSpec"]);
    ne != null && m(t, ["distillationSpec"], ne);
    const se = p(e, ["experiment"]);
    se != null && m(t, ["experiment"], se);
    const le = p(e, ["labels"]);
    le != null && m(t, ["labels"], le);
    const ue = p(e, ["pipelineJob"]);
    ue != null && m(t, ["pipelineJob"], ue);
    const fe = p(e, ["tunedModelDisplayName"]);
    return fe != null && m(t, ["tunedModelDisplayName"], fe),
    t
}
function jP(r, e) {
    const t = {}
      , s = p(e, ["nextPageToken"]);
    s != null && m(t, ["nextPageToken"], s);
    const o = p(e, ["tuningJobs"]);
    if (o != null) {
        let l = o;
        Array.isArray(l) && (l = l.map(f => Zd(r, f))),
        m(t, ["tuningJobs"], l)
    }
    return t
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class WP extends Ol {
    constructor(e) {
        super(),
        this.apiClient = e,
        this.get = async t => await this.getInternal(t),
        this.list = async (t={}) => new kp(Sl.PAGED_ITEM_TUNING_JOBS,s => this.listInternal(s),await this.listInternal(t),t),
        this.tune = async t => {
            if (this.apiClient.isVertexAI())
                return await this.tuneInternal(t);
            {
                const s = await this.tuneMldevInternal(t);
                let o = "";
                return s.metadata !== void 0 && s.metadata.tunedModel !== void 0 ? o = s.metadata.tunedModel : s.name !== void 0 && s.name.includes("/operations/") && (o = s.name.split("/operations/")[0]),
                {
                    name: o,
                    state: Xd.JOB_STATE_QUEUED
                }
            }
        }
    }
    async getInternal(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = qP(this.apiClient, e);
            return d = Se("{name}", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "GET",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(T => T.json()),
            f.then(T => Zd(this.apiClient, T))
        } else {
            const y = PP(this.apiClient, e);
            return d = Se("{name}", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "GET",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }).then(T => T.json()),
            f.then(T => L0(this.apiClient, T))
        }
    }
    async listInternal(e) {
        var t, s, o, l;
        let f, d = "", v = {};
        if (this.apiClient.isVertexAI()) {
            const y = FP(this.apiClient, e);
            return d = Se("tuningJobs", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "GET",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(T => T.json()),
            f.then(T => {
                const A = jP(this.apiClient, T)
                  , I = new uT;
                return Object.assign(I, A),
                I
            }
            )
        } else {
            const y = VP(this.apiClient, e);
            return d = Se("tunedModels", y._url),
            v = y._query,
            delete y.config,
            delete y._url,
            delete y._query,
            f = this.apiClient.request({
                path: d,
                queryParams: v,
                body: JSON.stringify(y),
                httpMethod: "GET",
                httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions,
                abortSignal: (l = e.config) === null || l === void 0 ? void 0 : l.abortSignal
            }).then(T => T.json()),
            f.then(T => {
                const A = XP(this.apiClient, T)
                  , I = new uT;
                return Object.assign(I, A),
                I
            }
            )
        }
    }
    async tuneInternal(e) {
        var t, s;
        let o, l = "", f = {};
        if (this.apiClient.isVertexAI()) {
            const d = KP(this.apiClient, e);
            return l = Se("tuningJobs", d._url),
            f = d._query,
            delete d.config,
            delete d._url,
            delete d._query,
            o = this.apiClient.request({
                path: l,
                queryParams: f,
                body: JSON.stringify(d),
                httpMethod: "POST",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(v => v.json()),
            o.then(v => Zd(this.apiClient, v))
        } else
            throw new Error("This method is only supported by the Vertex AI.")
    }
    async tuneMldevInternal(e) {
        var t, s;
        let o, l = "", f = {};
        if (this.apiClient.isVertexAI())
            throw new Error("This method is only supported by the Gemini Developer API.");
        {
            const d = BP(this.apiClient, e);
            return l = Se("tunedModels", d._url),
            f = d._query,
            delete d.config,
            delete d._url,
            delete d._query,
            o = this.apiClient.request({
                path: l,
                queryParams: f,
                body: JSON.stringify(d),
                httpMethod: "POST",
                httpOptions: (t = e.config) === null || t === void 0 ? void 0 : t.httpOptions,
                abortSignal: (s = e.config) === null || s === void 0 ? void 0 : s.abortSignal
            }).then(v => v.json()),
            o.then(v => $P(this.apiClient, v))
        }
    }
}
const ZP = 1024 * 1024 * 8;
async function e2(r, e, t) {
    var s, o;
    let l = 0
      , f = 0
      , d = new $d(new Response)
      , v = "upload";
    for (l = r.size; f < l; ) {
        const T = Math.min(ZP, l - f)
          , A = r.slice(f, f + T);
        if (f + T >= l && (v += ", finalize"),
        d = await t.request({
            path: "",
            body: A,
            httpMethod: "POST",
            httpOptions: {
                apiVersion: "",
                baseUrl: e,
                headers: {
                    "X-Goog-Upload-Command": v,
                    "X-Goog-Upload-Offset": String(f),
                    "Content-Length": String(T)
                }
            }
        }),
        f += T,
        ((s = d == null ? void 0 : d.headers) === null || s === void 0 ? void 0 : s["x-goog-upload-status"]) !== "active")
            break;
        if (l <= f)
            throw new Error("All content has been uploaded, but the upload status is not finalized.")
    }
    const y = await (d == null ? void 0 : d.json());
    if (((o = d == null ? void 0 : d.headers) === null || o === void 0 ? void 0 : o["x-goog-upload-status"]) !== "final")
        throw new Error("Failed to upload file: Upload status is not finalized.");
    return y.file
}
async function t2(r) {
    return {
        size: r.size,
        type: r.type
    }
}
class n2 {
    async upload(e, t, s) {
        if (typeof e == "string")
            throw new Error("File path is not supported in browser uploader.");
        return await e2(e, t, s)
    }
    async stat(e) {
        if (typeof e == "string")
            throw new Error("File path is not supported in browser uploader.");
        return await t2(e)
    }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class i2 {
    create(e, t, s) {
        return new r2(e,t,s)
    }
}
class r2 {
    constructor(e, t, s) {
        this.url = e,
        this.headers = t,
        this.callbacks = s
    }
    connect() {
        this.ws = new WebSocket(this.url),
        this.ws.onopen = this.callbacks.onopen,
        this.ws.onerror = this.callbacks.onerror,
        this.ws.onclose = this.callbacks.onclose,
        this.ws.onmessage = this.callbacks.onmessage
    }
    send(e) {
        if (this.ws === void 0)
            throw new Error("WebSocket is not connected");
        this.ws.send(e)
    }
    close() {
        if (this.ws === void 0)
            throw new Error("WebSocket is not connected");
        this.ws.close()
    }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const RT = "x-goog-api-key";
class s2 {
    constructor(e) {
        this.apiKey = e
    }
    async addAuthHeaders(e) {
        e.get(RT) === null && e.append(RT, this.apiKey)
    }
}
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const o2 = "gl-node/";
class a2 {
    constructor(e) {
        var t;
        if (e.apiKey == null)
            throw new Error("An API Key must be set when running in a browser");
        if (e.project || e.location)
            throw new Error("Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location.");
        this.vertexai = (t = e.vertexai) !== null && t !== void 0 ? t : !1,
        this.apiKey = e.apiKey;
        const s = gM(e, void 0, void 0);
        s && (e.httpOptions ? e.httpOptions.baseUrl = s : e.httpOptions = {
            baseUrl: s
        }),
        this.apiVersion = e.apiVersion;
        const o = new s2(this.apiKey);
        this.apiClient = new xP({
            auth: o,
            apiVersion: this.apiVersion,
            apiKey: this.apiKey,
            vertexai: this.vertexai,
            httpOptions: e.httpOptions,
            userAgentExtra: o2 + "web",
            uploader: new n2
        }),
        this.models = new hP(this.apiClient),
        this.live = new aP(this.apiClient,o,new i2),
        this.chats = new l1(this.models,this.apiClient),
        this.caches = new r1(this.apiClient),
        this.files = new E1(this.apiClient),
        this.operations = new AP(this.apiClient),
        this.tunings = new WP(this.apiClient)
    }
}
const l2 = new a2({
    apiKey: "AIzaSyBT2-Mss3y3v2mz780dX_NEC4E5Z2B5uSs"
});
function u2({setPage: r}) {
    const [e,t] = dt.useState([])
      , [s,o] = dt.useState("")
      , [l,f] = dt.useState(!1)
      , d = async () => {
        if (s.trim() === "")
            return;
        const T = {
            text: s,
            isCurrentUser: !0
        };
        t(A => [...A, T]),
        o(""),
        f(!0);
        try {
            const I = {
                text: (await l2.models.generateContent({
                    model: "gemini-2.0-flash",
                    contents: s
                })).text,
                isCurrentUser: !1
            };
            t(V => [...V, I])
        } catch (A) {
            console.error("Error communicating with AI:", A);
            const I = {
                text: "Sorry, I couldn't process your request. Please try again later.",
                isCurrentUser: !1
            };
            t(V => [...V, I])
        } finally {
            f(!1)
        }
    }
      , v = T => {
        T.key === "Enter" && d()
    }
      , y = () => {
        alert("You have left the chat."),
        r("profile")
    }
    ;
    return b.jsxs("div", {
        className: "chatbox",
        children: [b.jsxs("div", {
            id: "chat-header",
            style: {
                animation: "fadeIn 1s"
            },
            children: [b.jsx("span", {
                id: "back-button",
                onClick: y,
                style: {
                    cursor: "pointer"
                },
                children: "←"
            }), b.jsx("h2", {
                style: {
                    animation: "slideIn 1s"
                },
                children: "AI Chat"
            })]
        }), b.jsxs("div", {
            id: "chat-container",
            children: [e.map( (T, A) => b.jsx("div", {
                className: `message ${T.isCurrentUser ? "right" : "left"}`,
                style: {
                    animation: T.isCurrentUser ? "slideInRight 0.5s" : "slideInLeft 0.5s"
                },
                children: b.jsx("span", {
                    children: T.text
                })
            }, A)), l && b.jsx("div", {
                className: "message left",
                style: {
                    animation: "fadeIn 0.5s"
                },
                children: b.jsx("span", {
                    children: "Typing..."
                })
            })]
        }), b.jsxs("div", {
            id: "input-container",
            style: {
                animation: "fadeInUp 1s"
            },
            children: [b.jsx("input", {
                type: "text",
                id: "message-input",
                placeholder: "Type your message...",
                value: s,
                onChange: T => o(T.target.value),
                onKeyPress: v,
                style: {
                    transition: "box-shadow 0.3s",
                    boxShadow: s ? "0 0 10px rgba(33, 150, 243, 0.5)" : "none"
                }
            }), b.jsx("button", {
                id: "send-button",
                onClick: d,
                disabled: !s.trim() || l,
                style: {
                    backgroundColor: l ? "#ccc" : "#2196F3",
                    color: l ? "#666" : "#fff",
                    transition: "background-color 0.3s, transform 0.2s",
                    transform: l ? "scale(0.95)" : "scale(1)"
                },
                children: l ? "Loading..." : "Send"
            })]
        })]
    })
}
const c2 = (r, e) => r === e
  , f2 = (r, e) => r === e
  , h2 = r => window.confirm(r)
  , d2 = ({setPage: r}) => {
    const [e,t] = dt.useState(null)
      , [s,o] = dt.useState({
        currentPass: "",
        newPass: "",
        confirmNewPass: "",
        currentEmail: "",
        newEmail: "",
        confirmNewEmail: "",
        deletePass: ""
    })
      , l = async () => {
        try {
            await lI(xo),
            alert("Successfully logged out!"),
            r("home")
        } catch (G) {
            console.error("Logout failed", G),
            alert("Failed to log out. Please try again.")
        }
    }
      , f = G => t(G)
      , d = () => {
        t(null),
        o({
            currentPass: "",
            newPass: "",
            confirmNewPass: "",
            currentEmail: "",
            newEmail: "",
            confirmNewEmail: "",
            deletePass: ""
        })
    }
      , v = G => {
        const {id: J, value: ne} = G.target;
        o(se => ({
            ...se,
            [J]: ne
        }))
    }
      , y = () => {
        const {newPass: G, confirmNewPass: J} = s;
        if (!c2(G, J)) {
            alert("New passwords do not match!");
            return
        }
        alert("Password changed successfully!"),
        d()
    }
      , T = () => {
        const {newEmail: G, confirmNewEmail: J} = s;
        if (!f2(G, J)) {
            alert("Emails do not match!");
            return
        }
        alert("Email changed successfully!"),
        d()
    }
      , A = () => {
        const {deletePass: G} = s;
        if (!G) {
            alert("Please enter your password to confirm.");
            return
        }
        h2("This action is irreversible. Are you sure?") && (alert("Account deleted."),
        d())
    }
      , [I,V] = dt.useState(!1)
      , q = () => {
        V(!I)
    }
    ;
    return b.jsxs("div", {
        className: "settings-page",
        children: [b.jsx("img", {
            src: Yi,
            className: "profile-icon",
            alt: "Profile"
        }), b.jsxs("div", {
            id: "newnavbar",
            children: [b.jsx("button", {
                onClick: q,
                style: {},
                children: "☰"
            }), b.jsxs("div", {
                className: `sliding-panel ${I ? "visible" : ""}`,
                children: [b.jsx("button", {
                    className: "close-panel",
                    onClick: q,
                    children: "✖"
                }), b.jsxs("ul", {
                    children: [b.jsx("li", {
                        onClick: () => r("profile"),
                        children: "Home"
                    }), b.jsx("li", {
                        onClick: () => r("dmlist"),
                        children: "DmList"
                    }), b.jsx("li", {
                        onClick: () => r("drlist"),
                        children: "DrList"
                    }), b.jsx("li", {
                        onClick: () => r("chatbox"),
                        children: "Chat"
                    }), b.jsx("li", {
                        onClick: () => r("settings"),
                        children: "Settings"
                    })]
                })]
            })]
        }), b.jsxs("header", {
            children: [b.jsx("h1", {
                style: {
                    marginTop: "0em"
                },
                children: "Dr.Finder"
            }), b.jsx("h1", {
                style: {
                    fontSize: "50px"
                },
                children: "Settings"
            })]
        }), b.jsx("img", {
            src: Yi,
            style: {
                width: "200px",
                height: "2",
                borderRadius: "50%",
                position: "absolute",
                marginTop: "8em"
            },
            alt: "Profile"
        }), b.jsxs("div", {
            className: "settings-buttons",
            style: {
                position: "absolute",
                marginTop: "23em"
            },
            children: [b.jsx("button", {
                onClick: () => r("changeUser"),
                onMouseOver: G => {
                    G.currentTarget.style.transform = "scale(1.05)",
                    G.currentTarget.style.backgroundColor = "#c9c7c7"
                }
                ,
                onMouseOut: G => {
                    G.currentTarget.style.transform = "scale(1)",
                    G.currentTarget.style.backgroundColor = "#ddd"
                }
                ,
                children: "Change User"
            }), b.jsx("button", {
                onClick: () => f("password"),
                onMouseOver: G => {
                    G.currentTarget.style.transform = "scale(1.05)",
                    G.currentTarget.style.backgroundColor = "#c9c7c7"
                }
                ,
                onMouseOut: G => {
                    G.currentTarget.style.transform = "scale(1)",
                    G.currentTarget.style.backgroundColor = "#ddd"
                }
                ,
                children: "Change Password"
            }), b.jsx("button", {
                onClick: () => f("email"),
                onMouseOver: G => {
                    G.currentTarget.style.transform = "scale(1.05)",
                    G.currentTarget.style.backgroundColor = "#c9c7c7"
                }
                ,
                onMouseOut: G => {
                    G.currentTarget.style.transform = "scale(1)",
                    G.currentTarget.style.backgroundColor = "#ddd"
                }
                ,
                children: "Change Email"
            }), b.jsx("button", {
                onClick: l,
                onMouseOver: G => {
                    G.currentTarget.style.transform = "scale(1.05)",
                    G.currentTarget.style.backgroundColor = "#c9c7c7"
                }
                ,
                onMouseOut: G => {
                    G.currentTarget.style.transform = "scale(1)",
                    G.currentTarget.style.backgroundColor = "#ddd"
                }
                ,
                children: "Log Out"
            }), b.jsx("button", {
                className: "delete",
                onClick: () => f("delete"),
                onMouseOver: G => {
                    G.currentTarget.style.transform = "scale(1.05)",
                    G.currentTarget.style.backgroundColor = "#c9c7c7"
                }
                ,
                onMouseOut: G => {
                    G.currentTarget.style.transform = "scale(1)",
                    G.currentTarget.style.backgroundColor = "#ddd"
                }
                ,
                children: "Delete Account"
            })]
        }), e === "password" && b.jsx("div", {
            className: "popup-overlay",
            children: b.jsxs("div", {
                className: "popup",
                children: [b.jsx("span", {
                    className: "close",
                    onClick: d,
                    children: "×"
                }), b.jsx("h2", {
                    children: "Change Password"
                }), b.jsx("input", {
                    type: "password",
                    placeholder: "Current Password",
                    id: "currentPass",
                    value: s.currentPass,
                    onChange: v
                }), b.jsx("input", {
                    type: "password",
                    placeholder: "New Password",
                    id: "newPass",
                    value: s.newPass,
                    onChange: v
                }), b.jsx("input", {
                    type: "password",
                    placeholder: "Confirm New Password",
                    id: "confirmNewPass",
                    value: s.confirmNewPass,
                    onChange: v
                }), b.jsx("button", {
                    onClick: y,
                    children: "Submit"
                })]
            })
        }), e === "email" && b.jsx("div", {
            className: "popup-overlay",
            children: b.jsxs("div", {
                className: "popup",
                children: [b.jsx("span", {
                    className: "close",
                    onClick: d,
                    children: "×"
                }), b.jsx("h2", {
                    children: "Change Email"
                }), b.jsx("input", {
                    type: "email",
                    placeholder: "Current Email",
                    id: "currentEmail",
                    value: s.currentEmail,
                    onChange: v
                }), b.jsx("input", {
                    type: "email",
                    placeholder: "New Email",
                    id: "newEmail",
                    value: s.newEmail,
                    onChange: v
                }), b.jsx("input", {
                    type: "email",
                    placeholder: "Confirm New Email",
                    id: "confirmNewEmail",
                    value: s.confirmNewEmail,
                    onChange: v
                }), b.jsx("button", {
                    onClick: T,
                    children: "Submit"
                })]
            })
        }), e === "delete" && b.jsx("div", {
            className: "popup-overlay",
            children: b.jsxs("div", {
                className: "popup",
                children: [b.jsx("span", {
                    className: "close",
                    onClick: d,
                    children: "×"
                }), b.jsx("h2", {
                    children: "Do you really want to delete your account?"
                }), b.jsx("input", {
                    type: "password",
                    placeholder: "Type password to confirm",
                    id: "deletePass",
                    value: s.deletePass,
                    onChange: v
                }), b.jsx("button", {
                    className: "delete-btn",
                    onClick: A,
                    children: "Delete Account"
                })]
            })
        })]
    })
}
;
function p2({setPage: r}) {
    const [e,t] = dt.useState([])
      , [s,o] = dt.useState("")
      , [l,f] = dt.useState(!1)
      , d = async () => {
        if (s.trim() === "")
            return;
        const T = {
            text: s,
            isCurrentUser: !0
        };
        t(A => [...A, T]),
        o(""),
        setTimeout( () => {
            t(A => [...A, {
                text: "This is a response from the other user.",
                isCurrentUser: !1
            }])
        }
        , 1e3)
    }
      , v = T => {
        T.key === "Enter" && d()
    }
      , y = () => {
        alert("You have left the chat."),
        r("profile")
    }
    ;
    return b.jsxs("div", {
        className: "chatbox",
        children: [b.jsxs("div", {
            id: "chat-header",
            style: {
                animation: "fadeIn 1s"
            },
            children: [b.jsx("span", {
                id: "back-button",
                onClick: y,
                style: {
                    cursor: "pointer"
                },
                children: "←"
            }), b.jsx("h2", {
                style: {
                    animation: "slideIn 1s"
                },
                children: "Chat with Doctor"
            })]
        }), b.jsxs("div", {
            id: "chat-container",
            children: [e.map( (T, A) => b.jsx("div", {
                className: `message ${T.isCurrentUser ? "right" : "left"}`,
                style: {
                    animation: T.isCurrentUser ? "slideInRight 0.5s" : "slideInLeft 0.5s"
                },
                children: b.jsx("span", {
                    children: T.text
                })
            }, A)), l && b.jsx("div", {
                className: "message left",
                style: {
                    animation: "fadeIn 0.5s"
                },
                children: b.jsx("span", {
                    children: "Typing..."
                })
            })]
        }), b.jsxs("div", {
            id: "input-container",
            style: {
                animation: "fadeInUp 1s"
            },
            children: [b.jsx("input", {
                type: "text",
                id: "message-input",
                placeholder: "Type your message...",
                value: s,
                onChange: T => o(T.target.value),
                onKeyPress: v,
                style: {
                    transition: "box-shadow 0.3s",
                    boxShadow: s ? "0 0 10px rgba(33, 150, 243, 0.5)" : "none"
                }
            }), b.jsx("button", {
                id: "send-button",
                onClick: d,
                disabled: !s.trim() || l,
                style: {
                    backgroundColor: l ? "#ccc" : "#2196F3",
                    color: l ? "#666" : "#fff",
                    transition: "background-color 0.3s, transform 0.2s",
                    transform: l ? "scale(0.95)" : "scale(1)"
                },
                children: l ? "Loading..." : "Send"
            })]
        })]
    })
}
function m2() {
    const [r,e] = dt.useState("home");
    return b.jsxs(b.Fragment, {
        children: [r === "home" && b.jsx(EA, {
            setPage: e
        }), r === "login" && b.jsx(uM, {
            setPage: e
        }), r === "profile" && b.jsx(cM, {
            setPage: e
        }), r === "dmlist" && b.jsx(fM, {
            setPage: e
        }), r === "drlist" && b.jsx(hM, {
            setPage: e
        }), r === "chatbox" && b.jsx(u2, {
            setPage: e
        }), r === "settings" && b.jsx(d2, {
            setPage: e
        }), r === "chatwithdoctor" && b.jsx(p2, {
            setPage: e
        })]
    })
}
vA.createRoot(document.getElementById("root")).render(b.jsx(dt.StrictMode, {
    children: b.jsx(m2, {})
}));
